<html lang="en">
    <head>
        <meta charset="utf-8" />
        <link
            crossorigin="anonymous"
            href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/4.1.1/slate/bootstrap.min.css"
            id="theme"
            rel="stylesheet"
        />
        <style type="text/css">
            .table th {
                border-top: 0;
            }

            .form-control {
                padding: 0.3rem 0.4rem;
            }

            .theme-slate g.hovertext text.name {
                fill: #cccccc !important;
            }

            .theme-yeti g.hovertext text.name {
                fill: #495057 !important;
            }

            .theme-slate g.hovertext rect {
                fill: #272b30 !important;
                fill-opacity: 0.9 !important;
            }

            .theme-yeti g.hovertext rect {
                fill: #fff !important;
                fill-opacity: 0.9 !important;
            }

            .scrollable-y {
                overflow-y: auto;
                scrollbar-width: thin;
            }

            .scrollable-x {
                overflow-x: auto;
                scrollbar-width: thin;
            }

            .theme-yeti ::-webkit-scrollbar {
                width: 6px;
                height: 6px;
                background-color: #dddddd;
            }

            .theme-yeti ::-webkit-scrollbar-thumb {
                background-color: #888888;
                border-radius: 10px;
            }

            .theme-yeti ::-webkit-scrollbar-track {
                -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
                background-color: #dddddd;
            }

            .theme-slate ::-webkit-scrollbar {
                width: 6px;
                height: 6px;
                background-color: #888888;
            }

            .theme-slate ::-webkit-scrollbar-thumb {
                background-color: #dddddd;
                border-radius: 10px;
            }

            .theme-slate ::-webkit-scrollbar-track {
                -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
                background-color: #888888;
            }

            .ei-container-big {
                min-width: 1900px;
                margin-right: auto;
                margin-left: auto;
            }

            .ei-container-small {
                max-width: min(1600px, 90%);
                min-width: 1450px;
                margin-right: auto;
                margin-left: auto;
            }

            .buff-display {
                width: 250px;
            }

            .buff-container {
                position: relative;
                text-align: center;
                height: 18px;
                margin-right: 0.05em;
            }

            .buff-number {
                position: absolute;
                pointer-events: none;
                font-size: 0.5em;
                left: 20%;
                top: 65%;
                text-shadow: -2px -2px 3px #000000, -2px 2px 3px #000000,
                    2px -2px 3px #000000, 0px 2px 3px #000000,
                    0px -2px 3px #000000, 2px 0px 3px #000000,
                    -2px 0px 3px #000000, 2px 2px 3px #000000;
                font-weight: bold;
                color: #fff;
                width: 100%;
            }

            .scale85 {
                transform: scale(0.85, 0.85) !important;
            }

            .scale75 {
                transform: scale(0.75, 0.75) !important;
            }

            .scale65 {
                transform: scale(0.65, 0.65) !important;
            }

            .player-status-rotation {
                height: 48px;
            }

            .player-status {
                color: #dddddd;
                width: 170px;
                height: 35px;
                cursor: pointer;
                user-select: none;
            }

            .actor-rotation {
                width: 150px;
                height: 48px;
            }

            .target-status {
                color: #dddddd;
                width: 210px;
                height: 35px;
                cursor: pointer;
                user-select: none;
            }

            .cr-hp-display {
                font-size: 0.65rem;
                position: relative;
                width: 45px;
                top: -12px;
                left: 0%;
                height: 16px;
                pointer-events: none;
            }

            .cr-barrier-display {
                font-size: 0.65rem;
                position: relative;
                width: 45px;
                top: -44px;
                height: 16px;
                pointer-events: none;
            }

            .cr-barrier {
                position: relative;
                width: 100%;
                top: -99px;
                height: 100%;
                pointer-events: none;
            }

            .cr-breakbar-display {
                font-size: 0.65rem;
                min-height: 16px;
            }

            .cr-breakbar-bar {
                color: #dddddd;
                width: 130px;
                height: 16px;
            }

            .cr-breakbar-phase-display {
                font-size: 0.65rem;
                width: 180px;
            }

            .cr-barrier-display-player {
                left: 68%;
            }

            .cr-barrier-display-target {
                left: 77%;
            }

            h6.actor-shorten-cr {
                width: 100%;
                height: 21px;
                margin-top: 7px;
                margin-bottom: 7px;
                overflow: hidden;
                white-space: nowrap;
                text-overflow: ellipsis;
                vertical-align: middle;
            }

            .squad-details {
                width: 450px;
            }

            .range-btn {
                width: 60px;
            }

            .range-btns {
                width: 200px;
                height: 30px;
            }

            .ply-btn {
                width: 120px;
                overflow: hidden;
                white-space: nowrap;
                text-overflow: ellipsis;
                vertical-align: middle;
            }

            .theme-slate .player-data.active {
                background-color: rgba(80, 86, 92, 0.9);
            }

            .theme-yeti .player-data.active {
                background-color: rgba(220, 220, 220, 0.9);
            }

            .theme-slate .target-data.active {
                background-color: rgba(80, 86, 92, 0.9);
            }

            .theme-yeti .target-data.active {
                background-color: rgba(220, 220, 220, 0.9);
            }

            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                    Roboto, "Helvetica Neue", Arial, sans-serif,
                    "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            }

            .replay {
                border: 2px solid #888888;
            }

            .btn {
                font-weight: 400;
                padding: 0.75rem 1rem;
            }

            .btn-small {
                font-size: 0.9em;
                padding: 0.375rem 0.5rem;
            }

            .btn-ssmall {
                font-size: 0.7em;
                padding: 0.25rem 0.4rem;
            }

            .target-cell,
            .player-cell,
            a {
                cursor: pointer !important;
            }

            .player-cell {
                width: 125px;
                min-height: 90px;
            }

            .theme-yeti .player-cell {
                box-shadow: 1px 0 0 0 #dee2e6, 0 1px 0 0 #dee2e6,
                    1px 1px 0 0 #dee2e6, 1px 0 0 0 #dee2e6 inset,
                    0 1px 0 0 #dee2e6 inset;
            }

            .theme-slate .player-cell {
                box-shadow: 1px 0 0 0 rgb(10, 10, 10), 0 1px 0 0 rgb(10, 10, 10),
                    1px 1px 0 0 rgb(10, 10, 10), 1px 0 0 0 rgb(10, 10, 10) inset,
                    0 1px 0 0 rgb(10, 10, 10) inset;
            }

            .player-cell-shorten {
                display: block;
                text-align: center;
                white-space: nowrap;
                width: 90px;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            h1,
            h2,
            h3,
            h4,
            h5,
            h6,
            .h1,
            .h2,
            .h3,
            .h4,
            .h5,
            .h6 {
                margin-bottom: 0.5rem;
                font-family: inherit;
                font-weight: 500;
                line-height: 1.2;
                color: inherit;
            }

            .header {
                text-align: center;
                width: 100%;
                margin-top: 6px;
                margin-bottom: 10px;
            }

            [v-cloak] {
                display: none;
            }

            .footer {
                text-align: center;
                margin-top: 10px;
                margin-bottom: 6px;
                width: 100%;
            }

            td.sorting_1 {
                background-color: rgba(39, 128, 227, 0.05);
            }

            table {
                font-size: inherit;
            }

            .table > tfoot > tr:first-child > td,
            .table > tfoot > tr:last-child > td {
                border-top-width: 3px;
            }

            .table > tfoot > tr > td {
                color: #888;
            }

            tr.condi td {
                background-color: rgba(255, 0, 0, 0.25);
            }

            tr.hybridH td {
                background-color: rgba(0, 255, 0, 0.25);
            }

            tr.conversionH td {
                background-color: rgba(0, 0, 255, 0.25);
            }

            img.icon-s {
                width: 16px;
                height: 16px;
            }

            img.icon {
                width: 18px;
                height: 18px;
            }

            img.icon-l {
                width: 24px;
                height: 24px;
            }

            .empty-icon-l {
                width: 24px;
                height: 24px;
            }
            img.icon-sl {
                width: 32px;
                height: 32px;
            }

            .empty-icon-sl {
                width: 32px;
                height: 32px;
            }

            .empty-icon-ll {
                width: 48px;
                height: 48px;
            }

            img.icon-ll {
                width: 48px;
                height: 48px;
            }

            img.icon-xl {
                width: 128px;
                height: 128px;
            }

            img.icon-xxl {
                width: 196px;
                height: 196px;
            }

            img.encounter-icon {
                height: 128px;
                object-fit: contain;
            }

            img.icon-lg {
                width: 64px;
                height: 64px;
            }

            img.icon-hover:hover,
            td:hover img.icon-hover,
            th:hover img.icon-hover,
            .table-hover tr:hover td img.icon-hover {
                width: 36px;
                height: 36px;
                margin: -9px;
                position: relative;
                -webkit-filter: drop-shadow(3px 3px 6px #000);
                filter: drop-shadow(3px 3px 6px #000);
                -ms-filter: "progid:DXImageTransform.Microsoft.Dropshadow(OffX=3, OffY=3, Color='#000')";
                filter: "progid:DXImageTransform.Microsoft.Dropshadow(OffX=3, OffY=3, Color='#000')";
            }

            .sub-cell {
                width: 20px;
            }

            .prof-cell {
                width: 5px;
            }

            .cr-ellipsis {
                width: 110px;
                display: block;
                overflow: hidden;
                white-space: nowrap;
                text-overflow: ellipsis;
            }

            .damage-cell {
                width: 150px;
            }

            .stat-cell {
                width: 120px;
            }

            .damage-dist-cell {
                width: 100px;
            }

            .name-cr-cell {
                min-width: 110px;
            }

            .damage-cr-cell-small {
                min-width: 90px;
            }

            .damage-cr-cell {
                min-width: 110px;
            }

            .sub-tabs {
                margin-top: 10px;
            }

            td,
            th {
                text-align: center;
                white-space: nowrap;
            }

            .tooltip-inner {
                max-width: 400px;
            }

            .theme-slate .nav-tabs .nav-link.active {
                background-image: -webkit-gradient(
                    linear,
                    left top,
                    left bottom,
                    from(#484e55),
                    color-stop(60%, #3a3f44),
                    to(#313539)
                );
                background-image: linear-gradient(
                    #484e55,
                    #3a3f44 60%,
                    #313539
                );
                background-repeat: no-repeat;
                border-bottom-color: transparent;
            }

            .theme-slate .nav-tabs .nav-link,
            .theme-slate .nav-tabs .nav-link:hover {
                color: #aaa;
            }

            .theme-slate .nav-tabs .nav-link:hover {
                color: #fff;
            }

            .theme-yeti .nav-pills .nav-link:not(.active) {
                background-color: #eee;
                border: 1px solid #e1e1e1;
            }

            .theme-yeti .nav-pills .nav-link:hover,
            .theme-yeti .nav-pills .nav-link:focus {
                background-color: #008cba;
                border-color: #0079a1;
            }

            .nav-tabs {
                margin-top: 0.5rem;
            }

            .rot-icon {
                width: 30px;
                height: 30px;
            }

            .rot-cancelled {
                border: 2px solid #ff0000;
            }

            .rot-animfull {
                border: 2px solid #00ff00;
            }

            .rot-unknown {
                border: 2px solid #ffff00;
            }

            .rot-instant {
                border: 2px solid #00ffff;
            }

            .rot-small .rot-icon {
                width: 20px;
                height: 20px;
            }

            .rot-small .rot-cancelled {
                border: 1px solid #ff0000;
            }

            .rot-small .rot-animfull {
                border: 1px solid #00ff00;
            }

            .rot-small .rot-unknown {
                border: 1px solid #ffff00;
            }

            .rot-swap:after {
                content: "\A";
                white-space: pre;
            }

            .rot-highlight:not(.rot-highlight-active) {
                opacity: 0.5;
                filter: grayscale(0.7);
            }

            .theme-slate .player-cell.active {
                background-color: rgba(50, 120, 0, 0.5);
            }

            .theme-slate .player-cell:hover:not(.active) {
                background-color: rgba(40, 75, 0, 0.5);
            }

            .theme-yeti .player-cell.active {
                background-color: rgba(100, 200, 0, 0.5);
            }

            .theme-yeti .player-cell:hover:not(.active) {
                background-color: rgba(120, 240, 0, 0.5);
            }

            .theme-slate .target-cell.active {
                border: 2px solid rgba(50, 120, 0, 0.5);
                border-radius: 50%;
                filter: drop-shadow(0px 0px 6px rgba(50, 120, 0, 1));
            }

            .super-small {
                font-size: 65%;
            }

            .theme-slate .target-cell:hover:not(.active) {
                border: 2px solid rgba(40, 75, 0, 0.5);
                border-radius: 50%;
                filter: drop-shadow(0px 0px 6px rgba(40, 75, 0, 1));
            }

            .theme-yeti .target-cell.active {
                border: 2px solid rgba(100, 200, 0, 0.5);
                border-radius: 50%;
                filter: drop-shadow(0px 0px 6px rgba(100, 200, 0, 1));
            }

            .theme-yeti .target-cell:hover:not(.active) {
                border: 2px solid rgba(120, 240, 0, 0.5);
                border-radius: 50%;
                filter: drop-shadow(0px 0px 6px rgba(120, 240, 0, 1));
            }

            .theme-yeti table tbody tr.active {
                background-color: rgba(100, 200, 0, 0.5);
            }

            .theme-slate table tbody tr.active {
                background-color: rgba(50, 120, 0, 0.5);
            }

            .nav-item .nav-link {
                margin-left: -1px;
                border-radius: 0;
            }

            .nav-item:first-child .nav-link {
                margin-left: 0;
                border-top-left-radius: 0.25rem;
                border-bottom-left-radius: 0.25rem;
            }

            .nav-item:last-child .nav-link {
                border-top-right-radius: 0.25rem;
                border-bottom-right-radius: 0.25rem;
            }

            canvas {
                position: absolute;
            }

            #main-canvas {
                z-index: 2;
            }

            #bg-canvas {
                z-index: 1;
            }

            #picking-canvas {
                z-index: 0;
                opacity: 0;
            }

            .animation-control {
                z-index: 3;
            }

            .combat-replay-mechanics-list-container {
                height: 700px;
            }

            .combat-actor-status-container {
                height: 700px;
            }

            .theme-yeti
                #combat-replay-mechanics-list-container
                > table
                > thead
                > tr
                > th {
                background-color: #fff !important;
            }

            .theme-slate
                #combat-replay-mechanics-list-container
                > table
                > thead
                > tr
                > th {
                background-color: #272b30 !important;
            }

            #combat-replay-mechanics-list-container > table > thead > tr > th {
                position: sticky !important;
                top: 0 !important;
            }

            .combat-replay-mechanics-list-row {
                cursor: pointer;
            }

            .combat-replay-mechanics-list-header > a:hover {
                text-decoration: none;
            }

            .slidercontainer {
                width: 100%;
            }
            .slider {
                width: 100%;
                height: 25px;
                background: rgb(246, 246, 246);
                opacity: 0.7;
                outline: none;
                -webkit-transition: 0.2s;
                transition: opacity 0.2s;
                border-radius: 13px;
            }
            .slider:hover {
                opacity: 0.9;
            }
            /* http://danielstern.ca/range.css/?ref=css-tricks#/ */
            input[type="range"].slider {
                width: 100%;
                background-color: transparent;
                -webkit-appearance: none;
            }
            input[type="range"].slider::-webkit-slider-runnable-track {
                background: rgba(0, 0, 0, 0);
                border: 1px solid rgba(0, 0, 0, 0);
                width: 100%;
                cursor: pointer;
            }
            input[type="range"].slider::-webkit-slider-thumb {
                width: 25px;
                height: 25px;
                background: #00ff00;
                border: 3px solid #00c800;
                border-radius: 13px;
                cursor: pointer;
                -webkit-appearance: none;
            }
            input[type="range"].slider::-moz-range-track {
                background: rgba(0, 0, 0, 0);
                border: 1px solid rgba(0, 0, 0, 0);
                width: 100%;
                cursor: pointer;
            }
            input[type="range"].slider::-moz-range-thumb {
                width: 25px;
                height: 25px;
                background: #00ff00;
                border: 3px solid #00c800;
                border-radius: 13px;
                cursor: pointer;
            }

            thead .sorted,
            thead .sorted_asc,
            thead .sorted_desc {
                cursor: pointer;
                position: relative;
                padding-right: 20px;
            }

            thead .sorted:before,
            thead .sorted_asc:before,
            thead .sorted_desc:before {
                top: 5px;
                right: 0.85em;
                content: "\2191";
                position: absolute;
                display: block;
            }
            thead .sorted:before,
            thead .sorted_desc:before {
                opacity: 0.3;
            }
            thead .sorted_asc:before {
                opacity: 1;
            }

            thead .sorted:after,
            thead .sorted_asc:after,
            thead .sorted_desc:after {
                top: 5px;
                right: 0.5em;
                content: "\2193";
                position: absolute;
                display: block;
            }
            thead .sorted:after,
            thead .sorted_asc:after {
                opacity: 0.3;
            }
            thead .sorted_desc:after {
                opacity: 1;
            }

            td.sorted {
                background-color: rgba(39, 128, 227, 0.05);
            }

            td.lowerOrEqual::before {
                content: "<=";
            }

            td.higherOrEqual::before {
                content: ">=";
            }

            td.approximate::before {
                content: "\2248";
            }

            .scrollabledropdown {
                max-height: 500px;
                overflow: auto;
                overscroll-behavior: contain;
            }

            .card-header {
                padding: 0.25rem 1.25rem !important;
            }

            .card-header-fightMode {
                padding: 0.1rem 1.25rem;
                margin-bottom: 0px;
            }

            .card-body-encounter {
                padding: 1rem !important;
            }

            /* Fight Mode Header - Light Theme */
            .fightModeStory-light {
                background-color: #eeeeee;
            }

            .fightModeQuickplay-light {
                background-color: #32fceb;
            }

            .fightModeEmboldened-light {
                background-color: #39925a;
            }

            .fightModeNormal-light {
                background-color: #00779e;
            }

            .fightModeChallenge-light {
                background-color: #e99002;
            }

            .fightModeLegendary-light {
                background-color: #c9a0ff;
            }

            .fightModeUnknown-light {
                background-color: #ee3000;
            }

            /* Fight Mode Header - Dark Theme */
            .fightModeStory-dark {
                background-color: #515960;
            }

            .fightModeQuickplay-dark {
                background-color: #006858;
            }

            .fightModeEmboldened-dark {
                background-color: #036e09;
            }

            .fightModeNormal-dark {
                background-color: #0c5e94;
            }

            .fightModeChallenge-dark {
                background-color: #736625;
            }

            .fightModeLegendary-dark {
                background-color: #6c4da3;
            }

            .fightModeUnknown-dark {
                background-color: #990000;
            }

            .healthBar {
                height: 7px;
                width: 100%;
                border-radius: 5px;
            }
        </style>
        <link
            href="https://fonts.googleapis.com/css?family=Open+Sans"
            rel="stylesheet"
        />
        <script
            crossorigin="anonymous"
            src="https://code.jquery.com/jquery-3.7.0.min.js"
        ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.1/umd/popper.min.js"></script>
        <script src="https://cdn.plot.ly/plotly-3.0.0.min.js"></script>
        <style id="plotly.js-style-global"></style>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.1/dist/js/bootstrap.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/1.0.10/pako.min.js"></script>
        <script>
            "use strict";

            /*\
    |*|
    |*|  Base64 / binary data / UTF-8 strings utilities
    |*|
    |*|  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding
    |*|
    \*/

            /* Array of bytes to Base64 string decoding */

            function b64ToUint6(nChr) {
                return nChr > 64 && nChr < 91
                    ? nChr - 65
                    : nChr > 96 && nChr < 123
                    ? nChr - 71
                    : nChr > 47 && nChr < 58
                    ? nChr + 4
                    : nChr === 43
                    ? 62
                    : nChr === 47
                    ? 63
                    : 0;
            }

            function base64DecToArr(sBase64, nBlocksSize) {
                var sB64Enc = sBase64.replace(/[^A-Za-z0-9\+\/]/g, ""),
                    nInLen = sB64Enc.length,
                    nOutLen = nBlocksSize
                        ? Math.ceil(((nInLen * 3 + 1) >> 2) / nBlocksSize) *
                          nBlocksSize
                        : (nInLen * 3 + 1) >> 2,
                    taBytes = new Uint8Array(nOutLen);

                for (
                    var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0;
                    nInIdx < nInLen;
                    nInIdx++
                ) {
                    nMod4 = nInIdx & 3;
                    nUint24 |=
                        b64ToUint6(sB64Enc.charCodeAt(nInIdx)) <<
                        (6 * (3 - nMod4));
                    if (nMod4 === 3 || nInLen - nInIdx === 1) {
                        for (
                            nMod3 = 0;
                            nMod3 < 3 && nOutIdx < nOutLen;
                            nMod3++, nOutIdx++
                        ) {
                            taBytes[nOutIdx] =
                                (nUint24 >>> ((16 >>> nMod3) & 24)) & 255;
                        }
                        nUint24 = 0;
                    }
                }

                return taBytes;
            }

            /* Base64 string to array encoding */

            function uint6ToB64(nUint6) {
                return nUint6 < 26
                    ? nUint6 + 65
                    : nUint6 < 52
                    ? nUint6 + 71
                    : nUint6 < 62
                    ? nUint6 - 4
                    : nUint6 === 62
                    ? 43
                    : nUint6 === 63
                    ? 47
                    : 65;
            }

            function base64EncArr(aBytes) {
                var nMod3 = 2,
                    sB64Enc = "";

                for (
                    var nLen = aBytes.length, nUint24 = 0, nIdx = 0;
                    nIdx < nLen;
                    nIdx++
                ) {
                    nMod3 = nIdx % 3;
                    if (nIdx > 0 && ((nIdx * 4) / 3) % 76 === 0) {
                        sB64Enc += "\r\n";
                    }
                    nUint24 |= aBytes[nIdx] << ((16 >>> nMod3) & 24);
                    if (nMod3 === 2 || aBytes.length - nIdx === 1) {
                        sB64Enc += String.fromCharCode(
                            uint6ToB64((nUint24 >>> 18) & 63),
                            uint6ToB64((nUint24 >>> 12) & 63),
                            uint6ToB64((nUint24 >>> 6) & 63),
                            uint6ToB64(nUint24 & 63)
                        );
                        nUint24 = 0;
                    }
                }

                return (
                    sB64Enc.substr(0, sB64Enc.length - 2 + nMod3) +
                    (nMod3 === 2 ? "" : nMod3 === 1 ? "=" : "==")
                );
            }

            /* UTF-8 array to DOMString and vice versa */

            function UTF8ArrToStr(aBytes) {
                var sView = "";

                for (
                    var nPart, nLen = aBytes.length, nIdx = 0;
                    nIdx < nLen;
                    nIdx++
                ) {
                    nPart = aBytes[nIdx];
                    sView += String.fromCharCode(
                        nPart > 251 &&
                            nPart < 254 &&
                            nIdx + 5 < nLen /* six bytes */
                            ? /* (nPart - 252 << 30) may be not so safe in ECMAScript! So...: */
                              (nPart - 252) * 1073741824 +
                                  ((aBytes[++nIdx] - 128) << 24) +
                                  ((aBytes[++nIdx] - 128) << 18) +
                                  ((aBytes[++nIdx] - 128) << 12) +
                                  ((aBytes[++nIdx] - 128) << 6) +
                                  aBytes[++nIdx] -
                                  128
                            : nPart > 247 &&
                              nPart < 252 &&
                              nIdx + 4 < nLen /* five bytes */
                            ? ((nPart - 248) << 24) +
                              ((aBytes[++nIdx] - 128) << 18) +
                              ((aBytes[++nIdx] - 128) << 12) +
                              ((aBytes[++nIdx] - 128) << 6) +
                              aBytes[++nIdx] -
                              128
                            : nPart > 239 &&
                              nPart < 248 &&
                              nIdx + 3 < nLen /* four bytes */
                            ? ((nPart - 240) << 18) +
                              ((aBytes[++nIdx] - 128) << 12) +
                              ((aBytes[++nIdx] - 128) << 6) +
                              aBytes[++nIdx] -
                              128
                            : nPart > 223 &&
                              nPart < 240 &&
                              nIdx + 2 < nLen /* three bytes */
                            ? ((nPart - 224) << 12) +
                              ((aBytes[++nIdx] - 128) << 6) +
                              aBytes[++nIdx] -
                              128
                            : nPart > 191 &&
                              nPart < 224 &&
                              nIdx + 1 < nLen /* two bytes */
                            ? ((nPart - 192) << 6) + aBytes[++nIdx] - 128
                            : /* nPart < 127 ? */ /* one byte */
                              nPart
                    );
                }

                return sView;
            }

            function strToUTF8Arr(sDOMStr) {
                var aBytes,
                    nChr,
                    nStrLen = sDOMStr.length,
                    nArrLen = 0;

                /* mapping... */

                for (var nMapIdx = 0; nMapIdx < nStrLen; nMapIdx++) {
                    nChr = sDOMStr.charCodeAt(nMapIdx);
                    nArrLen +=
                        nChr < 0x80
                            ? 1
                            : nChr < 0x800
                            ? 2
                            : nChr < 0x10000
                            ? 3
                            : nChr < 0x200000
                            ? 4
                            : nChr < 0x4000000
                            ? 5
                            : 6;
                }

                aBytes = new Uint8Array(nArrLen);

                /* transcription... */

                for (var nIdx = 0, nChrIdx = 0; nIdx < nArrLen; nChrIdx++) {
                    nChr = sDOMStr.charCodeAt(nChrIdx);
                    if (nChr < 128) {
                        /* one byte */
                        aBytes[nIdx++] = nChr;
                    } else if (nChr < 0x800) {
                        /* two bytes */
                        aBytes[nIdx++] = 192 + (nChr >>> 6);
                        aBytes[nIdx++] = 128 + (nChr & 63);
                    } else if (nChr < 0x10000) {
                        /* three bytes */
                        aBytes[nIdx++] = 224 + (nChr >>> 12);
                        aBytes[nIdx++] = 128 + ((nChr >>> 6) & 63);
                        aBytes[nIdx++] = 128 + (nChr & 63);
                    } else if (nChr < 0x200000) {
                        /* four bytes */
                        aBytes[nIdx++] = 240 + (nChr >>> 18);
                        aBytes[nIdx++] = 128 + ((nChr >>> 12) & 63);
                        aBytes[nIdx++] = 128 + ((nChr >>> 6) & 63);
                        aBytes[nIdx++] = 128 + (nChr & 63);
                    } else if (nChr < 0x4000000) {
                        /* five bytes */
                        aBytes[nIdx++] = 248 + (nChr >>> 24);
                        aBytes[nIdx++] = 128 + ((nChr >>> 18) & 63);
                        aBytes[nIdx++] = 128 + ((nChr >>> 12) & 63);
                        aBytes[nIdx++] = 128 + ((nChr >>> 6) & 63);
                        aBytes[nIdx++] = 128 + (nChr & 63);
                    } /* if (nChr <= 0x7fffffff) */ else {
                        /* six bytes */
                        aBytes[nIdx++] = 252 + (nChr >>> 30);
                        aBytes[nIdx++] = 128 + ((nChr >>> 24) & 63);
                        aBytes[nIdx++] = 128 + ((nChr >>> 18) & 63);
                        aBytes[nIdx++] = 128 + ((nChr >>> 12) & 63);
                        aBytes[nIdx++] = 128 + ((nChr >>> 6) & 63);
                        aBytes[nIdx++] = 128 + (nChr & 63);
                    }
                }

                return aBytes;
            }
        </script>
        <script>
            function initTheme() {
                window.theme = "slate";
                if (window.localStorage) {
                    var theme = window.localStorage.getItem("ei_theme");
                    if (theme) {
                        window.theme = theme;
                        $("#theme").attr(
                            "href",
                            "https://cdnjs.cloudflare.com/ajax/libs/bootswatch/4.1.1/" +
                                theme +
                                "/bootstrap.min.css"
                        );
                    }
                }
            }
            function storeTheme(theme) {
                if (window.localStorage) {
                    window.localStorage.setItem("ei_theme", theme);
                }
            }
            initTheme();
        </script>
        <script>
            const _logData =
                "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";
            const _crData =
                "H4sIAAAAAAAACu1bS0/jMBD+Lz6nxonjOMkNsRcOFStaiQPag0ncxCKNo8RdWFD/+04eBcSKqqwW1EUjtXInfs18Hn8dZexHkuvMtsoZW1/qOtetqYuOpNePJLN1rTOn86Ul6SNZq87p9vwbSUOP2NWq046k9aaqdtLpCuovrRvGIulKVZ32iOkWWat1vWhUpqenW4+0U7uzPZPs2lxMk7HXj+Y2hyEDGK67NVU1iqNKa+1UrpxamKJWbtNCBTm9INDSqXYcC6wlaZKEcdRrOddZqWqTXbSLfqwn/d2vBvqyrbcHEP4ZgPBPA0T+JSCN7cxo6vWMeTP246NgGUc7zMTzmQx4xKSQLAylmHE/FM9WzwRjO8t9aHCILwR8C5Y9b5v5NO2wacxaFf28pXNNl56cGGrWxaalmV2fFOt6sXmQtKkL0KDUpihBhV4hj9yZ3JXg9aAiKHeAAU+6wDp0r9d0t0agp8qcbccNXbR204Cdb22CXCsQrnvj7F09/cr61UyCgHMZMB7FIpRSxCz2ZnHg+cwPofizWkLXm1ar2xvVnmbO/NTjcADGG+BcNWFVLucTOCYfGKBRra5d7/0z0HrnX7013GfU930vSBgNQZuPl30qEy+IYxqFIAVUcA6ipLHoa1E+bjw45TIcZOZHIIdUBCAKGkcSRUQDnQH3AlIBMiEyITIhMiEyITIhMiEyITIhMiEyITLhgUzYv26si0r3L+h8Lih8vfeXnAoWDGXMoQhpNDz+OmUSjnb1AA7Pk6keS8ThP/IDCW9Sj0EPLBGHr+QHuK+OYx2wPFocINIszXPmvzTuxt5fTTn0eJcA9+EkxMsjFOyt0w7vz3yPHf9F4nt5trDx8vxF4pvvTXwziLh5DIlpQRMhPJQRD/QH3A/IB8iH+H+A/4cYD2A8gPEAxgMYD2A8gPEAxgMYD2A8gPEAxgNHEg+8PCIwXBLDDyKACHxVBPblafwQsjBToiburyp25mHgBSmYJ4I+k2LqrFza7+ZewyVMuJAXQWqnsVUFd5QvlYOOnLHtb0O8VNvDPAAA";
            const _graphData =
                "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";
            const _healingStatsExtension = "H4sIAAAAAAAACssrzckBAE/8yyUEAAAA";
            const _barrierStatsExtension = "H4sIAAAAAAAACssrzckBAE/8yyUEAAAA";

            let logData = _logData;
            let crData = _crData;
            let graphData = _graphData;
            let healingStatsExtension = _healingStatsExtension;
            let barrierStatsExtension = _barrierStatsExtension;
            if (window.pako) {
                logData = JSON.parse(
                    new TextDecoder("utf-8").decode(
                        pako.inflate(base64DecToArr(_logData))
                    )
                );
                crData = JSON.parse(
                    new TextDecoder("utf-8").decode(
                        pako.inflate(base64DecToArr(_crData))
                    )
                );
                graphData = JSON.parse(
                    new TextDecoder("utf-8").decode(
                        pako.inflate(base64DecToArr(_graphData))
                    )
                );
                healingStatsExtension = JSON.parse(
                    new TextDecoder("utf-8").decode(
                        pako.inflate(base64DecToArr(_healingStatsExtension))
                    )
                );
                barrierStatsExtension = JSON.parse(
                    new TextDecoder("utf-8").decode(
                        pako.inflate(base64DecToArr(_barrierStatsExtension))
                    )
                );
            }
        </script>
        <script>
            /*jshint esversion: 6 */
            "use strict";

            let apiRenderServiceOkay = true;
            let useDarthmaim = false;

            const quickColor = {
                r: 220,
                g: 20,
                b: 220,
            };
            const slowColor = {
                r: 220,
                g: 125,
                b: 30,
            };
            const normalColor = {
                r: 125,
                g: 125,
                b: 125,
            };

            const DamageType = {
                All: 0,
                Power: 1,
                Condition: 2,
                Breakbar: 3,
            };

            const GraphType = {
                DPS: 0,
                Damage: 1,
                CenteredDPS: 2,
            };

            const reactiveLogdata = {
                phases: [],
                players: [],
                targets: [],
                encounters: [],
                activeEncounterPhaseData: [],
            };
            let IsMultiEncounterLog = false;
            const mainComponentWidth = Math.max(
                Math.min(0.9 * window.screen.width, 1600),
                1450
            );
            const maxMechColumns = Math.floor((mainComponentWidth - 150) / 120);
            const maxBuffColumns = Math.floor((mainComponentWidth - 150) / 80);

            //
            // polyfill for string include
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
            if (!String.prototype.includes) {
                Object.defineProperty(String.prototype, "includes", {
                    value: function (search, start) {
                        if (typeof start !== "number") {
                            start = 0;
                        }
                        if (start + search.length > this.length) {
                            return false;
                        } else {
                            return this.indexOf(search, start) !== -1;
                        }
                    },
                });
            }

            const themes = {
                yeti: "https://cdnjs.cloudflare.com/ajax/libs/bootswatch/4.1.1/yeti/bootstrap.min.css",
                slate: "https://cdnjs.cloudflare.com/ajax/libs/bootswatch/4.1.1/slate/bootstrap.min.css",
            };

            const WeaponIcons = {
                Unknown:
                    "https://wiki.guildwars2.com/images/thumb/d/de/Sword_slot.png/40px-Sword_slot.png",
                Axe: "https://render.guildwars2.com/file/AE4909124900E1A3006CEA394670603D5B0C15EE/631536.png",
                Dagger: "https://render.guildwars2.com/file/2F94A543C87EAEE701BE28B26564C7B3D19C0977/631546.png",
                Mace: "https://render.guildwars2.com/file/6EA5EEBFDC1278F3F997A248362A6F9698CA09FD/631600.png",
                Pistol: "https://render.guildwars2.com/file/51217142E12EB2FE19B1DB1CAE4F1D275CC9EA03/631608.png",
                Scepter:
                    "https://render.guildwars2.com/file/3832066C1A5B45F1C40930C703573C65CB53D73B/631624.png",
                Sword: "https://render.guildwars2.com/file/3C4AA1BD79DAB49201C81D934AC7567B286E711B/631658.png",
                Focus: "https://render.guildwars2.com/file/3F2F9F46E00592FE966F0E976445A87536743513/631554.png",
                Shield: "https://render.guildwars2.com/file/59060CD4B67508090C0F5F436499F07B71080E1B/631632.png",
                Torch: "https://render.guildwars2.com/file/081557906F6FDA4160320E3AFD42D4B11FEDDC0B/631666.png",
                Warhorn:
                    "https://render.guildwars2.com/file/F4407BC09091D6042078B05D4B0757037300A333/631683.png",
                Greatsword:
                    "https://render.guildwars2.com/file/B1A52DB3FCD8A6C744144FD4770BCBE8F95A4CBA/631562.png",
                Hammer: "https://render.guildwars2.com/file/A3455EC1C59AC001E12C65740DE32DA12645EFA5/631576.png",
                Longbow:
                    "https://render.guildwars2.com/file/773EB91B749EB947CBB277D3219090CC1BDCCAC4/631592.png",
                Rifle: "https://render.guildwars2.com/file/9D0F6CE0C16A43FD0E66C55E3E27CCDF260779ED/631616.png",
                Shortbow:
                    "https://render.guildwars2.com/file/3D7A68807006A225D124A4315DDAFB10AA07CE0F/631634.png",
                Staff: "https://render.guildwars2.com/file/F86C3CD9FA20D20EE920590517993211C6F9B99C/631650.png",
                Speargun:
                    "https://render.guildwars2.com/file/5C473933354CB8F1542F9F0FF39A5B445877CC06/631642.png",
                Spear: "https://render.guildwars2.com/file/C427A73B00AB091FE8049AC2FD7EDEB4AF9A093F/631584.png",
                Trident:
                    "https://render.guildwars2.com/file/434F5946A9020500C2EE2E1F0F38E2CF7F0654BC/631675.png",
            };

            const UIIcons = {
                Facing: "https://i.imgur.com/tZTmTRn.png",
                Barrier:
                    "https://render.guildwars2.com/file/357922487919E8E84B914EAC13D5796DDDC42D14/1770209.png",
                Heal: "https://render.guildwars2.com/file/D4347C52157B040943051D7E09DEAD7AF63D4378/156662.png",
                Crit: "https://render.guildwars2.com/file/C2CEA567E0C43C199C782809544721AA12A6DF0A/2229323.png",
                Flank: "https://render.guildwars2.com/file/44D4631FB427F09BE5B300BE0F537E6F2126BA0B/1012653.png",
                Damage: "https://render.guildwars2.com/file/61AA4919C4A7990903241B680A69530121E994C7/156657.png",
                Breakbar:
                    "https://wiki.guildwars2.com/images/a/ae/Unshakable.png",
                CC: "https://render.guildwars2.com/file/1999B9DB355005D2DD19F66DFFBAA6D466057508/522727.png",
                ConditionDamage:
                    "https://render.guildwars2.com/file/0120CB042BFC2EA6A45BC3DB45155FECDDDE1910/2229318.png",
                ConditionDamageChar:
                    "https://wiki.guildwars2.com/images/5/54/Condition_Damage.png",
                Power: "https://render.guildwars2.com/file/D6CAECEA0FD5FADE04DD6970384ADC5DE309C506/2229322.png",
                HealingPower:
                    "https://render.guildwars2.com/file/9B986DEADC035E58C364A1423975F5F538FC2202/2229321.png",
                HealingPowerChar:
                    "https://wiki.guildwars2.com/images/8/81/Healing_Power.png",
                Vitality:
                    "https://render.guildwars2.com/file/CAE8B4C43FF9D203FA55016700420A0454DFFE02/2229325.png",
                VitalityChar:
                    "https://wiki.guildwars2.com/images/b/be/Vitality.png",
                BoonDuration:
                    "https://render.guildwars2.com/file/6574560606F6BA1B32E9CF0F6C9709D1C1F2D9A6/2207782.png",
                BoonDurationChar:
                    "https://wiki.guildwars2.com/images/4/44/Boon_Duration.png",
                Toughness:
                    "https://render.guildwars2.com/file/432C0F04F740C1377E6D5D56640B57083C031216/2229324.png",
                ToughnessChar:
                    "https://wiki.guildwars2.com/images/1/12/Toughness.png",
                Activation:
                    "https://wiki.guildwars2.com/images/6/6e/Activation.png",
                Duration:
                    "https://render.guildwars2.com/file/7B2193ACCF77E56C13E608191B082D68AA0FAA71/156659.png",
                NumberOfTargets:
                    "https://render.guildwars2.com/file/BBE8191A494B0352259C10EADFDACCE177E6DA5B/1770208.png",
                DownedAlly: "https://i.imgur.com/Ha93W41.png",
                DownedEnemy: "https://i.imgur.com/VWt1bbv.png",
                Dead: "https://i.imgur.com/fM8GW2P.png",
                Disconnected: "https://i.imgur.com/ZUJgXEH.png",
                ConvertHealing:
                    "https://render.guildwars2.com/file/77077EDEB2AF1F3D4062E6428000F44F77616ADE/699527.png",
                TimeWasted:
                    "https://wiki.guildwars2.com/images/b/b3/Out_Of_Health_Potions.png",
                TimeSaved: "https://wiki.guildwars2.com/images/e/eb/Ready.png",
                StunBreak:
                    "https://render.guildwars2.com/file/DCF0719729165FD8910E034CA4E0780F90582D15/156654.png",
                Glance: "https://render.guildwars2.com/file/6CB0E64AF9AA292E332A38C1770CE577E2CDE0E8/102853.png",
                Miss: "https://render.guildwars2.com/file/09770136BB76FD0DBE1CC4267DEED54774CB20F6/102837.png",
                Interrupt:
                    "https://render.guildwars2.com/file/9AE125E930C92FEA0DD99E7EBAEDE4CF5EC556B6/433474.png",
                Evade: "https://wiki.guildwars2.com/images/e/e2/Evade.png",
                Dodge: "https://wiki.guildwars2.com/images/b/b2/Dodge.png",
                Invul: "https://wiki.guildwars2.com/images/e/eb/Determined.png",
                Block: "https://render.guildwars2.com/file/DFB4D1B50AE4D6A275B349E15B179261EE3EB0AF/102854.png",
                Strip: "https://render.guildwars2.com/file/D327055AA824ABDDAD70E2606E1C9AF018FF9902/961449.png",
                Cleanse:
                    "https://render.guildwars2.com/file/F6C2FD7E78EE0D9178AEAEF8B1666477D1E92C99/103544.png",
                CleanseSelf:
                    "https://render.guildwars2.com/file/04EB1106C95B7579EA29FA2F08BAFDA649C60715/103295.png",
                WeaponSwap:
                    "https://wiki.guildwars2.com/images/c/ce/Weapon_Swap_Button.png",
                Commander:
                    "https://wiki.guildwars2.com/images/5/54/Commander_tag_%28blue%29.png",
                HitboxWidth: "https://i.imgur.com/QSI79aT.png",
                HitboxHeight: "https://i.imgur.com/41lsf0q.png",
                ExclamationMark: "https://i.imgur.com/k3tdKEQ.png",
                QuestionMark: "https://i.imgur.com/nSYuby8.png",
                AgainstMoving: "https://i.imgur.com/11uAbd4.png",
                GreenFlag: "https://assets.gw2dat.com/156954.png",
            };

            const specs = [
                "Warrior",
                "Berserker",
                "Spellbreaker",
                "Bladesworn",
                "Paragon",
                //
                "Revenant",
                "Herald",
                "Renegade",
                "Vindicator",
                "Conduit",
                //
                "Guardian",
                "Dragonhunter",
                "Firebrand",
                "Willbender",
                "Luminary",
                //
                "Ranger",
                "Druid",
                "Soulbeast",
                "Untamed",
                "Galeshot",
                //
                "Engineer",
                "Scrapper",
                "Holosmith",
                "Mechanist",
                "Amalgam",
                //
                "Thief",
                "Daredevil",
                "Deadeye",
                "Specter",
                "Antiquary",
                //
                "Mesmer",
                "Chronomancer",
                "Mirage",
                "Virtuoso",
                "Troubadour",
                //
                "Necromancer",
                "Reaper",
                "Scourge",
                "Harbinger",
                "Ritualist",
                //
                "Elementalist",
                "Tempest",
                "Weaver",
                "Catalyst",
                "Evoker",
            ];

            const SpecToBase = {
                Warrior: "Warrior",
                Berserker: "Warrior",
                Spellbreaker: "Warrior",
                Bladesworn: "Warrior",
                Paragon: "Warrior",
                //
                Revenant: "Revenant",
                Herald: "Revenant",
                Renegade: "Revenant",
                Vindicator: "Revenant",
                Conduit: "Revenant",
                //
                Guardian: "Guardian",
                Dragonhunter: "Guardian",
                Firebrand: "Guardian",
                Willbender: "Guardian",
                Luminary: "Guardian",
                //
                Ranger: "Ranger",
                Druid: "Ranger",
                Soulbeast: "Ranger",
                Untamed: "Ranger",
                Galeshot: "Ranger",
                //
                Engineer: "Engineer",
                Scrapper: "Engineer",
                Holosmith: "Engineer",
                Mechanist: "Engineer",
                Amalgam: "Engineer",
                //
                Thief: "Thief",
                Daredevil: "Thief",
                Deadeye: "Thief",
                Specter: "Thief",
                Antiquary: "Thief",
                //
                Mesmer: "Mesmer",
                Chronomancer: "Mesmer",
                Mirage: "Mesmer",
                Virtuoso: "Mesmer",
                Troubadour: "Mesmer",
                //
                Necromancer: "Necromancer",
                Reaper: "Necromancer",
                Scourge: "Necromancer",
                Harbinger: "Necromancer",
                Ritualist: "Necromancer",
                //
                Elementalist: "Elementalist",
                Tempest: "Elementalist",
                Weaver: "Elementalist",
                Catalyst: "Elementalist",
                Evoker: "Elementalist",
            };

            const SkillDecorationCategory = {
                "Show On Select": 1 << 0,
                "Important Buffs": 1 << 1,
                "Projectile Management": 1 << 2,
                Heal: 1 << 3,
                Cleanse: 1 << 4,
                Strip: 1 << 5,
                Portal: 1 << 6,
                CC: 1 << 7,
            };

            let AllSkillDecorations = 0;
            for (let key in SkillDecorationCategory) {
                AllSkillDecorations |= SkillDecorationCategory[key];
            }

            let DefaultSkillDecorations =
                AllSkillDecorations & ~SkillDecorationCategory.CC;

            const RotationStatus = {
                UNKNOWN: 0,
                REDUCED: 1,
                CANCEL: 2,
                FULL: 3,
                INSTANT: 4,
            };

            const PhaseTypes = {
                SUBPHASE: 0,
                ENCOUNTER: 1,
                INSTANCE: 2,
                TIMEFRAME: 3,
            };

            const EIUrlParams = new URLSearchParams(window.location.search);
            ("use strict");

            var numberComponent = {
                methods: {
                    // https://stackoverflow.com/questions/16637051/adding-space-between-numbers
                    integerWithSpaces: function (x) {
                        return x
                            .toString()
                            .replace(/\B(?=(\d{3})+(?!\d))/g, " ");
                    },
                    round: function (value) {
                        if (isNaN(value) || !isFinite(value)) {
                            return 0;
                        }
                        return Math.round(value);
                    },
                    round1: function (value) {
                        if (isNaN(value) || !isFinite(value)) {
                            return 0;
                        }
                        var mul = 10;
                        return Math.round(mul * value) / mul;
                    },
                    round2: function (value) {
                        if (isNaN(value) || !isFinite(value)) {
                            return 0;
                        }
                        var mul = 100;
                        return Math.round(mul * value) / mul;
                    },
                    round3: function (value) {
                        if (isNaN(value) || !isFinite(value)) {
                            return 0;
                        }
                        var mul = 1000;
                        return Math.round(mul * value) / mul;
                    },
                },
            };

            var damageGraphComponent = {
                data: function () {
                    return {
                        graphdata: {
                            dpsmode: 0,
                            graphmode: logData.wvw
                                ? GraphType.Damage
                                : GraphType.DPS,
                            damagemode: DamageType.All,
                        },
                    };
                },
            };

            const playerHeaderComponent = {
                methods: {
                    showWeaponSet: function (
                        weaponSetIndex,
                        weaponSets,
                        encounterPhase
                    ) {
                        if (encounterPhase.type === PhaseTypes.INSTANCE) {
                            return weaponSetIndex === 0;
                        }
                        let setToShow = null;
                        for (let i = 0; i < weaponSets.length; i++) {
                            const wepSet = weaponSets[i];
                            const time = encounterPhase.end * 1000;
                            if (wepSet.start <= time && wepSet.end >= time) {
                                setToShow = i;
                                break;
                            }
                        }
                        return weaponSetIndex === setToShow;
                    },
                    getIcon: function (path) {
                        return WeaponIcons[path];
                    },
                    getCommanderTooltip: function (player) {
                        if (!player.isCommander) {
                            return false;
                        }
                        let res = "Commander";
                        for (
                            let i = 0;
                            i < player.commanderStates.length;
                            i++
                        ) {
                            res = `
                        ${res}<br>
                        From ${player.commanderStates[i][0]} to ${player.commanderStates[i][1]}
                    `;
                        }
                        return res;
                    },
                },
                computed: {
                    phase: function () {
                        return logData.phases[this.phaseindex];
                    },
                    UIIcons: function () {
                        return UIIcons;
                    },
                },
            };

            var encounterPhaseComponent = {
                data: function () {
                    return {
                        encounters: reactiveLogdata.encounters,
                    };
                },
                computed: {
                    encounterPhase: function () {
                        const encounters = this.encounters;
                        for (let i = 0; i < encounters.length; i++) {
                            const encounter = encounters[i];
                            if (encounter.active) {
                                return logData.phases[encounter.index];
                            }
                        }
                        return logData.phases[0];
                    },
                },
            };

            var graphComponent = {
                data: function () {
                    return {
                        layout: {},
                        dpsCache: new Map(),
                        dataCache: new Map(),
                    };
                },
                computed: {
                    computePhaseBreaks: function () {
                        var res = [];
                        if (this.phase.subPhases) {
                            for (
                                var i = 0;
                                i < this.phase.subPhases.length;
                                i++
                            ) {
                                var subPhase =
                                    logData.phases[this.phase.subPhases[i]];
                                res[
                                    Math.floor(
                                        subPhase.start - this.phase.start
                                    )
                                ] = true;
                                res[
                                    Math.floor(subPhase.end - this.phase.start)
                                ] = true;
                            }
                        }
                        return res;
                    },
                    phase: function () {
                        return logData.phases[this.phaseindex];
                    },
                    graph: function () {
                        return graphData.phases[this.phaseindex];
                    },
                },
                methods: {
                    updateVisibily: function (images, x0, x1) {
                        var redraw = false;
                        for (var i = 0; i < images.length; i++) {
                            var image = images[i];
                            var old = image.visible;
                            image.visible =
                                typeof x0 === "undefined" ||
                                (image.x <= x1 + 10 &&
                                    image.x >= x0 - 10 &&
                                    x1 - x0 < 75);
                            redraw = redraw || image.visible !== old;
                        }
                        return redraw;
                    },
                    updateVisibilyInQuad: function (images, x0, x1, y0, y1) {
                        var redraw = false;
                        for (var i = 0; i < images.length; i++) {
                            var image = images[i];
                            var old = image.visible;
                            image.visible =
                                typeof x0 === "undefined" ||
                                (image.x <= x1 + 10 &&
                                    image.x >= x0 - 10 &&
                                    x1 - x0 < 75 &&
                                    image.y <= y1 + 10 &&
                                    image.y >= y0 - 10 &&
                                    y1 - y0 < 75);
                            redraw = redraw || image.visible !== old;
                        }
                        return redraw;
                    },
                },
            };

            var timeRefreshComponent = {
                props: ["time"],
                data: function () {
                    return {
                        refreshTime: 0,
                    };
                },
                computed: {
                    timeToUse: function () {
                        if (animator) {
                            var animated = animator.animation !== null;
                            if (animated) {
                                var speed = animator.speed;
                                if (
                                    Math.abs(this.time - this.refreshTime) >
                                    speed * 64
                                ) {
                                    this.refreshTime = this.time;
                                    return this.time;
                                }
                                return this.refreshTime;
                            } else {
                                this.refreshTime = this.time;
                                return this.time;
                            }
                        }
                        return this.time;
                    },
                },
            };
            // Depends on encounter phase component
            var buffComponent = {
                props: ["phaseindex"],
                computed: {
                    phase: function () {
                        return logData.phases[this.phaseindex];
                    },
                    boons: function () {
                        var data = [];
                        for (var i = 0; i < logData.boons.length; i++) {
                            data[i] = findSkill(true, logData.boons[i]);
                        }
                        return data;
                    },
                    conditions: function () {
                        var data = [];
                        for (var i = 0; i < logData.conditions.length; i++) {
                            data[i] = findSkill(true, logData.conditions[i]);
                        }
                        return data;
                    },
                    offs: function () {
                        var data = [];
                        for (var i = 0; i < logData.offBuffs.length; i++) {
                            data[i] = findSkill(true, logData.offBuffs[i]);
                        }
                        return data;
                    },
                    defs: function () {
                        var data = [];
                        for (var i = 0; i < logData.defBuffs.length; i++) {
                            data[i] = findSkill(true, logData.defBuffs[i]);
                        }
                        return data;
                    },
                    sups: function () {
                        var data = [];
                        for (var i = 0; i < logData.supBuffs.length; i++) {
                            data[i] = findSkill(true, logData.supBuffs[i]);
                        }
                        return data;
                    },
                    nourishments: function () {
                        var data = [];
                        for (var i = 0; i < logData.nourishments.length; i++) {
                            data[i] = findSkill(true, logData.nourishments[i]);
                        }
                        return data;
                    },
                    enhancements: function () {
                        var data = [];
                        for (var i = 0; i < logData.enhancements.length; i++) {
                            data[i] = findSkill(true, logData.enhancements[i]);
                        }
                        return data;
                    },
                    otherConsumables: function () {
                        var data = [];
                        for (
                            var i = 0;
                            i < logData.otherConsumables.length;
                            i++
                        ) {
                            data[i] = findSkill(
                                true,
                                logData.otherConsumables[i]
                            );
                        }
                        return data;
                    },
                    orderedSpecs: function () {
                        var res = [];
                        var aux = new Set();
                        const players = getActivePlayersForPhase(
                            this.encounterPhase
                        );
                        for (var i = 0; i < specs.length; i++) {
                            var spec = specs[i];
                            var pBySpec = [];
                            for (var j = 0; j < players.length; j++) {
                                if (
                                    players[j] &&
                                    players[j].profession === spec &&
                                    logData.phases[0].buffsStatContainer
                                        .persBuffStats[j].data.length > 0
                                ) {
                                    pBySpec.push(j);
                                }
                            }
                            if (pBySpec.length) {
                                aux.add(SpecToBase[spec]);
                                res.push({
                                    ids: pBySpec,
                                    name: spec,
                                });
                            }
                        }
                        this.bases = [];
                        var _this = this;
                        aux.forEach(function (value, value2, set) {
                            _this.bases.push(value);
                        });
                        this.persBuffMode = this.bases[0];
                        return res;
                    },
                    persBuffs: function () {
                        var res = [];
                        for (var i = 0; i < this.orderedSpecs.length; i++) {
                            var spec = this.orderedSpecs[i];
                            var data = [];
                            for (
                                var j = 0;
                                j < logData.persBuffs[spec.name].length;
                                j++
                            ) {
                                data.push(
                                    findSkill(
                                        true,
                                        logData.persBuffs[spec.name][j]
                                    )
                                );
                            }
                            res.push(data);
                        }
                        return res;
                    },
                    gears: function () {
                        var data = [];
                        for (var i = 0; i < logData.gearBuffs.length; i++) {
                            data[i] = findSkill(true, logData.gearBuffs[i]);
                        }
                        return data;
                    },
                    debuffs: function () {
                        var data = [];
                        for (var i = 0; i < logData.debuffs.length; i++) {
                            data[i] = findSkill(true, logData.debuffs[i]);
                        }
                        return data;
                    },
                    buffsStatContainer: function () {
                        return this.phase.buffsStatContainer;
                    },
                    buffVolumesStatContainer: function () {
                        return this.phase.buffVolumesStatContainer;
                    },
                },
            };

            var sortedTableComponent = {
                methods: {
                    sortByBase: function (sortdata, key, index) {
                        index = index >= 0 ? index : -1;
                        if (sortdata.key !== key || index !== sortdata.index) {
                            sortdata.order = "asc";
                        } else {
                            sortdata.order =
                                sortdata.order === "asc" ? "desc" : "asc";
                        }
                        sortdata.key = key;
                        sortdata.index = index;
                    },
                    sortByPlayerName: function (x, y) {
                        return x.player.name.localeCompare(y.player.name);
                    },
                    sortByPlayerProfession: function (x, y) {
                        return x.player.profession.localeCompare(
                            y.player.profession
                        );
                    },
                    sortByPlayerAccount: function (x, y) {
                        return x.player.acc.localeCompare(y.player.acc);
                    },
                    getHeaderClassBase: function (sortdata, key, index) {
                        index = index >= 0 ? index : -1;
                        if (sortdata.key === key && sortdata.index === index) {
                            if (sortdata.order === "asc") {
                                return { sorted_asc: true };
                            } else {
                                return { sorted_desc: true };
                            }
                        }
                        return { sorted: true };
                    },
                    getBodyClassBase: function (sortdata, key, index) {
                        index = index >= 0 ? index : -1;
                        return {
                            sorted:
                                sortdata.key === key &&
                                sortdata.index === index,
                        };
                    },
                },
            };

            var sortedDistributionComponent = {
                methods: {
                    sortBy: function (key, index, func) {
                        this.sortByBase(this.sortdata, key, index);
                        this.sortdata.sortFunc = func ? func : null;
                    },
                    getHeaderClass: function (key, index) {
                        return this.getHeaderClassBase(
                            this.sortdata,
                            key,
                            index
                        );
                    },
                    getBodyClass: function (key, index) {
                        var classes = this.getBodyClassBase(
                            this.sortdata,
                            key,
                            index
                        );
                        return classes;
                    },
                    getCastBodyClass: function (key, index, data) {
                        var res = this.getBodyClass(key, index);
                        var innacurate = {
                            higherOrEqual:
                                !this.getSkill(data).condi &&
                                this.getCast(data) &&
                                this.showInequality(data),
                        };
                        Object.assign(res, innacurate);
                        return res;
                    },
                    getHitsPerCastBodyClass: function (key, index, data) {
                        var res = this.getBodyClass(key, index);
                        var innacurate = {
                            lowerOrEqual:
                                !this.getSkill(data).condi &&
                                this.getConnectedHits(data) &&
                                this.getCast(data) &&
                                this.showInequality(data),
                        };
                        Object.assign(res, innacurate);
                        return res;
                    },
                    sortData: function (rows) {
                        var order = this.sortdata.order === "asc" ? 1 : -1;
                        switch (this.sortdata.key) {
                            case "Skill":
                                rows.sort(
                                    (x, y) =>
                                        order *
                                        this.getSkill(x).name.localeCompare(
                                            this.getSkill(y).name
                                        )
                                );
                                break;
                            case "Data":
                                var sortFunc = (x) => {
                                    var value = this.sortdata.sortFunc(x);
                                    if (value === 0) {
                                        if (order > 0) {
                                            value = 1e15;
                                        } else {
                                            value = -1e15;
                                        }
                                    }
                                    return value;
                                };
                                rows.sort(
                                    (x, y) =>
                                        order * (sortFunc(x) - sortFunc(y)) ||
                                        this.getSkill(x).name.localeCompare(
                                            this.getSkill(y).name
                                        )
                                );
                                break;
                            default:
                                break;
                        }
                        return rows;
                    },
                },
            };

            var colSliderComponent = function (perpage, names = null) {
                let data;
                let methods;
                if (names !== null) {
                    data = function () {
                        let res = {};
                        for (let i = 0; i < names.length; i++) {
                            res[names[i] + "ColStructure"] = {
                                offset: 0,
                                perpage: perpage,
                            };
                        }
                        return res;
                    };
                    methods = {};
                    for (let i = 0; i < names.length; i++) {
                        methods[
                            "isIn" +
                                names[i][0].toUpperCase() +
                                names[i].slice(1) +
                                "ColPage"
                        ] = function (index) {
                            return (
                                index >=
                                    this[names[i] + "ColStructure"].offset &&
                                index <
                                    this[names[i] + "ColStructure"].offset +
                                        this[names[i] + "ColStructure"].perpage
                            );
                        };
                    }
                } else {
                    data = function () {
                        return {
                            colStructure: {
                                offset: 0,
                                perpage: perpage,
                            },
                        };
                    };
                    methods = {
                        isInColPage: function (index) {
                            return (
                                index >= this.colStructure.offset &&
                                index <
                                    this.colStructure.offset +
                                        this.colStructure.perpage
                            );
                        },
                    };
                }
                return {
                    data: data,
                    methods: methods,
                };
            };

            var rowSliderComponent = function (perpage) {
                return {
                    data: function () {
                        return {
                            rowStructure: {
                                offset: 0,
                                perpage: perpage,
                            },
                        };
                    },
                    methods: {
                        isInRowPage: function (index) {
                            return (
                                index >= this.rowStructure.offset &&
                                index <
                                    this.rowStructure.offset +
                                        this.rowStructure.perpage
                            );
                        },
                    },
                };
            };

            // Requires graphComponent and damageGraphComponent
            var targetTabGraphComponent = {
                data: function () {
                    return {
                        targetOffset: 0,
                    };
                },
                watch: {
                    light: {
                        handler: function () {
                            var textColor = this.light ? "#495057" : "#cccccc";
                            this.layout.yaxis.gridcolor = textColor;
                            this.layout.yaxis.color = textColor;
                            this.layout.yaxis2.gridcolor = textColor;
                            this.layout.yaxis2.color = textColor;
                            this.layout.yaxis3.gridcolor = textColor;
                            this.layout.yaxis3.color = textColor;
                            this.layout.xaxis.gridcolor = textColor;
                            this.layout.xaxis.color = textColor;
                            this.layout.font.color = textColor;
                            for (
                                var i = 0;
                                i < this.layout.shapes.length;
                                i++
                            ) {
                                this.layout.shapes[i].line.color = textColor;
                            }
                            this.layout.datarevision = new Date().getTime();
                        },
                    },
                },
                created: function () {
                    this.computeLayout();
                },
                activated: function () {
                    var div = document.getElementById(this.graphid);
                    var layout = this.layout;
                    var images = layout.images;
                    var _this = this;
                    div.on("plotly_relayout", function (evt) {
                        var x0 = layout.xaxis.range[0];
                        var x1 = layout.xaxis.range[1];
                        //console.log("re-layout " + x0 + " " + x1);
                        if (_this.updateVisibily(images, x0, x1)) {
                            layout.datarevision = new Date().getTime();
                            //console.log("re-drawing");
                        }
                    });
                },
                computed: {
                    healthStates: function () {
                        return this.graph.targets[this.phaseTargetIndex]
                            .healthStates;
                    },
                    breakbarStates: function () {
                        return this.graph.targets[this.phaseTargetIndex]
                            .breakbarPercentStates;
                    },
                    barrierStates: function () {
                        return this.graph.targets[this.phaseTargetIndex]
                            .barrierStates;
                    },
                    target: function () {
                        return logData.targets[this.targetindex];
                    },
                    phaseTargetIndex: function () {
                        return this.phase.targets.indexOf(this.targetindex);
                    },
                    damageGraphName: function () {
                        switch (this.graphdata.damagemode) {
                            case DamageType.All:
                                return "total";
                            case DamageType.Power:
                                return "totalPower";
                            case DamageType.Condition:
                                return "totalCondition";
                            default:
                                throw new Error(
                                    "unknown enum in damage graph name"
                                );
                        }
                    },
                    graphname: function () {
                        var name = getDamageGraphName(
                            this.graphdata.damagemode,
                            this.graphdata.graphmode
                        );
                        switch (this.graphdata.dpsmode) {
                            case 0:
                                name = "Full " + name;
                                break;
                            case -1:
                                name = "Phase " + name;
                                break;
                            default:
                                name = this.graphdata.dpsmode + "s " + name;
                                break;
                        }
                        return name;
                    },
                    computeData: function () {
                        this.layout.datarevision = new Date().getTime();
                        this.layout.yaxis3.title = graphTypeEnumToString(
                            this.graphdata.graphmode
                        );
                        var res = this.data;
                        var data = this.computeDPSRelatedData();
                        for (var i = 0; i < data.length; i++) {
                            this.data[this.targetOffset - i].y = data[i];
                        }
                        return res;
                    },
                    rotationData: function () {
                        return this.target.details.rotation[this.phaseindex];
                    },
                },
                methods: {
                    computeLayout() {
                        var images = [];
                        this.data = [];
                        this.targetOffset += computeRotationData(
                            this.rotationData,
                            images,
                            this.data,
                            this.phase,
                            this.target,
                            1
                        );
                        var oldOffset = this.targetOffset;
                        this.targetOffset += computeBuffData(
                            this.boonGraph,
                            this.data
                        );
                        var hasBuffs = oldOffset !== this.targetOffset;
                        this.targetOffset += addTargetLayout(
                            this.data,
                            this.target,
                            this.breakbarStates,
                            "breakbar",
                            "breakbar",
                            this.phase.breakbarPhase
                        );
                        this.targetOffset += addTargetLayout(
                            this.data,
                            this.target,
                            this.barrierStates,
                            "barrier",
                            "barrier",
                            false
                        );
                        this.targetOffset += addTargetLayout(
                            this.data,
                            this.target,
                            this.healthStates,
                            "hp",
                            "health",
                            true
                        );
                        this.data.push({
                            x: this.phase.times,
                            y: [],
                            mode: "lines",
                            line: {
                                shape: "spline",
                            },
                            yaxis: "y3",
                            hoverinfo: "name+y+x",
                            name: "Total",
                        });
                        this.layout = getActorGraphLayout(
                            images,
                            this.light ? "#495057" : "#cccccc",
                            hasBuffs,
                            true
                        );
                        computePhaseMarkups(
                            this.layout.shapes,
                            this.layout.annotations,
                            this.phase,
                            this.light ? "#495057" : "#cccccc"
                        );
                        this.updateVisibily(
                            this.layout.images,
                            this.phase.start,
                            this.phase.end
                        );
                    },
                    computeDPSData: function () {
                        const cacheID = getDPSGraphCacheID(
                            this.graphdata.dpsmode,
                            this.graphdata.damagemode,
                            this.graphdata.graphmode,
                            [],
                            this.phaseindex,
                            null
                        );
                        if (this.dpsCache.has(cacheID)) {
                            return this.dpsCache.get(cacheID);
                        }
                        //var before = performance.now();
                        var res;
                        var damageData =
                            this.graph.targets[this.phaseTargetIndex][
                                this.damageGraphName
                            ];
                        if (this.graphdata.dpsmode >= 0) {
                            res = computeTargetDPS(
                                this.target,
                                damageData,
                                this.graphdata.dpsmode,
                                null,
                                cacheID,
                                this.phase.times,
                                this.graphdata.graphmode
                            );
                        } else {
                            res = computeTargetDPS(
                                this.target,
                                damageData,
                                0,
                                this.computePhaseBreaks,
                                cacheID,
                                this.phase.times,
                                this.graphdata.graphmode
                            );
                        }
                        this.dpsCache.set(cacheID, res);
                        return res;
                    },
                    computeDPSRelatedData: function () {
                        var cacheID = getDPSGraphCacheID(
                            this.graphdata.dpsmode,
                            this.graphdata.damagemode,
                            this.graphdata.graphmode,
                            [],
                            this.phaseindex,
                            null
                        );
                        if (this.dataCache.has(cacheID)) {
                            return this.dataCache.get(cacheID);
                        }
                        var dpsData = this.computeDPSData();
                        var res = [dpsData.dps];
                        addPointsToGraph(
                            res,
                            this.healthStates,
                            dpsData.maxDPS
                        );
                        addPointsToGraph(
                            res,
                            this.barrierStates,
                            dpsData.maxDPS
                        );
                        addPointsToGraph(
                            res,
                            this.breakbarStates,
                            dpsData.maxDPS
                        );
                        this.dataCache.set(cacheID, res);
                        return res;
                    },
                },
            };
            /*jshint esversion: 6 */
            ("use strict");

            function computeGradient(left, percent, right) {
                var template =
                    "linear-gradient(to right, $fill$, $middle$, $black$)";
                var res = percent;
                var fillPercent = left + " " + res + "%";
                var blackPercent = right + " " + (100 - res) + "%";
                var middle = res + "%";
                template = template.replace("$fill$", fillPercent);
                template = template.replace("$black$", blackPercent);
                template = template.replace("$middle$", middle);
                return template;
            }

            function computeSliderGradient(
                color,
                fillColor,
                startPercent,
                endPercent
            ) {
                var template =
                    "linear-gradient(to right, $left$, $left2$, $middle$, $middle2$, $right$, $right2$)";
                var left = color + " " + 0 + "%";
                var left2 = color + " " + startPercent + "%";
                var right = color + " " + endPercent + "%";
                var right2 = color + " " + 100 + "%";
                var middle = fillColor + " " + startPercent + "%";
                var middle2 = fillColor + " " + endPercent + "%";
                template = template.replace("$left$", left);
                template = template.replace("$left2$", left2);
                template = template.replace("$right$", right);
                template = template.replace("$right2$", right2);
                template = template.replace("$middle$", middle);
                template = template.replace("$middle2$", middle2);
                return template;
            }

            function _buildFallBackURL(url) {
                if (!url.includes("render")) {
                    // not using API render service
                    return url;
                }
                var splitIcon = url.split("/");
                var id = splitIcon[splitIcon.length - 1];
                if (useDarthmaim) {
                    var signature = splitIcon[splitIcon.length - 2];
                    return (
                        "https://icons-gw2.darthmaim-cdn.com/" +
                        signature +
                        "/" +
                        id
                    );
                } else {
                    return "https://assets.gw2dat.com/" + id;
                }
            }

            function buildFallBackURL(skill) {
                if (!skill.icon || skill.fallBack) {
                    return;
                }
                var apiIcon = skill.icon;
                skill.icon = _buildFallBackURL(apiIcon);
                skill.fallBack = true;
            }

            function findSkill(isBuff, id) {
                var skill;
                if (isBuff) {
                    skill = logData.buffMap["b" + id] || {};
                    skill.condi = true;
                } else {
                    skill = logData.skillMap["s" + id] || {};
                }
                skill.id = id;
                if (!apiRenderServiceOkay) {
                    buildFallBackURL(skill);
                }
                return skill;
            }

            function getTargetCacheID(activetargets) {
                var id = 0;
                for (var i = 0; i < activetargets.length; i++) {
                    id += Math.pow(2, activetargets[i]);
                }
                return id;
            }

            function getDPSGraphCacheID(
                dpsmode,
                damagemode,
                graphmode,
                activetargets,
                phaseIndex,
                extra
            ) {
                return (
                    "dps" +
                    dpsmode +
                    "-" +
                    damagemode +
                    "-" +
                    graphmode +
                    "-" +
                    getTargetCacheID(activetargets) +
                    "-" +
                    phaseIndex +
                    (extra !== null ? "-" + extra : "")
                );
            }

            function graphTypeEnumToString(mode) {
                var name = "";
                switch (mode) {
                    case GraphType.DPS:
                        name = "DPS";
                        break;
                    case GraphType.CenteredDPS:
                        name = "Centered DPS";
                        break;
                    case GraphType.Damage:
                        name = "Damage";
                        break;
                    default:
                        break;
                }
                return name;
            }

            function addPointsToGraph(res, graph, max) {
                if (!graph) {
                    return;
                }
                var points = [];
                for (var j = 0; j < graph.length; j++) {
                    points[j] = (graph[j][1] * max) / 100.0;
                }
                res.push(points);
            }

            function addMechanicsToGraph(data, phase, phaseIndex) {
                for (var i = 0; i < graphData.mechanics.length; i++) {
                    var mech = graphData.mechanics[i];
                    var mechData = logData.mechanicMap[i];
                    var chart = {
                        x: [],
                        mode: "markers",
                        visible: mech.visible ? null : "legendonly",
                        type: "scatter",
                        marker: {
                            symbol: mech.symbol,
                            color: mech.color,
                            size: mech.size ? mech.size : 15,
                        },
                        text: [],
                        name: mechData.name,
                        hoverinfo: "text",
                    };
                    if (mechData.enemyMech) {
                        for (
                            var j = 0;
                            j < mech.points[phaseIndex].length;
                            j++
                        ) {
                            var pts = mech.points[phaseIndex][j];
                            var tarId = phase.targets[j];
                            if (tarId >= 0) {
                                var target = logData.targets[tarId];
                                for (var k = 0; k < pts.length; k++) {
                                    var time = pts[k][0];
                                    chart.x.push(time);
                                    chart.text.push(time + "s: " + target.name);
                                }
                            } else {
                                for (var k = 0; k < pts.length; k++) {
                                    var time = pts[k][0];
                                    chart.x.push(time);
                                    chart.text.push(time + "s: " + pts[k][1]);
                                }
                            }
                        }
                    } else {
                        for (
                            var j = 0;
                            j < mech.points[phaseIndex].length;
                            j++
                        ) {
                            var pts = mech.points[phaseIndex][j];
                            var player = logData.players[j];
                            for (var k = 0; k < pts.length; k++) {
                                var time = pts[k][0];
                                chart.x.push(time);
                                chart.text.push(time + "s: " + player.name);
                            }
                        }
                    }
                    data.push(chart);
                }
            }

            function updateMechanicsYValues(
                res,
                phase,
                phaseIndex,
                phaseGraphData,
                activePlayers,
                max
            ) {
                for (var i = 0; i < graphData.mechanics.length; i++) {
                    var mech = graphData.mechanics[i];
                    var mechData = logData.mechanicMap[i];
                    var chart = [];
                    res.push(chart);
                    if (mechData.enemyMech) {
                        for (
                            var j = 0;
                            j < mech.points[phaseIndex].length;
                            j++
                        ) {
                            var pts = mech.points[phaseIndex][j];
                            var tarId = phase.targets[j];
                            if (tarId >= 0) {
                                var health =
                                    phaseGraphData.targets[j].healthStates;
                                for (var k = 0; k < pts.length; k++) {
                                    chart.push(
                                        (findState(
                                            health,
                                            pts[k][0],
                                            0,
                                            health.length - 1
                                        ) *
                                            max) /
                                            100.0
                                    );
                                }
                            } else {
                                for (var k = 0; k < pts.length; k++) {
                                    chart.push(max * 0.5);
                                }
                            }
                        }
                    } else {
                        let indexInGraph = 0;
                        for (
                            var j = 0;
                            j < mech.points[phaseIndex].length;
                            j++
                        ) {
                            if (!activePlayers[j]) {
                                continue;
                            }
                            var pts = mech.points[phaseIndex][j];
                            for (var k = 0; k < pts.length; k++) {
                                var time = pts[k][0];
                                var ftime = Math.floor(time);
                                var y = res[indexInGraph][ftime];
                                var yp1 = res[indexInGraph][ftime + 1];
                                chart.push(
                                    interpolatePoint(
                                        ftime,
                                        ftime + 1,
                                        y,
                                        yp1,
                                        time
                                    )
                                );
                            }
                            indexInGraph++;
                        }
                    }
                }
            }

            function interpolatePoint(x1, x2, y1, y2, x) {
                if (typeof y2 !== "undefined") {
                    return y1 + ((y2 - y1) / (x2 - x1)) * (x - x1);
                } else {
                    return y1;
                }
            }

            function damageTypeEnumToString(mode) {
                var name = "";
                switch (mode) {
                    case DamageType.All:
                        name = "All";
                        break;
                    case DamageType.Power:
                        name = "Power";
                        break;
                    case DamageType.Condition:
                        name = "Condition";
                        break;
                    case DamageType.Breakbar:
                        name = "Breakbar";
                        break;
                    default:
                        break;
                }
                return name;
            }

            function getDamageGraphName(damageMode, graphMode) {
                return (
                    damageTypeEnumToString(damageMode) +
                    " " +
                    graphTypeEnumToString(graphMode) +
                    " Graph"
                );
            }

            function computeRotationData(
                rotationData,
                images,
                data,
                phase,
                actor,
                yAxis
            ) {
                if (rotationData) {
                    var rotaTrace = {
                        x: [],
                        base: [],
                        y: [],
                        name: actor.name,
                        text: [],
                        orientation: "h",
                        mode: "markers",
                        type: "bar",
                        textposition: "none",
                        width: [],
                        hoverinfo: "text",
                        hoverlabel: {
                            namelength: "-1",
                        },
                        yaxis: yAxis === 0 ? "y" : "y" + (yAxis + 1),
                        marker: {
                            color: [],
                            width: "5",
                            line: {
                                color: [],
                                width: "2.0",
                            },
                        },
                        showlegend: false,
                    };
                    for (var i = 0; i < rotationData.length; i++) {
                        var item = rotationData[i];
                        var x = item[0];
                        var skillId = item[1];
                        var duration = item[2];
                        var endType = item[3];
                        var quick = item[4];
                        var skill = findSkill(false, skillId);
                        var aa = false;
                        var icon;
                        var name = "???";
                        if (skill) {
                            aa = skill.aa;
                            icon = skill.icon;
                            name = skill.name;
                        }

                        if (
                            !icon.includes("render") &&
                            !icon.includes("darthmaim") &&
                            !icon.includes("gw2dat")
                        ) {
                            icon = null;
                        }

                        var fillColor;
                        var originalDuration = duration;
                        if (endType === RotationStatus.REDUCED) {
                            fillColor = "rgb(0,0,255)";
                        } else if (endType === RotationStatus.CANCEL) {
                            fillColor = "rgb(255,0,0)";
                        } else if (endType === RotationStatus.FULL) {
                            fillColor = "rgb(0,255,0)";
                        } else if (endType === RotationStatus.INSTANT) {
                            fillColor = "rgb(0,255,255)";
                            duration = 50; // so that the quad is visible
                        } else {
                            // UNKNOWN
                            fillColor = "rgb(255,255,0)";
                        }

                        var clampedX = Math.max(x, 0);
                        var diffX = clampedX - x;
                        var clampedWidth =
                            Math.min(
                                x + duration / 1000.0,
                                phase.duration / 1000.0
                            ) -
                            x -
                            diffX;
                        if (!aa && icon) {
                            images.push({
                                source: icon,
                                xref: "x",
                                yref: yAxis === 0 ? "y" : "y" + (yAxis + 1),
                                x: clampedX,
                                y: 0.0,
                                sizex: 1.0,
                                sizey: 1.0,
                                xanchor: "middle",
                                yanchor: "bottom",
                            });
                        }

                        rotaTrace.x.push(clampedWidth - 0.001);
                        rotaTrace.base.push(clampedX);
                        rotaTrace.y.push(1.2);
                        var text = `${name} at ${x}s`;
                        rotaTrace.text.push(
                            endType === RotationStatus.INSTANT
                                ? text
                                : text + ` for ${originalDuration}ms`
                        );
                        rotaTrace.width.push(aa ? 0.5 : 1.0);
                        rotaTrace.marker.color.push(fillColor);

                        var outlineR =
                            quick > 0.0
                                ? quick * quickColor.r +
                                  (1.0 - quick) * normalColor.r
                                : -quick * slowColor.r +
                                  (1.0 + quick) * normalColor.r;
                        var outlineG =
                            quick > 0.0
                                ? quick * quickColor.g +
                                  (1.0 - quick) * normalColor.g
                                : -quick * slowColor.g +
                                  (1.0 + quick) * normalColor.g;
                        var outlineB =
                            quick > 0.0
                                ? quick * quickColor.b +
                                  (1.0 - quick) * normalColor.b
                                : -quick * slowColor.b +
                                  (1.0 + quick) * normalColor.b;
                        rotaTrace.marker.line.color.push(
                            "rgb(" +
                                outlineR +
                                "," +
                                outlineG +
                                "," +
                                outlineB +
                                ")"
                        );
                    }
                    data.push(rotaTrace);
                    return 1;
                }
                return 0;
            }

            function computePhaseMarkupSettings(
                currentArea,
                areas,
                annotations
            ) {
                var y = 1;
                var textbg = "#0000FF";
                var x = (currentArea.end + currentArea.start) / 2;
                for (var i = annotations.length - 1; i >= 0; i--) {
                    var annotation = annotations[i];
                    var area = areas[i];
                    if (
                        (area.start <= currentArea.start &&
                            area.end >= currentArea.end) ||
                        area.end >= currentArea.start - 2
                    ) {
                        // current area included in area OR current area intersects area
                        if (annotation.bgcolor === textbg) {
                            textbg = "#FF0000";
                        }
                        y =
                            annotation.y === y && area.end > currentArea.start
                                ? 1.09
                                : y;
                        break;
                    }
                }
                return {
                    y: y,
                    x: x,
                    textbg: textbg,
                };
            }

            function computePhaseMarkups(
                shapes,
                annotations,
                phase,
                linecolor
            ) {
                if (phase.markupAreas) {
                    for (var i = 0; i < phase.markupAreas.length; i++) {
                        var area = phase.markupAreas[i];
                        var setting = computePhaseMarkupSettings(
                            area,
                            phase.markupAreas,
                            annotations
                        );
                        if (area.label) {
                            annotations.push({
                                x: setting.x,
                                y: setting.y,
                                xref: "x",
                                yref: "paper",
                                xanchor: "center",
                                yanchor: "bottom",
                                text:
                                    area.label +
                                    "<br>" +
                                    "(" +
                                    Math.round(1000 * (area.end - area.start)) /
                                        1000 +
                                    " s)",
                                font: {
                                    color: "#ffffff",
                                },
                                showarrow: false,
                                bordercolor: "#A0A0A0",
                                borderwidth: 2,
                                bgcolor: setting.textbg,
                                opacity: 0.8,
                            });
                        }

                        if (area.highlight) {
                            shapes.push({
                                type: "rect",
                                xref: "x",
                                yref: "paper",
                                x0: area.start,
                                y0: 0,
                                x1: area.end,
                                y1: 1,
                                fillcolor: setting.textbg,
                                opacity: 0.2,
                                line: {
                                    width: 0,
                                },
                                layer: "below",
                            });
                        }
                    }
                }
                if (phase.markupLines) {
                    for (var i = 0; i < phase.markupLines.length; i++) {
                        var x = phase.markupLines[i];
                        shapes.push({
                            type: "line",
                            xref: "x",
                            yref: "paper",
                            x0: x,
                            y0: 0,
                            x1: x,
                            y1: 1,
                            line: {
                                color: linecolor,
                                width: 2,
                                dash: "dash",
                            },
                            opacity: 0.6,
                        });
                    }
                }
            }

            function computePlayerDPS(
                player,
                damageGraphs,
                lim,
                phasebreaks,
                activetargets,
                cacheID,
                times,
                graphMode,
                damageMode
            ) {
                if (player.dpsGraphCache.has(cacheID)) {
                    return player.dpsGraphCache.get(cacheID);
                }
                var totalDamage = 0;
                var totalDamageTaken = 0;
                var targetDamage = 0;
                var totalDPS = [0];
                var cleaveDPS = [0];
                var targetDPS = [0];
                var takenDPS = [0];
                var maxDPS = {
                    total: 0,
                    cleave: 0,
                    target: 0,
                    taken: 0,
                };
                var centeredDPS =
                    graphMode === GraphType.CenteredDPS &&
                    times[times.length - 1] > 2;
                if (centeredDPS) {
                    lim /= 2;
                }
                var end = times.length;
                var left = 0,
                    right = 0,
                    targetid,
                    k;
                var roundingToUse =
                    damageMode === DamageType.Breakbar
                        ? numberComponent.methods.round1
                        : numberComponent.methods.round;
                for (var j = 0; j < end; j++) {
                    var time = times[j];
                    if (lim > 0) {
                        left = Math.max(Math.round(time - lim), 0);
                    } else if (phasebreaks && phasebreaks[j]) {
                        left = j;
                    }
                    right = j;
                    if (centeredDPS) {
                        if (lim > 0) {
                            right = Math.min(Math.round(time + lim), end - 1);
                        } else if (phasebreaks) {
                            for (
                                var i = left + 1;
                                i < phasebreaks.length;
                                i++
                            ) {
                                if (phasebreaks[i]) {
                                    right = i;
                                    break;
                                }
                            }
                        } else {
                            right = end - 1;
                        }
                    }
                    var div =
                        graphMode !== GraphType.Damage
                            ? Math.max(times[right] - times[left], 1)
                            : 1;
                    totalDamage =
                        damageGraphs.total[right] - damageGraphs.total[left];
                    totalDamageTaken =
                        damageGraphs.taken[right] - damageGraphs.taken[left];
                    targetDamage = 0;
                    for (k = 0; k < activetargets.length; k++) {
                        targetid = activetargets[k];
                        targetDamage +=
                            damageGraphs.targets[targetid][right] -
                            damageGraphs.targets[targetid][left];
                    }
                    totalDPS[j] = roundingToUse(totalDamage / div);
                    targetDPS[j] = roundingToUse(targetDamage / div);
                    cleaveDPS[j] = roundingToUse(
                        (totalDamage - targetDamage) / div
                    );
                    takenDPS[j] = roundingToUse(totalDamageTaken / div);
                    maxDPS.total = Math.max(maxDPS.total, totalDPS[j]);
                    maxDPS.target = Math.max(maxDPS.target, targetDPS[j]);
                    maxDPS.cleave = Math.max(maxDPS.cleave, cleaveDPS[j]);
                    maxDPS.taken = Math.max(maxDPS.taken, takenDPS[j]);
                }
                if (maxDPS.total < 1e-6) {
                    maxDPS.total = 10;
                }
                if (maxDPS.target < 1e-6) {
                    maxDPS.target = 10;
                }
                if (maxDPS.cleave < 1e-6) {
                    maxDPS.cleave = 10;
                }
                if (maxDPS.taken < 1e-6) {
                    maxDPS.taken = 10;
                }
                var res = {
                    dps: {
                        total: totalDPS,
                        target: targetDPS,
                        cleave: cleaveDPS,
                        taken: takenDPS,
                    },
                    maxDPS: maxDPS,
                };
                player.dpsGraphCache.set(cacheID, res);
                return res;
            }

            function findState(states, timeS, start, end) {
                // when the array exists, it covers from 0 to fightEnd by construction
                var id = Math.floor((end + start) / 2);
                if (id === start || id === end) {
                    return states[id][1];
                }
                var item = states[id];
                var itemN = states[id + 1];
                var x = item[0];
                var xN = itemN[0];
                if (timeS < x) {
                    return findState(states, timeS, start, id);
                } else if (timeS > xN) {
                    return findState(states, timeS, id, end);
                } else {
                    return item[1];
                }
            }

            function getActorGraphLayout(images, color, hasBuffs, noIncoming) {
                let layout = {
                    barmode: "stack",
                    yaxis2: {
                        title: "Rotation",
                        domain: hasBuffs ? [0.45, 0.54] : [0.0, 0.09],
                        fixedrange: true,
                        showgrid: false,
                        showticklabels: false,
                        color: color,
                        range: [0, 2],
                    },
                    legend: {
                        traceorder: "reversed",
                    },
                    hovermode: "x",
                    hoverdistance: 150,
                    yaxis: {
                        title: "Duration Buffs",
                        domain: hasBuffs ? [0.0, 0.44] : [0.0, 0.0],
                        color: color,
                        gridcolor: color,
                        tickformat: ",d",
                        fixedrange: true,
                        side: "right",
                        range: [0, 1.5],
                        nticks: 2,
                    },
                    yaxis4: {
                        title: "Intensity Buffs",
                        domain: hasBuffs ? [0.0, 0.44] : [0.0, 0.0],
                        color: color,
                        gridcolor: color,
                        tickformat: ",d",
                        fixedrange: true,
                        overlaying: "y",
                        nticks: 10,
                    },
                    images: images,
                    font: {
                        color: color,
                    },
                    xaxis: {
                        title: "Time(sec)",
                        color: color,
                        rangemode: "nonnegative",
                        gridcolor: color,
                        tickmode: "auto",
                        nticks: 8,
                        xrangeslider: {},
                        domain: [0.0, 0.95],
                    },
                    paper_bgcolor: "rgba(0,0,0,0)",
                    plot_bgcolor: "rgba(0,0,0,0)",
                    shapes: [],
                    annotations: [],
                    autosize: true,
                    height: 850,
                    datarevision: new Date().getTime(),
                };
                if (noIncoming) {
                    Object.assign(layout, {
                        yaxis3: {
                            title: "Outgoing",
                            domain: hasBuffs ? [0.55, 1.0] : [0.1, 1.0],
                            color: color,
                            fixedrange: true,
                            gridcolor: color,
                            tickformat: ",d",
                        },
                    });
                } else {
                    Object.assign(layout, {
                        yaxis3: {
                            title: "Outgoing",
                            domain: hasBuffs ? [0.68, 1.0] : [0.23, 1.0],
                            color: color,
                            fixedrange: true,
                            gridcolor: color,
                            tickformat: ",d",
                        },
                        yaxis5: {
                            title: "Incoming",
                            domain: hasBuffs ? [0.55, 0.67] : [0.1, 0.22],
                            color: color,
                            fixedrange: true,
                            gridcolor: color,
                            tickformat: ",d",
                            nticks: 2,
                        },
                    });
                }
                return layout;
            }

            function _computeTargetGraphData(
                graph,
                targets,
                phase,
                data,
                yaxis,
                jsonGraphName,
                percentName,
                graphName,
                visible
            ) {
                var count = 0;
                for (var i = 0; i < graph.targets.length; i++) {
                    var graphData = graph.targets[i][jsonGraphName];
                    if (!graphData) {
                        continue;
                    }
                    count++;
                    var texts = [];
                    var times = [];
                    var target = targets[phase.targets[i]];
                    for (var j = 0; j < graphData.length; j++) {
                        texts[j] =
                            graphData[j][1] +
                            "% " +
                            percentName +
                            " - " +
                            target.name;
                        times[j] = graphData[j][0];
                    }
                    var res = {
                        x: times,
                        text: texts,
                        mode: "lines",
                        line: {
                            dash: "dashdot",
                            shape: "hv",
                        },
                        hoverinfo: "text",
                        visible: visible ? true : "legendonly",
                        name: target.name + " " + graphName,
                    };
                    if (yaxis) {
                        res.yaxis = yaxis;
                    }
                    data.push(res);
                }
                return count;
            }

            function computeTargetHealthData(
                graph,
                targets,
                phase,
                data,
                yaxis
            ) {
                return _computeTargetGraphData(
                    graph,
                    targets,
                    phase,
                    data,
                    yaxis,
                    "healthStates",
                    "hp",
                    "health",
                    !logData.wvw
                );
            }

            function computeTargetBarrierData(
                graph,
                targets,
                phase,
                data,
                yaxis
            ) {
                return _computeTargetGraphData(
                    graph,
                    targets,
                    phase,
                    data,
                    yaxis,
                    "barrierStates",
                    "barrier",
                    "barrier",
                    false
                );
            }

            function computeTargetBreakbarData(
                graph,
                targets,
                phase,
                data,
                yaxis
            ) {
                return _computeTargetGraphData(
                    graph,
                    targets,
                    phase,
                    data,
                    yaxis,
                    "breakbarPercentStates",
                    "breakbar",
                    "breakbar",
                    phase.breakbarPhase
                );
            }

            function _computePlayerGraphData(
                graph,
                player,
                data,
                yaxis,
                graphName,
                percentName
            ) {
                if (!graph) {
                    return 0;
                }
                var texts = [];
                var times = [];
                for (var j = 0; j < graph.length; j++) {
                    texts[j] =
                        graph[j][1] + "%" + percentName + " - " + player.name;
                    times[j] = graph[j][0];
                }
                var res = {
                    x: times,
                    text: texts,
                    mode: "lines",
                    line: {
                        dash: "dashdot",
                        shape: "hv",
                    },
                    hoverinfo: "text",
                    name: player.name + " " + graphName,
                    visible: "legendonly",
                };
                if (yaxis) {
                    res.yaxis = yaxis;
                }
                data.push(res);
                return 1;
            }

            function computePlayerHealthData(healthGraph, player, data, yaxis) {
                return _computePlayerGraphData(
                    healthGraph,
                    player,
                    data,
                    yaxis,
                    "health",
                    "hp"
                );
            }

            function computePlayerBarrierData(
                barrierGraph,
                player,
                data,
                yaxis
            ) {
                return _computePlayerGraphData(
                    barrierGraph,
                    player,
                    data,
                    yaxis,
                    "barrier",
                    "barrier"
                );
            }

            function computeBuffData(buffData, data) {
                if (buffData) {
                    for (var i = 0; i < buffData.length; i++) {
                        var boonItem = buffData[i];
                        var boon = findSkill(true, boonItem.id);
                        var line = {
                            x: [],
                            y: [],
                            text: [],
                            yaxis: boon.stacking ? "y4" : "y",
                            type: "scatter",
                            visible: boonItem.visible ? null : "legendonly",
                            line: {
                                color: boonItem.color,
                                shape: "hv",
                            },
                            hoverinfo: "text+x",
                            fill: "tozeroy",
                            name: boon.name.substring(0, 20),
                        };
                        for (var p = 0; p < boonItem.states.length; p++) {
                            line.x.push(boonItem.states[p][0]);
                            line.y.push(boonItem.states[p][1]);
                            line.text.push(
                                boon.name + ": " + boonItem.states[p][1]
                            );
                        }
                        data.push(line);
                    }
                    return buffData.length;
                }
                return 0;
            }

            function computeTargetDPS(
                target,
                damageGraphs,
                lim,
                phasebreaks,
                cacheID,
                times,
                graphMode
            ) {
                if (target.dpsGraphCache.has(cacheID)) {
                    return target.dpsGraphCache.get(cacheID);
                }
                var totalDamage = 0;
                var totalDPS = [0];
                var maxDPS = 0;
                var left = 0,
                    right = 0;
                var end = times.length;
                var centeredDPS =
                    graphMode === GraphType.CenteredDPS &&
                    times[times.length - 1] > 2;
                if (centeredDPS) {
                    lim /= 2;
                }
                for (var j = 0; j < end; j++) {
                    var time = times[j];
                    if (lim > 0) {
                        left = Math.max(Math.round(time - lim), 0);
                    } else if (phasebreaks && phasebreaks[j]) {
                        left = j;
                    }
                    right = j;
                    if (centeredDPS) {
                        if (lim > 0) {
                            right = Math.min(Math.round(time + lim), end - 1);
                        } else if (phasebreaks) {
                            for (
                                var i = left + 1;
                                i < phasebreaks.length;
                                i++
                            ) {
                                if (phasebreaks[i]) {
                                    right = i;
                                    break;
                                }
                            }
                        } else {
                            right = end - 1;
                        }
                    }
                    var div =
                        graphMode !== GraphType.Damage
                            ? Math.max(times[right] - times[left], 1)
                            : 1;
                    totalDamage = damageGraphs[right] - damageGraphs[left];
                    totalDPS[j] = Math.round(totalDamage / div);
                    maxDPS = Math.max(maxDPS, totalDPS[j]);
                }
                if (maxDPS < 1e-6) {
                    maxDPS = 10;
                }
                var res = {
                    dps: totalDPS,
                    maxDPS: maxDPS,
                };
                target.dpsGraphCache.set(cacheID, res);
                return res;
            }

            function addTargetLayout(
                data,
                target,
                states,
                percentName,
                graphName,
                visible
            ) {
                if (!states) {
                    return 0;
                }
                var texts = [];
                var times = [];
                for (var j = 0; j < states.length; j++) {
                    texts[j] = states[j][1] + "% " + percentName;
                    times[j] = states[j][0];
                }
                var res = {
                    x: times,
                    text: texts,
                    mode: "lines",
                    line: {
                        dash: "dashdot",
                        shape: "hv",
                    },
                    hoverinfo: "text",
                    visible: visible ? true : "legendonly",
                    name: target.name + " " + graphName,
                    yaxis: "y3",
                };
                data.push(res);
                return 1;
            }

            /*function getActorGraphLayout(images, boonYs, stackingBoons) {
    var layout = {
        barmode: 'stack',
        yaxis: {
            title: 'Rotation',
            domain: [0, 0.1],
            fixedrange: true,
            showgrid: false,
            showticklabels: false,
            color: '#cccccc',
            range: [0, 2]
        },
        legend: {
            traceorder: 'reversed'
        },
        hovermode: 'compare',
        images: images,
        font: {
            color: '#cccccc'
        },
        xaxis: {
            title: 'Time(sec)',
            rangemode: 'nonnegative',
            color: '#cccccc',
            tickmode: 'auto',
            nticks: 8,
            gridcolor: '#cccccc',
            xrangeslider: {}
        },
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        shapes: [],
        annotations: [],
        autosize: true,
        height: 1100,
        datarevision: new Date().getTime(),
    };
    layout['yaxis' + (2 + boonYs)] = {
        title: 'DPS',
        color: '#cccccc',
        gridcolor: '#cccccc',
        domain: [0.75, 1]
    };
    var perBoon = 0.65 / boonYs;
    var singleBuffs = boonYs;
    if (stackingBoons) {
        layout['yaxis' + (2 + boonYs - 1)] = {
            title: 'Stacking Buffs',
            color: '#cccccc',
            gridcolor: '#cccccc',
            domain: [0.70, 0.75]
        };
        perBoon = 0.6 / (boonYs - 1);
        singleBuffs--;
    }
    for (var i = 0; i < singleBuffs; i++) {
        layout['yaxis' + (2 + i)] = {
            title: '',
            color: '#cccccc',
            showgrid: false,
            showticklabels: false,
            domain: [0.1 + i * perBoon, 0.1 + (i + 1) * perBoon]
        };
    }
    return layout;
}*/

            /*
function computeBuffData(buffData, data) {
    var ystart = 0;
    if (buffData) {
        var stackings = [];
        var i;
        for (i = buffData.length - 1; i >= 0; i--) {
            var boonItem = buffData[i];
            var boon = findSkill(true, boonItem.id);
            var line = {
                x: [],
                y: [],
                yaxis: boon.stacking ? 'stacking' : 'y' + (2 + ystart++),
                type: 'scatter',
                visible: boonItem.visible || !boon.stacking ? null : 'legendonly',
                line: {
                    color: boonItem.color,
                    shape: 'hv'
                },
                fill: boon.stacking ? 'tozeroy' : 'toself',
                name: boon.name,
                showlegend: boon.stacking ? true : false,
            };
            for (var p = 0; p < boonItem.states.length; p++) {
                line.x[p] = boonItem.states[p][0];
                line.y[p] = boonItem.states[p][1];
            }
            if (boon.stacking) {
                stackings.push(line);
            }
            data.push(line);
        }
        if (stackings.length) {
            var axis = 'y' + (2 + ystart++);
            for (i = 0; i < stackings.length; i++) {
                stackings[i].yaxis = axis;
            }
        }
        return {
            actorOffset: buffData.length,
            y: ystart,
            stacking: stackings.length > 0
        };
    }
    return {
        actorOffset: 0,
        y: 0,
        stacking: false
    };
}*/

            function hasRotations() {
                return logData.players.length > 1;
            }

            function hasOutgoingDamageMods() {
                return Object.keys(logData.damageModMap).length !== 0;
            }

            function hasIncomingDamageMods() {
                return Object.keys(logData.damageIncModMap).length !== 0;
            }

            function hasDamageMods() {
                return hasOutgoingDamageMods() || hasIncomingDamageMods();
            }

            function playerMechanics() {
                var playerMechanics = [];
                for (var i = 0; i < logData.mechanicMap.length; i++) {
                    var mech = logData.mechanicMap[i];
                    if (mech.playerMech) {
                        playerMechanics.push(mech);
                    }
                }
                return playerMechanics;
            }

            function enemyMechanics() {
                var enemyMechanics = [];
                for (var i = 0; i < logData.mechanicMap.length; i++) {
                    var mech = logData.mechanicMap[i];
                    if (mech.enemyMech) {
                        enemyMechanics.push(mech);
                    }
                }
                return enemyMechanics;
            }

            function hasMechanics() {
                if (logData.mechanicMap.length > 0 && !logData.noMechanics) {
                    return (
                        enemyMechanics().length > 0 ||
                        playerMechanics().length > 0
                    );
                }
                return false;
            }

            function hasTargets() {
                return !logData.targetless;
            }

            function hasOffBuffs() {
                return logData.offBuffs.length > 0;
            }
            function hasDefBuffs() {
                return logData.defBuffs.length > 0;
            }
            function hasSupBuffs() {
                return logData.supBuffs.length > 0;
            }
            function hasGearBuffs() {
                return logData.gearBuffs.length > 0;
            }
            function hasDebuffs() {
                return logData.debuffs.length > 0;
            }
            function hasConditions() {
                return logData.conditions.length > 0;
            }
            function hasNourishments() {
                return logData.nourishments.length > 0;
            }
            function hasEnhancements() {
                return logData.enhancements.length > 0;
            }
            function hasOtherConsumables() {
                return logData.otherConsumables.length > 0;
            }
            function hasPersBuffs() {
                var hasPersBuffs = false;
                if (logData.persBuffs) {
                    for (var prop in logData.persBuffs) {
                        if (
                            logData.persBuffs.hasOwnProperty(prop) &&
                            logData.persBuffs[prop].length > 0
                        ) {
                            hasPersBuffs = true;
                            break;
                        }
                    }
                }
                return hasPersBuffs;
            }

            function showDeathRecap() {
                for (var i = 0; i < logData.players.length; i++) {
                    if (!!logData.players[i].details.deathRecap) {
                        return true;
                    }
                }
                return false;
            }

            function hasBarrierExtension() {
                return !!barrierStatsExtension;
            }

            function validateStartPath(path) {
                const setting = EIUrlParams.get("startPage");
                if (!setting) {
                    return false;
                }
                return setting.startsWith(path);
            }

            function getActivePlayers(time) {
                let res = [];
                for (let i = 0; i < logData.players.length; i++) {
                    const player = logData.players[i];
                    if (
                        (player.notInSquad &&
                            (player.firstAware > time ||
                                player.lastAware < time)) ||
                        (player.isEnglobed &&
                            ((!player.isFirstEnglobed &&
                                player.firstAware > time) ||
                                (!player.isLastEnglobed &&
                                    player.lastAware < time)))
                    ) {
                        res.push(null);
                    } else {
                        res.push(player);
                    }
                }
                return res;
            }

            function getActiveNonFakePlayers(time) {
                let res = [];
                for (let i = 0; i < logData.players.length; i++) {
                    const player = logData.players[i];
                    if (
                        player.isFake ||
                        (player.notInSquad &&
                            (player.firstAware > time ||
                                player.lastAware < time)) ||
                        (player.isEnglobed &&
                            ((!player.isFirstEnglobed &&
                                player.firstAware > time) ||
                                (!player.isLastEnglobed &&
                                    player.lastAware < time)))
                    ) {
                        res.push(null);
                    } else {
                        res.push(player);
                    }
                }
                return res;
            }

            function getActivePlayersForPhase(phase) {
                if (
                    phase.type !== PhaseTypes.INSTANCE &&
                    phase.type !== PhaseTypes.ENCOUNTER
                ) {
                    throw "Expected an instance or encounter phase";
                }
                let res = [];
                const start = phase.start;
                const end = phase.end;
                for (let i = 0; i < logData.players.length; i++) {
                    const player = logData.players[i];
                    if (player.lastAware <= start || player.firstAware >= end) {
                        res.push(null);
                    } else {
                        res.push(player);
                    }
                }
                return res;
            }

            function getActiveNonFakePlayersForPhase(phase) {
                if (
                    phase.type !== PhaseTypes.INSTANCE &&
                    phase.type !== PhaseTypes.ENCOUNTER
                ) {
                    throw "Expected an instance or encounter phase";
                }
                let res = [];
                const start = phase.start;
                const end = phase.end;
                for (let i = 0; i < logData.players.length; i++) {
                    const player = logData.players[i];
                    if (
                        player.isFake ||
                        player.lastAware <= start ||
                        player.firstAware >= end
                    ) {
                        res.push(null);
                    } else {
                        res.push(player);
                    }
                }
                return res;
            }

            function getPhasesForSelectedEncounter(phases, encounters) {
                for (let i = 0; i < encounters.length; i++) {
                    const encounter = encounters[i];
                    if (encounter.active) {
                        const phase = logData.phases[encounter.index];
                        let resPhases = [];
                        if (phase.type === PhaseTypes.INSTANCE) {
                            if (IsMultiEncounterLog) {
                                for (let j = 0; j < phases.length; j++) {
                                    const subPhase = logData.phases[j];
                                    if (
                                        subPhase === phase ||
                                        subPhase.type === PhaseTypes.ENCOUNTER
                                    ) {
                                        resPhases.push(phases[j]);
                                    }
                                }
                            } else {
                                return phases;
                            }
                        } else {
                            if (IsMultiEncounterLog) {
                                for (let j = 0; j < phases.length; j++) {
                                    const subPhase = logData.phases[j];
                                    if (
                                        subPhase === phase ||
                                        subPhase.encounterPhase ===
                                            encounter.index
                                    ) {
                                        resPhases.push(phases[j]);
                                    }
                                }
                            } else {
                                return phases;
                            }
                        }
                        return resPhases;
                    }
                }
                return phases;
            }
            /*jshint esversion: 6 */
            ("use strict");
            function compileTemplates() {
                Vue.component("custom-numberform-component", {
                    props: ["minValue", "maxValue", "id", "placeholderValue"],
                    template: `
        <div>
            <input class="form-control" type="number" :id="id"
                @onkeypress="return isNumber(event)" onpaste="return false;" step="2"
                    :value="placeholderValue" data-bind="value:replyNumber, fireChange: true"
                    :min="minValue" :max="maxValue">
        </div>
        `,
                    methods: {
                        isNumber: function (evt) {
                            evt = evt ? evt : window.event;
                            const charCode = evt.which
                                ? evt.which
                                : evt.keyCode;
                            if (
                                (charCode > 31 && charCode < 48) ||
                                charCode > 57
                            ) {
                                return false;
                            }
                            return true;
                        },
                    },
                    mounted() {
                        $("#" + this.id).on("input ", function () {
                            const max = parseInt($(this).attr("max")) || 1e12;
                            const min = parseInt($(this).attr("min"));
                            if ($(this).val() > max) {
                                $(this).val(max);
                            } else if ($(this).val() < min) {
                                $(this).val(min);
                            }
                        });
                    },
                });
                Vue.component("table-scroll-component", {
                    props: [
                        "min",
                        "max",
                        "width",
                        "height",
                        "transform",
                        "pagestructure",
                    ],
                    template: `
        <input
            style="background-color: #888888;"
            :style=getStyle()
            type="range" :min="min" :max="max" :value="min" class="slider" @input="updateOffset($event.target.value)">
        `,
                    methods: {
                        updateOffset: function (value) {
                            this.pagestructure.offset = parseInt(value);
                        },
                        getStyle: function () {
                            const res = {
                                width: this.width,
                                height: this.height,
                                transform: this.transform,
                            };
                            return res;
                        },
                    },
                });
                Vue.component("targetperplayer-graphs-tab-component", {
                    props: [
                        "targetindex",
                        "phaseindex",
                        "light",
                        "playerindex",
                    ],
                    mixins: [encounterPhaseComponent],
                    template: `
        <div>
            <keep-alive>
                <targetperplayer-graph-tab-component v-for="(player, pId) in players" v-if="pId === playerindex"
                :key="phaseindex + 'perplayer' + pId" :targetindex="targetindex" :phaseindex="phaseindex" :light="light"
                :playerindex="playerindex">
                </targetperplayer-graph-tab-component>
            <keep-alive>
        </div>
        `,
                    computed: {
                        players: function () {
                            return getActivePlayersForPhase(
                                this.encounterPhase
                            );
                        },
                    },
                });
                {
                    const plotlyConfig = {
                        modeBarButtonsToRemove: ["select2d", "lasso2d"],
                        showEditInChartStudio: true,
                        plotlyServerURL: "https://chart-studio.plotly.com",
                    };
                    Vue.component("graph-component", {
                        props: ["id", "layout", "data", "removerangecontrol"],
                        template: `    <div>        <div :id="id" class="d-flex flex-row justify-content-center"></div>        <div v-if="!removerangecontrol" style="position:absolute; margin-top: -60px;margin-left: 100px; z-index: 1;">            <div class="d-flex flex-row align-items-center">                <custom-numberform-component class="mr-1" style="width: 100px;" :minValue="-1e6" :maxValue="1e6" :id="id+'xMin'"                    :placeholderValue="0"></custom-numberform-component>                <custom-numberform-component style="width: 100px;" :minValue="-1e6" :maxValue="1e6" :id="id+'xMax'"                    :placeholderValue="0"></custom-numberform-component>            </div>        </div>    </div>`,
                        activated: function () {
                            var div = document.querySelector(this.queryID);
                            Plotly.react(
                                div,
                                this.data,
                                this.layout,
                                plotlyConfig
                            );
                            var _this = this;
                            div.on("plotly_animated", function () {
                                $(_this.queryID + "xMin").val(
                                    _this.layout.xaxis.range[0]
                                );
                                $(_this.queryID + "xMax").val(
                                    _this.layout.xaxis.range[1]
                                );
                                // to be safe
                                for (
                                    let yAxisIndex = 0;
                                    yAxisIndex < 8;
                                    yAxisIndex++
                                ) {
                                    let yAxisName =
                                        "yaxis" +
                                        (yAxisIndex > 0 ? yAxisIndex : "");
                                    let yAxisDataName =
                                        "y" +
                                        (yAxisIndex > 0 ? yAxisIndex : "");
                                    if (!_this.layout[yAxisName]) {
                                        continue;
                                    }
                                    if (_this.layout[yAxisName].autorange) {
                                        let minRange = Number.MAX_SAFE_INTEGER;
                                        let maxRange = Number.MIN_SAFE_INTEGER;
                                        for (
                                            let i = 0;
                                            i < _this.data.length;
                                            i++
                                        ) {
                                            let curData = _this.data[i];
                                            if (yAxisIndex === 0) {
                                                if (
                                                    curData.yaxis &&
                                                    curData.yaxis !==
                                                        yAxisDataName
                                                ) {
                                                    continue;
                                                }
                                            } else if (
                                                curData.yaxis !== yAxisDataName
                                            ) {
                                                continue;
                                            }
                                            if (
                                                curData.y &&
                                                curData.visible !== false &&
                                                curData.visible !== "legendonly"
                                            ) {
                                                for (
                                                    let j = 0;
                                                    j < curData.y.length;
                                                    j++
                                                ) {
                                                    minRange = Math.min(
                                                        minRange,
                                                        curData.y[j]
                                                    );
                                                    maxRange = Math.max(
                                                        maxRange,
                                                        curData.y[j]
                                                    );
                                                }
                                            }
                                        }
                                        if (
                                            maxRange === Number.MIN_SAFE_INTEGER
                                        ) {
                                            maxRange = 1;
                                            minRange = 0;
                                        }
                                        _this.layout[yAxisName].range[0] = 0;
                                        _this.layout[yAxisName].range[1] =
                                            maxRange * 1.06;
                                    }
                                }
                                Plotly.relayout(div, _this.layout);
                            });
                            div.on("plotly_hover", function () {
                                $(_this.queryID + "xMin").val(
                                    _this.layout.xaxis.range[0]
                                );
                                $(_this.queryID + "xMax").val(
                                    _this.layout.xaxis.range[1]
                                );
                            });
                        },
                        computed: {
                            queryID: function () {
                                return "#" + this.id;
                            },
                        },
                        mounted() {
                            const _this = this;
                            const layout = this.layout;
                            const div = document.querySelector(this.queryID);
                            $(this.queryID + "xMin").on("input ", function () {
                                let value = Number.parseFloat($(this).val());
                                layout.xaxis.autorange = false;
                                layout.xaxis.range[0] = value;
                                layout.xaxis.range[1] = Math.max(
                                    Number.parseFloat(
                                        $(_this.queryID + "xMax").val()
                                    ),
                                    value + 1e-6
                                );
                                Plotly.relayout(div, _this.layout);
                            });
                            $(this.queryID + "xMax").on("input ", function () {
                                let value = Number.parseFloat($(this).val());
                                layout.xaxis.autorange = false;
                                layout.xaxis.range[0] = Math.min(
                                    Number.parseFloat(
                                        $(_this.queryID + "xMin").val()
                                    ),
                                    value - 1e-6
                                );
                                layout.xaxis.range[1] = value;
                                Plotly.relayout(div, _this.layout);
                            });
                        },
                        watch: {
                            layout: {
                                handler: function () {
                                    var div = document.querySelector(
                                        this.queryID
                                    );
                                    if (!div) {
                                        return;
                                    }
                                    var duration = 1000;
                                    Plotly.animate(
                                        div,
                                        {
                                            data: this.data,
                                        },
                                        {
                                            transition: {
                                                duration: duration,
                                                easing: "cubic-in-out",
                                            },
                                            frame: {
                                                duration: 0.75 * duration,
                                            },
                                        }
                                    );
                                },
                                deep: true,
                            },
                            data: {
                                handler: function () {
                                    var div = document.querySelector(
                                        this.queryID
                                    );
                                    if (!div) {
                                        return;
                                    }
                                    Plotly.react(
                                        div,
                                        this.data,
                                        this.layout,
                                        plotlyConfig
                                    );
                                },
                                deep: true,
                            },
                        },
                    });
                }
                {
                    Vue.component("buff-stats-component", {
                        props: ["type", "playerindex", "activeduration"],
                        mixins: [buffComponent, encounterPhaseComponent],
                        template: `    <div>        <div class="d-flex flex-row justify-content-center mt-1 mb-1">            <ul class="nav nav-pills d-flex flex-row justify-content-center scale85">                <li class="nav-item">                    <a class="nav-link" @click="buffMode = 0" :class="{active: buffMode === 0}"                       data-original-title="Buffs upkeep.">Uptime</a>                </li>                <li class="nav-item">                    <a class="nav-link" @click="buffMode = 1" :class="{active: buffMode === 1 }"                       data-original-title="Buffs applied to yourself.">Generation Self</a>                </li>                <li v-if="!singlePlayer" class="nav-item">                    <a class="nav-link" @click="buffMode = 2" :class="{active: buffMode === 2 }"                        data-original-title="Buffs applied to your group members. Self excluded.">Generation Group</a>                </li>                <li v-if="!singleGroup" class="nav-item">                    <a class="nav-link" @click="buffMode = 3" :class="{active: buffMode === 3 }"                        data-original-title="Buffs applied to your non-group members. Self excluded.">Generation Off-Group</a>                </li>                <li v-if="!singleGroup" class="nav-item">                    <a class="nav-link" @click="buffMode = 4" :class="{active: buffMode === 4 }"                        data-original-title="Buffs applied to the squad. Self excluded.">Generation Squad</a>                </li>            </ul>        </div>        <keep-alive>            <buff-table-component v-if="type === 0" :key="'boon-stats-table'" :condition="false" :generation="buffMode > 0"                :id="'boon-stats-table'" :buffs="boons" :playerdata="buffData.boonsData[buffMode]"                :sums="buffMode === 0 ? buffData.boonsData[5] : []" :playerindex="playerindex" :hidecustom="buffMode > 1">            </buff-table-component>            <buff-table-component v-if="type === 1" :key="'offensivebuff-stats-table'" :condition="false"                :generation="buffMode > 0" :id="'offensivebuff-stats-table'" :buffs="offs"                :playerdata="buffData.offsData[buffMode]" :sums="buffMode === 0 ? buffData.offsData[5] : []"                :playerindex="playerindex" :hidecustom="buffMode > 1">            </buff-table-component>            <buff-table-component v-if="type === 2" :key="'supportbuff-stats-table'" :condition="false"                :generation="buffMode > 0" :id="'supportbuff-stats-table'" :buffs="sups"                :playerdata="buffData.supsData[buffMode]" :sums="buffMode === 0 ? buffData.supsData[5] : []"                :playerindex="playerindex" :hidecustom="buffMode > 1">            </buff-table-component>            <buff-table-component v-if="type === 3" :key="'defensivebuff-stats-table'" :condition="false"                :generation="buffMode > 0" :id="'defensivebuff-stats-table'" :buffs="defs"                :playerdata="buffData.defsData[buffMode]" :sums="buffMode === 0 ? buffData.defsData[5] : []"                :playerindex="playerindex" :hidecustom="buffMode > 1">            </buff-table-component>        </keep-alive>    </div>`,
                        data: function () {
                            return {
                                buffMode: 0,
                                cache: new Map(),
                            };
                        },
                        methods: {
                            getData: function (name, container) {
                                const activeduration = !!this.activeduration;
                                const activeTimes =
                                    this.phase.playerActiveTimes;
                                //
                                const activeString = activeduration
                                    ? "Active"
                                    : "";
                                const uptimesStats =
                                    container[name + activeString + "Stats"];
                                const genSelfStats =
                                    container[
                                        name +
                                            "Gen" +
                                            activeString +
                                            "SelfStats"
                                    ];
                                const genGroupStats =
                                    container[
                                        name +
                                            "Gen" +
                                            activeString +
                                            "GroupStats"
                                    ];
                                const genOffGroupStats =
                                    container[
                                        name +
                                            "Gen" +
                                            activeString +
                                            "OGroupStats"
                                    ];
                                const genSquadStats =
                                    container[
                                        name +
                                            "Gen" +
                                            activeString +
                                            "SquadStats"
                                    ];
                                //
                                let uptimes = [];
                                let genSelf = [];
                                let genGroup = [];
                                let genOffGroup = [];
                                let genSquad = [];
                                let avg = [];
                                let groupAvg = [];
                                let totalAvg = [];
                                let groupCount = [];
                                let totalCount = 0;
                                let groupBoonAvg = [];
                                let totalBoonAvg = 0;
                                const players = getActiveNonFakePlayersForPhase(
                                    this.encounterPhase
                                );
                                for (let i = 0; i < players.length; i++) {
                                    const player = players[i];
                                    if (!player) {
                                        continue;
                                    }
                                    uptimes.push({
                                        player: player,
                                        data: uptimesStats[i],
                                    });
                                    genSelf.push({
                                        player: player,
                                        data: genSelfStats[i],
                                    });
                                    genGroup.push({
                                        player: player,
                                        data: genGroupStats[i],
                                    });
                                    genOffGroup.push({
                                        player: player,
                                        data: genOffGroupStats[i],
                                    });
                                    genSquad.push({
                                        player: player,
                                        data: genSquadStats[i],
                                    });
                                    if (
                                        activeduration &&
                                        activeTimes[i] < 1e-6
                                    ) {
                                        continue;
                                    }
                                    var playerWeight = activeduration
                                        ? activeTimes[i]
                                        : 1;
                                    if (player.notInSquad) {
                                        continue;
                                    }
                                    if (!groupAvg[player.group]) {
                                        groupAvg[player.group] = [];
                                        groupCount[player.group] = 0;
                                        groupBoonAvg[player.group] = 0;
                                    }
                                    totalCount += playerWeight;
                                    totalBoonAvg +=
                                        playerWeight * uptimesStats[i].avg;
                                    groupBoonAvg[player.group] +=
                                        playerWeight * uptimesStats[i].avg;
                                    groupCount[player.group] += playerWeight;
                                    for (
                                        let j = 0;
                                        j < uptimesStats[i].data.length;
                                        j++
                                    ) {
                                        totalAvg[j] =
                                            (totalAvg[j] || 0) +
                                            playerWeight *
                                                (uptimesStats[i].data[j][0] ||
                                                    0);
                                        groupAvg[player.group][j] =
                                            (groupAvg[player.group][j] || 0) +
                                            playerWeight *
                                                (uptimesStats[i].data[j][0] ||
                                                    0);
                                    }
                                }
                                for (let i = 0; i < groupAvg.length; i++) {
                                    if (groupAvg[i]) {
                                        for (
                                            let k = 0;
                                            k < groupAvg[i].length;
                                            k++
                                        ) {
                                            groupAvg[i][k] =
                                                Math.round(
                                                    (1000 * groupAvg[i][k]) /
                                                        groupCount[i]
                                                ) / 1000;
                                        }
                                        avg.push({
                                            name: "Group " + i,
                                            data: groupAvg[i],
                                            avg:
                                                Math.round(
                                                    (1000 * groupBoonAvg[i]) /
                                                        groupCount[i]
                                                ) / 1000,
                                        });
                                    }
                                }
                                for (let k = 0; k < totalAvg.length; k++) {
                                    totalAvg[k] =
                                        Math.round(
                                            (1000 * totalAvg[k]) / totalCount
                                        ) / 1000;
                                }
                                avg.push({
                                    name: "Total",
                                    data: totalAvg,
                                    avg:
                                        Math.round(
                                            (1000 * totalBoonAvg) / totalCount
                                        ) / 1000,
                                });
                                return [
                                    uptimes,
                                    genSelf,
                                    genGroup,
                                    genOffGroup,
                                    genSquad,
                                    avg,
                                ];
                            },
                        },
                        computed: {
                            singleGroup: function () {
                                return logData.singleGroup;
                            },
                            singlePlayer: function () {
                                return (
                                    logData.players.filter((x) => !x.notInSquad)
                                        .length <= 1
                                );
                            },
                            buffData: function () {
                                const id =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex +
                                    "-" +
                                    this.activeduration;
                                if (this.cache.has(id)) {
                                    return this.cache.get(id);
                                }
                                let res = {
                                    boonsData: this.getData(
                                        "boon",
                                        this.buffsStatContainer
                                    ),
                                    offsData: this.getData(
                                        "offBuff",
                                        this.buffsStatContainer
                                    ),
                                    offsData: this.getData(
                                        "offBuff",
                                        this.buffsStatContainer
                                    ),
                                    defsData: this.getData(
                                        "defBuff",
                                        this.buffsStatContainer
                                    ),
                                    supsData: this.getData(
                                        "supBuff",
                                        this.buffsStatContainer
                                    ),
                                };
                                this.cache.set(id, res);
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("buff-stats-player-component", {
                        props: ["playerindex"],
                        mixins: [buffComponent, encounterPhaseComponent],
                        template: `    <div>            <div :key="'activedurationplayer'" class="d-flex flex-row justify-content-center mt-1 mb-1">            <ul class="nav nav-pills d-flex flex-row justify-content-center scale85">                <li class="nav-item">                    <a class="nav-link" @click="activeduration = 0" data-original-title="Buffs upkeep applied by each player to the selected player based on currently selected phase."                       :class="{active: activeduration === 0}">Phase duration</a>                </li>                <li class="nav-item">                    <a class="nav-link" @click="activeduration = 1" data-original-title="Buffs upkeep applied by each player to the selected player based on currently selected phase. Removed dead and disconnected times."                        :class="{active: activeduration === 1 }">Phase active duration</a>                </li>            </ul>        </div>        <div class="mt-1 mb-1">            <buff-table-component :condition="false" :generation="true" :id="'boon-stats-player-table-' + player.id" :buffs="boons"                :playerdata="boonData" :sums="boonSums" :playerindex="-1" :hidecustom="false"></buff-table-component>        </div>    </div>`,
                        data: function () {
                            return {
                                activeduration: 0,
                                cacheBoon: new Map(),
                                cacheBoonSums: new Map(),
                            };
                        },
                        computed: {
                            player: function () {
                                return logData.players[this.playerindex];
                            },
                            boonData: function () {
                                const id =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex +
                                    "-" +
                                    this.activeduration;
                                if (this.cacheBoon.has(id)) {
                                    return this.cacheBoon.get(id);
                                }
                                const res = [];
                                const activeTimes =
                                    this.phase.playerActiveTimes;
                                const activeduration = this.activeduration;
                                const players = getActivePlayersForPhase(
                                    this.encounterPhase
                                );
                                for (let i = 0; i < players.length; i++) {
                                    if (
                                        !players[i] ||
                                        (activeduration &&
                                            activeTimes[i] < 1e-6)
                                    ) {
                                        continue;
                                    }
                                    res.push({
                                        player: players[i],
                                        data: activeduration
                                            ? this.buffsStatContainer
                                                  .boonActiveDictionaries[
                                                  this.playerindex
                                              ][i]
                                            : this.buffsStatContainer
                                                  .boonDictionaries[
                                                  this.playerindex
                                              ][i],
                                    });
                                }
                                this.cacheBoon.set(id, res);
                                return res;
                            },
                            boonSums: function () {
                                const id =
                                    this.phaseindex + "-" + this.activeduration;
                                if (this.cacheBoonSums.has(id)) {
                                    return this.cacheBoonSums.get(id);
                                }
                                const activeduration = this.activeduration;
                                const res = [];
                                const playerData = activeduration
                                    ? this.buffsStatContainer.boonActiveStats[
                                          this.playerindex
                                      ]
                                    : this.buffsStatContainer.boonStats[
                                          this.playerindex
                                      ];
                                const activeTimes =
                                    this.phase.playerActiveTimes;
                                if (
                                    activeduration &&
                                    activeTimes[this.playerindex] < 1e-6
                                ) {
                                    res.push({
                                        icon: this.player.icon,
                                        name: this.player.name,
                                        avg: 0,
                                        data: [],
                                    });
                                } else {
                                    res.push({
                                        icon: this.player.icon,
                                        name: this.player.name,
                                        avg: playerData.avg,
                                        data: playerData.data,
                                    });
                                }
                                this.cacheBoonSums.set(id, res);
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("buff-stats-target-component", {
                        props: ["playerindex", "targetindex"],
                        mixins: [buffComponent, encounterPhaseComponent],
                        template: `    <div>        <div>            <h3 class="text-center">Conditions</h3>            <buff-table-component :condition="true" :generation="true" :id="'condition-stats-target-table-' + target.id" :buffs="conditions"                :playerdata="condiData" :sums="condiSums" :playerindex="playerindex" :hidecustom="false"></buff-table-component>        </div>        <div v-show="hasBoons" class="mt-2">            <h3 class="text-center">Boons</h3>            <buff-table-component :condition="false" :generation="false" :id="'boon-stats-target-table-' + target.id" :buffs="boons"                :playerdata="boonData" :sums="[]" :hidecustom="false"></buff-table-component>        </div>    </div>`,
                        data: function () {
                            return {
                                cacheCondi: new Map(),
                                cacheCondiSums: new Map(),
                                cacheBoon: new Map(),
                            };
                        },
                        computed: {
                            target: function () {
                                return logData.targets[this.targetindex];
                            },
                            targetPhaseIndex: function () {
                                return this.phase.targets.indexOf(
                                    this.targetindex
                                );
                            },
                            hasBoons: function () {
                                return (
                                    this.buffsStatContainer.targetsBoonUptimes[
                                        this.targetPhaseIndex
                                    ].avg > 0
                                );
                            },
                            condiData: function () {
                                const cacheID =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex;
                                if (this.cacheCondi.has(cacheID)) {
                                    return this.cacheCondi.get(cacheID);
                                }
                                const players = getActivePlayersForPhase(
                                    this.encounterPhase
                                );
                                const res = [];
                                if (this.targetPhaseIndex === -1) {
                                    for (let i = 0; i < players.length; i++) {
                                        if (!players[i]) {
                                            continue;
                                        }
                                        res.push({
                                            player: players[i],
                                            data: {
                                                avg: 0.0,
                                                data: [],
                                            },
                                        });
                                    }
                                } else {
                                    for (let i = 0; i < players.length; i++) {
                                        if (!players[i]) {
                                            continue;
                                        }
                                        res.push({
                                            player: players[i],
                                            data: this.buffsStatContainer
                                                .targetsCondiStats[
                                                this.targetPhaseIndex
                                            ][i],
                                        });
                                    }
                                }
                                this.cacheCondi.set(cacheID, res);
                                return res;
                            },
                            condiSums: function () {
                                const cacheID = this.phaseindex;
                                if (this.cacheCondiSums.has(cacheID)) {
                                    return this.cacheCondiSums.get(cacheID);
                                }
                                const res = [];
                                if (this.targetPhaseIndex === -1) {
                                    res.push({
                                        icon: this.target.icon,
                                        name: this.target.name,
                                        avg: 0,
                                        data: [],
                                    });
                                } else {
                                    const targetData =
                                        this.buffsStatContainer
                                            .targetsCondiUptimes[
                                            this.targetPhaseIndex
                                        ];
                                    res.push({
                                        icon: this.target.icon,
                                        name: this.target.name,
                                        avg: targetData.avg,
                                        data: targetData.data,
                                    });
                                }
                                this.cacheCondiSums.set(cacheID, res);
                                return res;
                            },
                            boonData: function () {
                                const cacheID = this.phaseindex;
                                if (this.cacheBoon.has(cacheID)) {
                                    return this.cacheBoon.get(cacheID);
                                }
                                const res = [];
                                if (
                                    this.targetPhaseIndex === -1 ||
                                    !this.hasBoons
                                ) {
                                    res.push({
                                        player: this.target,
                                        data: {
                                            avg: 0.0,
                                            data: [],
                                        },
                                    });
                                } else {
                                    const targetData =
                                        this.phase.buffsStatContainer
                                            .targetsBoonUptimes[
                                            this.targetPhaseIndex
                                        ];
                                    res.push({
                                        player: this.target,
                                        data: targetData,
                                    });
                                }
                                this.cacheBoon.set(cacheID, res);
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("buff-table-component", {
                        props: [
                            "buffs",
                            "playerdata",
                            "generation",
                            "condition",
                            "sums",
                            "id",
                            "playerindex",
                            "hidecustom",
                        ],
                        template: `    <div v-if="buffs.length > 0">        <img v-if="generation" class="mb-1 icon" :src="UIIcons.QuestionMark"            :data-original-title="tooltipExpl" />        <div v-if="colPageCount > 0">            <table-scroll-component :min="0" :max="colPageCount" :width="'600px'" :height="'10px'" :transform="transFormString" :pagestructure="colStructure"></table-scroll-component>        </div>        <table class="table table-sm table-striped table-hover" cellspacing="0" width="100%" :id="tableid">            <thead>                <tr>                    <th class="sub-cell" :class="getHeaderClass('Sub')" @click="sortBy('Sub')">Sub</th>                    <th class="prof-cell" :class="getHeaderClass('Prof')" @click="sortBy('Prof')"></th>                    <th class="text-left" :class="getHeaderClass('Name')" @click="sortBy('Name')">Name</th>                    <th class="stat-cell" v-for="(buff, index) in buffs" :class="getHeaderClass('Data', index)" @click="sortBy('Data', index)"                        v-show="isInColPage(index)"                        :data-original-title="buff.name + (buff.description ? '<br> ' + buff.description : '')">                        <img :src="buff.icon" :alt="buff.name" class="icon icon-hover">                    </th>                </tr>            </thead>            <tbody>                <tr v-show="!row.player.notInSquad || !hidecustom" v-for="row in sortData(playerdata)" :class="{active: row.player.group && row.player.id === playerindex}">                    <td :class="getBodyClass('Sub')">{{ row.player.group ? row.player.group : '-' }}</td>                    <td :class="getBodyClass('Prof')" :data-original-title="row.player.profession ? row.player.profession : row.player.name">                        <img :src="row.player.icon"                            :alt="row.player.profession ? row.player.profession : row.player.name" class="icon">                        <span style="display:none">                            {{ row.player.profession ? row.player.profession : row.player.name}}                        </span>                    </td>                    <td class="text-left" :class="getBodyClass('Name')" :data-original-title="getAvgTooltip(row.data.avg)">                        {{ row.player.name }}                    </td>                    <td v-for=" (buff, index) in buffs"  :class="getBodyClass('Data', index)"                        v-show="isInColPage(index)"                        :data-original-title="getCellTooltip(buff, row.data.data[index])">                        {{ getCellValue(buff, row.data.data[index]) }}                    </td>                </tr>            </tbody>            <tfoot v-show="sums.length > 0">                <tr v-for="sum in sums">                    <td></td>                    <td v-if="sum.icon" :data-original-title="sum.name"><img :src="sum.icon" :alt="sum.name"                            class="icon"></td>                    <td v-else></td>                    <td class="text-left" :data-original-title="getAvgTooltip(sum.avg)">{{sum.name}}</td>                    <td v-for=" (buff, index) in buffs"                        v-show="isInColPage(index)"                        :data-original-title="getCellTooltip(buff, sum.data[index], !!sum.icon)">                        {{ getCellValue(buff, sum.data[index]) }}                    </td>                </tr>            </tfoot>        </table>    </div>`,
                        mixins: [
                            numberComponent,
                            sortedTableComponent,
                            colSliderComponent(maxBuffColumns),
                        ],
                        data: function () {
                            return {
                                sortdata: {
                                    order: "asc",
                                    index: -1,
                                    key: "Sub",
                                },
                            };
                        },
                        methods: {
                            sortBy: function (key, index) {
                                this.sortByBase(this.sortdata, key, index);
                            },
                            getHeaderClass: function (key, index) {
                                return this.getHeaderClassBase(
                                    this.sortdata,
                                    key,
                                    index
                                );
                            },
                            getBodyClass: function (key, index) {
                                const classes = this.getBodyClassBase(
                                    this.sortdata,
                                    key,
                                    index
                                );
                                return classes;
                            },
                            sortData: function (rows) {
                                const order =
                                    this.sortdata.order === "asc" ? 1 : -1;
                                switch (this.sortdata.key) {
                                    case "Sub":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    (x.player.group -
                                                        y.player.group) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Prof":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    this.sortByPlayerProfession(
                                                        x,
                                                        y
                                                    ) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Name":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Data":
                                        const index = this.sortdata.index;
                                        function getValue(rowValue) {
                                            const value =
                                                rowValue.data.data[index];
                                            if (value instanceof Array) {
                                                return value[0] ?? 0;
                                            }
                                            return value ?? 0;
                                        }
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    (getValue(x) -
                                                        getValue(y)) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    default:
                                        return null;
                                        break;
                                }
                                return rows;
                            },
                            getAvgTooltip: function (avg) {
                                if (avg) {
                                    return (
                                        "Average number of " +
                                        (this.condition
                                            ? "conditions: "
                                            : "boons: ") +
                                        avg
                                    );
                                }
                                return false;
                            },
                            getCellTooltip: function (buff, val, actorSum) {
                                if (val instanceof Array) {
                                    if (
                                        !actorSum &&
                                        this.generation &&
                                        val.filter((x) => x > 0).length > 0
                                    ) {
                                        let res = "";
                                        if (val[6] > 0) {
                                            res += res.length > 0 ? "<br>" : "";
                                            res +=
                                                val[6] +
                                                "% generated as presence";
                                        }
                                        if (val[1] !== val[0]) {
                                            res += res.length > 0 ? "<br>" : "";
                                            res +=
                                                (val[1] || 0) +
                                                (buff.stacking ? "" : "%") +
                                                " with overstack";
                                        }
                                        if (val[4] > 0) {
                                            res += res.length > 0 ? "<br>" : "";
                                            res +=
                                                val[4] +
                                                (buff.stacking ? "" : "%") +
                                                " by extension";
                                        }
                                        if (val[2] > 0) {
                                            res += res.length > 0 ? "<br>" : "";
                                            res +=
                                                val[2] +
                                                (buff.stacking ? "" : "%") +
                                                " wasted";
                                        }
                                        if (val[5] > 0) {
                                            res += res.length > 0 ? "<br>" : "";
                                            res +=
                                                val[5] +
                                                (buff.stacking ? "" : "%") +
                                                " extended";
                                        }
                                        if (val[3] > 0) {
                                            res += res.length > 0 ? "<br>" : "";
                                            res +=
                                                val[3] +
                                                (buff.stacking ? "" : "%") +
                                                " extended by unknown source";
                                        }
                                        return res.length > 0 ? res : false;
                                    } else if (buff.stacking && val[1] > 0) {
                                        return "Uptime: " + val[1] + "%";
                                    } else {
                                        return false;
                                    }
                                }
                                return false;
                            },
                            getCellValue: function (buff, val) {
                                let value = val;
                                let force = false;
                                if (val instanceof Array) {
                                    value = val[0];
                                    force =
                                        this.generation &&
                                        (val[1] > 0 ||
                                            val[2] > 0 ||
                                            val[3] > 0 ||
                                            val[4] > 0);
                                }
                                if (value > 0 || force) {
                                    return buff.stacking ? value : value + "%";
                                }
                                return "-";
                            },
                        },
                        computed: {
                            transFormString: function () {
                                const translateValue =
                                    mainComponentWidth * 0.34;
                                return `translate(${translateValue}px)`;
                            },
                            colPageCount: function () {
                                return (
                                    this.buffs.length -
                                    this.colStructure.perpage
                                );
                            },
                            tableid: function () {
                                return this.id;
                            },
                            UIIcons: function () {
                                return UIIcons;
                            },
                            tooltipExpl: function () {
                                return `<ul style='text-align:left;margin-block-end: 0.3em;'>
                        <li>The value shown in the row is "generation + extensions you are the source"</li>
                        <li>Generated as presence, only relevant for intensity stacking buffs, indicates the % of the time at least one stack generated by you was present</li>
                        <li>With overstack is "generation + extensions you are the source + stacks that couldn't make into the queue/stacks"</li>
                        <li>By extension is "extensions you are the source"</li>
                        <li>Waste is "stacks that were overriden/cleansed". If you have high waste values that could mean there is an issue with your composition as someone may be overriding your stacks non-stop.</li>
                        <li>Extended by unknown source is the extension value for which we were unable to find an src, not included in generation.</li>
                        <li>Extended is "extended by unknown source + extended by known source other than yourself". Not included in generation. This value is just here to indicate if you are a good seed.</li>
                        </ul>`;
                            },
                        },
                    });
                }
                {
                    function getDefaultBuffTableSubComponent() {
                        if (
                            validateStartPath(
                                "HealingStatistics/Buffs/Uptimes"
                            ) ||
                            validateStartPath("Statistics/Buffs/Uptimes")
                        ) {
                            const setting = EIUrlParams.get("startPage");
                            const compo = setting.split("/")[3];
                            switch (compo) {
                                case "Boons":
                                    return 0;
                                case "OffensiveBuffs":
                                    return hasOffBuffs() ? 1 : 0;
                                case "SupportBuffs":
                                    return hasSupBuffs() ? 2 : 0;
                                case "DefensiveBuffs":
                                    return hasDefBuffs() ? 3 : 0;
                                case "Conditions":
                                    return hasConditions() ? 5 : 0;
                                case "GearBuffs":
                                    return hasGearBuffs() ? 4 : 0;
                                case "Debuffs":
                                    return hasDebuffs() ? 7 : 0;
                                case "Nourishments":
                                    return hasNourishments() ? 8 : 0;
                                case "Enhancements":
                                    return hasEnhancements() ? 9 : 0;
                                case "Other Consumables":
                                    return hasOtherConsumables() ? 10 : 0;
                                case "Personal Buffs":
                                    return hasPersBuffs() ? 6 : 0;
                            }
                        }
                        return 0;
                    }
                    Vue.component("buff-tables-component", {
                        props: ["phaseindex", "playerindex"],
                        template: `    <div>        <ul class="nav nav-tabs">            <li>                <a class="nav-link" :class="{active: tab === 0}" @click="tab = 0">Boons</a>            </li>            <li v-if="hasOffBuffs">                <a class="nav-link" :class="{active: tab === 1}" @click="tab = 1">Offensive Buffs</a>            </li>            <li v-if="hasSupBuffs">                <a class="nav-link" :class="{active: tab === 2}" @click="tab = 2">Support Buffs</a>            </li>            <li v-if="hasDefBuffs">                <a class="nav-link" :class="{active: tab === 3}" @click="tab = 3">Defensive Buffs</a>            </li>            <li v-if="hasConditions">                <a class="nav-link" :class="{active: tab === 5}" @click="tab = 5">Conditions</a>            </li>            <li v-if="hasGearBuffs">                <a class="nav-link" :class="{active: tab === 4}" @click="tab = 4">Gear Buffs</a>            </li>            <li v-if="hasDebuffs">                <a class="nav-link" :class="{active: tab === 7}" @click="tab = 7">Debuffs</a>            </li>            <li v-if="hasNourishments">                <a class="nav-link" :class="{active: tab === 8}" @click="tab = 8">Nourishments</a>            </li>            <li v-if="hasEnhancements">                <a class="nav-link" :class="{active: tab === 9}" @click="tab = 9">Enhancements</a>            </li>            <li v-if="hasOtherConsumables">                <a class="nav-link" :class="{active: tab === 10}" @click="tab = 10">Other Consumables</a>            </li>            <li v-if="hasPersBuffs">                <a class="nav-link" :class="{active: tab === 6}" @click="tab = 6">Personal Buffs</a>            </li>        </ul>        <div :key="'activeduration'" class="d-flex flex-row justify-content-center mt-1 mb-1" v-if="showActiveDuration">            <ul class="nav nav-pills d-flex flex-row justify-content-center scale85">                <li class="nav-item">                    <a class="nav-link" @click="activeduration = 0" data-original-title="Buffs upkeep based on currently selected phase."                       :class="{active: activeduration === 0}">Phase duration</a>                </li>                <li class="nav-item">                    <a class="nav-link" @click="activeduration = 1" data-original-title="Buffs upkeep based on currently selected phase. Removed dead and disconnected times."                       :class="{active: activeduration === 1 }">Phase active duration</a>                </li>            </ul>        </div>        <keep-alive>            <buff-stats-component v-if="tab < 4" :key="'buffs'" :type="tab" :phaseindex="phaseindex"                :playerindex="playerindex" :activeduration="activeduration"></buff-stats-component>            <gear-buff-table-component v-if="tab === 4" :key="'gearbuffs'" :phaseindex="phaseindex"                :playerindex="playerindex" :activeduration="activeduration"></gear-buff-table-component>            <nourishement-buff-table-component v-if="tab === 8" :key="'nourishments'" :phaseindex="phaseindex"                :playerindex="playerindex" :activeduration="activeduration"></nourishement-buff-table-component>            <enhancement-buff-table-component v-if="tab === 9" :key="'enhancements'" :phaseindex="phaseindex"                :playerindex="playerindex" :activeduration="activeduration"></enhancement-buff-table-component>            <otherconsumable-buff-table-component v-if="tab === 10" :key="'otherconsumables'" :phaseindex="phaseindex"                :playerindex="playerindex" :activeduration="activeduration"></otherconsumable-buff-table-component>            <conditions-table-component v-if="tab === 5" :key="'conditions'" :phaseindex="phaseindex"                :playerindex="playerindex" :activeduration="activeduration"></conditions-table-component>            <debuff-table-component v-if="tab === 7" :key="'debuffs'" :phaseindex="phaseindex"                :playerindex="playerindex" :activeduration="activeduration"></debuff-table-component>            <personal-buff-table-component v-if="tab === 6" :key="'persbuffs'" :phaseindex="phaseindex"                :playerindex="playerindex" :activeduration="activeduration"></personal-buff-table-component>        </keep-alive>    </div>`,
                        data: function () {
                            return {
                                activeduration: 0,
                                tab: getDefaultBuffTableSubComponent(),
                            };
                        },
                        computed: {
                            showActiveDuration: function () {
                                return this.tab < 8 || this.tab > 10;
                            },
                            hasOffBuffs: function () {
                                return hasOffBuffs();
                            },
                            hasDefBuffs: function () {
                                return hasDefBuffs();
                            },
                            hasSupBuffs: function () {
                                return hasSupBuffs();
                            },
                            hasGearBuffs: function () {
                                return hasGearBuffs();
                            },
                            hasDebuffs: function () {
                                return hasDebuffs();
                            },
                            hasConditions: function () {
                                return hasConditions();
                            },
                            hasNourishments: function () {
                                return hasNourishments();
                            },
                            hasEnhancements: function () {
                                return hasEnhancements();
                            },
                            hasOtherConsumables: function () {
                                return hasOtherConsumables();
                            },
                            hasPersBuffs: function () {
                                return hasPersBuffs();
                            },
                        },
                    });
                }
                {
                    Vue.component("gear-buff-table-component", {
                        props: ["playerindex", "activeduration"],
                        mixins: [buffComponent, encounterPhaseComponent],
                        template: `    <div>        <buff-table-component :key="'gear-buff-stats-table'" :condition="false" :generation="false"            :id="'gear-buff-stats-table'" :buffs="gears" :playerdata="buffData" :sums="[]" :playerindex="playerindex" :hidecustom="false">        </buff-table-component>    </div>`,
                        data: function () {
                            return {
                                cache: new Map(),
                            };
                        },
                        computed: {
                            buffData: function () {
                                const id =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex;
                                if (this.cache.has(id)) {
                                    return this.cache.get(id);
                                }

                                const players = getActiveNonFakePlayersForPhase(
                                    this.encounterPhase
                                );
                                var getData = function (stats) {
                                    const uptimes = [];
                                    for (let i = 0; i < players.length; i++) {
                                        const player = players[i];
                                        if (!player) {
                                            continue;
                                        }
                                        uptimes.push({
                                            player: player,
                                            data: stats[i],
                                        });
                                    }
                                    return uptimes;
                                };
                                let res;
                                if (this.activeduration) {
                                    res = getData(
                                        this.buffsStatContainer
                                            .gearBuffActiveStats
                                    );
                                } else {
                                    res = getData(
                                        this.buffsStatContainer.gearBuffStats
                                    );
                                }
                                this.cache.set(id, res);
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("nourishement-buff-table-component", {
                        props: ["playerindex", "activeduration"],
                        mixins: [buffComponent, encounterPhaseComponent],
                        template: `    <div>        <buff-table-component :key="'nourishement-buff-stats-table'" :condition="false" :generation="false"            :id="'nourishement-buff-stats-table'" :buffs="nourishments" :playerdata="buffData" :sums="[]" :playerindex="playerindex" :hidecustom="false">        </buff-table-component>    </div>`,
                        data: function () {
                            return {
                                cache: new Map(),
                            };
                        },
                        computed: {
                            buffData: function () {
                                const id =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex;
                                if (this.cache.has(id)) {
                                    return this.cache.get(id);
                                }

                                const players = getActiveNonFakePlayersForPhase(
                                    this.encounterPhase
                                );
                                var getData = function (stats) {
                                    const uptimes = [];
                                    var i;
                                    for (i = 0; i < players.length; i++) {
                                        const player = players[i];
                                        if (!player) {
                                            continue;
                                        }
                                        uptimes.push({
                                            player: player,
                                            data: stats[i],
                                        });
                                    }
                                    return uptimes;
                                };
                                const res = getData(
                                    this.buffsStatContainer.nourishmentStats
                                );
                                this.cache.set(id, res);
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("enhancement-buff-table-component", {
                        props: ["playerindex", "activeduration"],
                        mixins: [buffComponent, encounterPhaseComponent],
                        template: `    <div>        <buff-table-component :key="'enhancement-buff-stats-table'" :condition="false" :generation="false"            :id="'enhancement-buff-stats-table'" :buffs="enhancements" :playerdata="buffData" :sums="[]" :playerindex="playerindex" :hidecustom="false">        </buff-table-component>    </div>`,
                        data: function () {
                            return {
                                cache: new Map(),
                            };
                        },
                        computed: {
                            buffData: function () {
                                const id =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex;
                                if (this.cache.has(id)) {
                                    return this.cache.get(id);
                                }

                                const players = getActiveNonFakePlayersForPhase(
                                    this.encounterPhase
                                );
                                var getData = function (stats) {
                                    const uptimes = [];
                                    for (let i = 0; i < players.length; i++) {
                                        const player = players[i];
                                        if (!player) {
                                            continue;
                                        }
                                        uptimes.push({
                                            player: player,
                                            data: stats[i],
                                        });
                                    }
                                    return uptimes;
                                };
                                const res = getData(
                                    this.buffsStatContainer.enhancementStats
                                );
                                this.cache.set(id, res);
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("otherconsumable-buff-table-component", {
                        props: ["playerindex", "activeduration"],
                        mixins: [buffComponent, encounterPhaseComponent],
                        template: `    <div>        <buff-table-component :key="'otherconsumable-buff-stats-table'" :condition="false" :generation="false"            :id="'otherconsumable-buff-stats-table'" :buffs="otherConsumables" :playerdata="buffData" :sums="[]" :playerindex="playerindex" :hidecustom="false">        </buff-table-component>    </div>`,
                        data: function () {
                            return {
                                cache: new Map(),
                            };
                        },
                        computed: {
                            buffData: function () {
                                const id =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex;
                                if (this.cache.has(id)) {
                                    return this.cache.get(id);
                                }

                                const players = getActiveNonFakePlayersForPhase(
                                    this.encounterPhase
                                );
                                var getData = function (stats) {
                                    const uptimes = [];
                                    for (let i = 0; i < players.length; i++) {
                                        const player = players[i];
                                        if (!player) {
                                            continue;
                                        }
                                        uptimes.push({
                                            player: player,
                                            data: stats[i],
                                        });
                                    }
                                    return uptimes;
                                };
                                const res = getData(
                                    this.buffsStatContainer.otherConsumableStats
                                );
                                this.cache.set(id, res);
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("debuff-table-component", {
                        props: ["playerindex", "activeduration"],
                        mixins: [buffComponent, encounterPhaseComponent],
                        template: `    <div>        <buff-table-component :key="'debuff-stats-table'" :condition="false" :generation="false"            :id="'debuff-stats-table'" :buffs="debuffs" :playerdata="buffData" :sums="[]" :playerindex="playerindex" :hidecustom="false">        </buff-table-component>    </div>`,
                        data: function () {
                            return {
                                cache: new Map(),
                            };
                        },
                        computed: {
                            buffData: function () {
                                const id =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex +
                                    "-" +
                                    this.activeduration;
                                if (this.cache.has(id)) {
                                    return this.cache.get(id);
                                }

                                const players = getActiveNonFakePlayersForPhase(
                                    this.encounterPhase
                                );
                                var getData = function (stats) {
                                    const uptimes = [];
                                    for (let i = 0; i < players.length; i++) {
                                        const player = players[i];
                                        if (!player) {
                                            continue;
                                        }
                                        uptimes.push({
                                            player: player,
                                            data: stats[i],
                                        });
                                    }
                                    return uptimes;
                                };
                                let res;
                                if (this.activeduration) {
                                    res = getData(
                                        this.buffsStatContainer
                                            .debuffActiveStats
                                    );
                                } else {
                                    res = getData(
                                        this.buffsStatContainer.debuffStats
                                    );
                                }
                                this.cache.set(id, res);
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("conditions-table-component", {
                        props: ["playerindex", "activeduration"],
                        mixins: [buffComponent, encounterPhaseComponent],
                        template: `    <div>        <buff-table-component :key="'conditions-stats-table'" :condition="true" :generation="false"            :id="'conditions-stats-table'" :buffs="conditions" :playerdata="buffData[0]" :sums="buffData[1]" :playerindex="playerindex" :hidecustom="false">        </buff-table-component>    </div>`,
                        data: function () {
                            return {
                                cache: new Map(),
                            };
                        },
                        computed: {
                            buffData: function () {
                                const id =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex +
                                    "-" +
                                    this.activeduration;
                                if (this.cache.has(id)) {
                                    return this.cache.get(id);
                                }
                                const activeduration = this.activeduration;
                                const activeTimes =
                                    this.phase.playerActiveTimes;

                                const players = getActiveNonFakePlayersForPhase(
                                    this.encounterPhase
                                );
                                var getData = function (uptimesStats) {
                                    var uptimes = [];
                                    var avg = [],
                                        groupeAvg = [],
                                        totalAvg = [];
                                    var groupCount = [],
                                        totalCount = 0;
                                    var groupConditionAvg = [],
                                        totalConditionAvg = 0;
                                    for (let i = 0; i < players.length; i++) {
                                        const player = players[i];
                                        if (!player) {
                                            continue;
                                        }
                                        uptimes.push({
                                            player: player,
                                            data: uptimesStats[i],
                                        });

                                        if (
                                            activeduration &&
                                            activeTimes[i] < 1e-6
                                        ) {
                                            continue;
                                        }
                                        if (player.notInSquad) {
                                            continue;
                                        }
                                        const playerWeight = activeduration
                                            ? activeTimes[i]
                                            : 1;
                                        if (!groupeAvg[player.group]) {
                                            groupeAvg[player.group] = [];
                                            groupCount[player.group] = 0;
                                            groupConditionAvg[player.group] = 0;
                                        }
                                        totalCount += playerWeight;
                                        totalConditionAvg +=
                                            playerWeight * uptimesStats[i].avg;
                                        groupConditionAvg[player.group] +=
                                            playerWeight * uptimesStats[i].avg;
                                        groupCount[player.group] +=
                                            playerWeight;
                                        for (
                                            let j = 0;
                                            j < uptimesStats[i].data.length;
                                            j++
                                        ) {
                                            totalAvg[j] =
                                                (totalAvg[j] || 0) +
                                                playerWeight *
                                                    (uptimesStats[i].data[
                                                        j
                                                    ][0] || 0);
                                            groupeAvg[player.group][j] =
                                                (groupeAvg[player.group][j] ||
                                                    0) +
                                                playerWeight *
                                                    (uptimesStats[i].data[
                                                        j
                                                    ][0] || 0);
                                        }
                                    }
                                    for (let i = 0; i < groupeAvg.length; i++) {
                                        if (groupeAvg[i]) {
                                            for (
                                                let k = 0;
                                                k < groupeAvg[i].length;
                                                k++
                                            ) {
                                                groupeAvg[i][k] =
                                                    Math.round(
                                                        (1000 *
                                                            groupeAvg[i][k]) /
                                                            groupCount[i]
                                                    ) / 1000;
                                            }
                                            avg.push({
                                                name: "Group " + i,
                                                data: groupeAvg[i],
                                                avg:
                                                    Math.round(
                                                        (1000 *
                                                            groupConditionAvg[
                                                                i
                                                            ]) /
                                                            groupCount[i]
                                                    ) / 1000,
                                            });
                                        }
                                    }
                                    for (let k = 0; k < totalAvg.length; k++) {
                                        totalAvg[k] =
                                            Math.round(
                                                (1000 * totalAvg[k]) /
                                                    totalCount
                                            ) / 1000;
                                    }
                                    avg.push({
                                        name: "Total",
                                        data: totalAvg,
                                        avg:
                                            Math.round(
                                                (1000 * totalConditionAvg) /
                                                    totalCount
                                            ) / 1000,
                                    });
                                    return [uptimes, avg];
                                };
                                let res;
                                if (this.activeduration) {
                                    res = getData(
                                        this.buffsStatContainer
                                            .conditionsActiveStats
                                    );
                                } else {
                                    res = getData(
                                        this.buffsStatContainer.conditionsStats
                                    );
                                }
                                this.cache.set(id, res);
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("personal-buff-table-component", {
                        props: ["playerindex", "activeduration"],
                        mixins: [buffComponent, encounterPhaseComponent],
                        template: `    <div>        <ul class="nav nav-pills d-flex flex-row justify-content-center mt-1 mb-1 scale85">            <li v-for="base in bases" class="nav-item">                <a class="nav-link" @click="persBuffMode = base" :class="{active: persBuffMode === base}">{{ base }}</a>            </li>        </ul>        <div v-for="(spec, id) in orderedSpecs" class="mt-1 mb-1">            <div v-show="specToBase[spec.name] === persBuffMode">                <h3 class="text-center">{{ spec.name }}</h3>                <buff-table-component :target="null" :condition="false" :generation="false" :id="'persbuffs-stats-table' + '_' + spec.name"                    :buffs="persBuffs[id]" :playerdata="data[id]" :sums="[]" :playerindex="playerindex" :hidecustom="false"></buff-table-component>            </div>        </div>    </div>`,
                        data: function () {
                            return {
                                bases: [],
                                persBuffMode: "Warrior",
                                cache: new Map(),
                                specToBase: SpecToBase,
                            };
                        },
                        computed: {
                            data: function () {
                                // Ordered specs depend on encounter phase
                                const id =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex;
                                if (this.cache.has(id)) {
                                    return this.cache.get(id);
                                }
                                const res = [];
                                for (
                                    let i = 0;
                                    i < this.orderedSpecs.length;
                                    i++
                                ) {
                                    const spec = this.orderedSpecs[i];
                                    const dataBySpec = [];
                                    for (let j = 0; j < spec.ids.length; j++) {
                                        dataBySpec.push({
                                            player: logData.players[
                                                spec.ids[j]
                                            ],
                                            data: this.activeduration
                                                ? this.buffsStatContainer
                                                      .persBuffActiveStats[
                                                      spec.ids[j]
                                                  ]
                                                : this.buffsStatContainer
                                                      .persBuffStats[
                                                      spec.ids[j]
                                                  ],
                                        });
                                    }
                                    res.push(dataBySpec);
                                }
                                this.cache.set(id, res);
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("buff-volume-stats-component", {
                        props: ["type", "playerindex", "activeduration"],
                        mixins: [buffComponent, encounterPhaseComponent],
                        template: `    <div>        <div class="d-flex flex-row justify-content-center mt-1 mb-1">            <ul class="nav nav-pills d-flex flex-row justify-content-center scale85">                <li class="nav-item">                    <a class="nav-link" @click="buffMode = 0" :class="{active: buffMode === 0}"                       data-original-title="Incoming buffs applications.">Incoming</a>                </li>                <li class="nav-item">                    <a class="nav-link" @click="buffMode = 1" :class="{active: buffMode === 1 }"                       data-original-title="Outgoing buffs applications to yourself.">Outgoing Self</a>                </li>                <li v-if="!singlePlayer" class="nav-item">                    <a class="nav-link" @click="buffMode = 2" :class="{active: buffMode === 2 }"                        data-original-title="Outgoing buffs applications to your group members. Self excluded.">Outgoing Group</a>                </li>                <li v-if="!singleGroup" class="nav-item">                    <a class="nav-link" @click="buffMode = 3" :class="{active: buffMode === 3 }"                        data-original-title="Outgoing buffs applications to your non-group members. Self excluded.">Outgoing Off-Group</a>                </li>                <li v-if="!singleGroup" class="nav-item">                    <a class="nav-link" @click="buffMode = 4" :class="{active: buffMode === 4 }"                        data-original-title="Outgoing buffs applications to your squad. Self excluded.">Outgoing Squad</a>                </li>            </ul>        </div>        <keep-alive>            <buff-volume-table-component v-if="type === 0" :key="'boon-volume-stats-table'"                 :outgoing="buffMode > 0" :id="'boon-volume-stats-table'" :buffs="boons"                :playerdata="buffData.boonsData[buffMode]" :sums="buffMode === 0 ? buffData.boonsData[5] : []"                :playerindex="playerindex" :hidecustom="buffMode > 1">            </buff-volume-table-component>            <buff-volume-table-component v-if="type === 1" :key="'offensivebuff-volume-stats-table'"                 :outgoing="buffMode > 0" :id="'offensivebuff-volume-stats-table'" :buffs="offs"                :playerdata="buffData.offsData[buffMode]" :sums="buffMode === 0 ? buffData.offsData[5] : []"                :playerindex="playerindex" :hidecustom="buffMode > 1">            </buff-volume-table-component>            <buff-volume-table-component v-if="type === 2" :key="'supportbuff-volume-stats-table'"                 :outgoing="buffMode > 0" :id="'supportbuff-volume-stats-table'" :buffs="sups"                :playerdata="buffData.supsData[buffMode]" :sums="buffMode === 0 ? buffData.supsData[5] : []"                :playerindex="playerindex" :hidecustom="buffMode > 1">            </buff-volume-table-component>            <buff-volume-table-component v-if="type === 3" :key="'defensivebuff-volume-stats-table'"                 :outgoing="buffMode > 0" :id="'defensivebuff-volume-stats-table'" :buffs="defs"                :playerdata="buffData.defsData[buffMode]" :sums="buffMode === 0 ? buffData.defsData[5] : []"                :playerindex="playerindex" :hidecustom="buffMode > 1">            </buff-volume-table-component>        </keep-alive>    </div>`,
                        data: function () {
                            return {
                                buffMode: 0,
                                cache: new Map(),
                            };
                        },
                        methods: {
                            getData: function (name, container) {
                                const activeduration = !!this.activeduration;
                                const activeTimes =
                                    this.phase.playerActiveTimes;
                                //
                                const activeString = activeduration
                                    ? "Active"
                                    : "";
                                const incomingStats =
                                    container[
                                        name + "Volume" + activeString + "Stats"
                                    ];
                                const outgoingSelfStats =
                                    container[
                                        name +
                                            "OutgoingVolume" +
                                            activeString +
                                            "SelfStats"
                                    ];
                                const outgoingGroupStats =
                                    container[
                                        name +
                                            "OutgoingVolume" +
                                            activeString +
                                            "GroupStats"
                                    ];
                                const outgoingOGroupStats =
                                    container[
                                        name +
                                            "OutgoingVolume" +
                                            activeString +
                                            "OGroupStats"
                                    ];
                                const outgoingSquadStats =
                                    container[
                                        name +
                                            "OutgoingVolume" +
                                            activeString +
                                            "SquadStats"
                                    ];
                                //
                                let incoming = [];
                                let outSelf = [];
                                let outGroup = [];
                                let outOffGroup = [];
                                let outSquad = [];
                                let avg = [];
                                let groupAvg = [];
                                let totalAvg = [];
                                let groupCount = [];
                                let totalCount = 0;
                                //
                                const players = getActiveNonFakePlayersForPhase(
                                    this.encounterPhase
                                );
                                for (var i = 0; i < players.length; i++) {
                                    const player = players[i];
                                    if (!player) {
                                        continue;
                                    }
                                    incoming.push({
                                        player: player,
                                        data: incomingStats[i],
                                    });
                                    outSelf.push({
                                        player: player,
                                        data: outgoingSelfStats[i],
                                    });
                                    outGroup.push({
                                        player: player,
                                        data: outgoingGroupStats[i],
                                    });
                                    outOffGroup.push({
                                        player: player,
                                        data: outgoingOGroupStats[i],
                                    });
                                    outSquad.push({
                                        player: player,
                                        data: outgoingSquadStats[i],
                                    });
                                    if (
                                        activeduration &&
                                        activeTimes[i] < 1e-6
                                    ) {
                                        continue;
                                    }
                                    var playerWeight = activeduration
                                        ? activeTimes[i]
                                        : 1;
                                    if (player.notInSquad) {
                                        continue;
                                    }
                                    if (!groupAvg[player.group]) {
                                        groupAvg[player.group] = [];
                                        groupCount[player.group] = 0;
                                    }
                                    totalCount += playerWeight;
                                    groupCount[player.group] += playerWeight;
                                    for (
                                        let j = 0;
                                        j < incomingStats[i].data.length;
                                        j++
                                    ) {
                                        totalAvg[j] =
                                            (totalAvg[j] || 0) +
                                            playerWeight *
                                                (incomingStats[i].data[j][0] ||
                                                    0);
                                        groupAvg[player.group][j] =
                                            (groupAvg[player.group][j] || 0) +
                                            playerWeight *
                                                (incomingStats[i].data[j][0] ||
                                                    0);
                                    }
                                }
                                for (let i = 0; i < groupAvg.length; i++) {
                                    if (groupAvg[i]) {
                                        for (
                                            let k = 0;
                                            k < groupAvg[i].length;
                                            k++
                                        ) {
                                            groupAvg[i][k] =
                                                Math.round(
                                                    (1000 * groupAvg[i][k]) /
                                                        groupCount[i]
                                                ) / 1000;
                                        }
                                        avg.push({
                                            name: "Group " + i,
                                            data: groupAvg[i],
                                        });
                                    }
                                }
                                for (let k = 0; k < totalAvg.length; k++) {
                                    totalAvg[k] =
                                        Math.round(
                                            (1000 * totalAvg[k]) / totalCount
                                        ) / 1000;
                                }
                                avg.push({
                                    name: "Total",
                                    data: totalAvg,
                                });
                                return [
                                    incoming,
                                    outSelf,
                                    outGroup,
                                    outOffGroup,
                                    outSquad,
                                    avg,
                                ];
                            },
                        },
                        computed: {
                            singleGroup: function () {
                                return logData.singleGroup;
                            },
                            singlePlayer: function () {
                                return (
                                    logData.players.filter((x) => !x.notInSquad)
                                        .length <= 1
                                );
                            },
                            buffData: function () {
                                const id =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex +
                                    "-" +
                                    this.activeduration;
                                if (this.cache.has(id)) {
                                    return this.cache.get(id);
                                }
                                let res = {
                                    boonsData: this.getData(
                                        "boon",
                                        this.buffVolumesStatContainer
                                    ),
                                    offsData: this.getData(
                                        "offBuff",
                                        this.buffVolumesStatContainer
                                    ),
                                    offsData: this.getData(
                                        "offBuff",
                                        this.buffVolumesStatContainer
                                    ),
                                    defsData: this.getData(
                                        "defBuff",
                                        this.buffVolumesStatContainer
                                    ),
                                    supsData: this.getData(
                                        "supBuff",
                                        this.buffVolumesStatContainer
                                    ),
                                };
                                this.cache.set(id, res);
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("buff-volume-stats-player-component", {
                        props: ["playerindex"],
                        mixins: [buffComponent, encounterPhaseComponent],
                        template: `    <div>            <div :key="'activedurationplayer'" class="d-flex flex-row justify-content-center mt-1 mb-1">            <ul class="nav nav-pills d-flex flex-row justify-content-center scale85">                <li class="nav-item">                    <a class="nav-link" @click="activeduration = 0" data-original-title="Buffs volumes applied by each player to the selected player based on currently selected phase."                       :class="{active: activeduration === 0}">Phase duration</a>                </li>                <li class="nav-item">                    <a class="nav-link" @click="activeduration = 1" data-original-title="Buffs volumes applied by each player to the selected player based on currently selected phase. Removed dead and disconnected times."                        :class="{active: activeduration === 1 }">Phase active duration</a>                </li>            </ul>        </div>        <div class="mt-1 mb-1">            <buff-volume-table-component  :outgoing="true" :id="'boon-volume-stats-player-table-' + player.id" :buffs="boons"                :playerdata="boonData" :sums="boonSums" :playerindex="-1" :hidecustom="false"></buff-volume-table-component>        </div>    </div>`,
                        data: function () {
                            return {
                                activeduration: 0,
                                cacheBoon: new Map(),
                                cacheBoonSums: new Map(),
                            };
                        },
                        computed: {
                            player: function () {
                                return logData.players[this.playerindex];
                            },
                            boonData: function () {
                                const id =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex +
                                    "-" +
                                    this.activeduration;
                                if (this.cacheBoon.has(id)) {
                                    return this.cacheBoon.get(id);
                                }
                                const res = [];
                                const activeTimes =
                                    this.phase.playerActiveTimes;
                                const activeduration = this.activeduration;
                                const players = getActiveNonFakePlayersForPhase(
                                    this.encounterPhase
                                );
                                for (let i = 0; i < players.length; i++) {
                                    if (
                                        !players[i] ||
                                        (activeduration &&
                                            activeTimes[i] < 1e-6)
                                    ) {
                                        continue;
                                    }
                                    res.push({
                                        player: players[i],
                                        data: activeduration
                                            ? this.buffVolumesStatContainer
                                                  .boonVolumeActiveDictionaries[
                                                  this.playerindex
                                              ][i]
                                            : this.buffVolumesStatContainer
                                                  .boonVolumeDictionaries[
                                                  this.playerindex
                                              ][i],
                                    });
                                }
                                this.cacheBoon.set(id, res);
                                return res;
                            },
                            boonSums: function () {
                                const id =
                                    this.phaseindex + "-" + this.activeduration;
                                if (this.cacheBoonSums.has(id)) {
                                    return this.cacheBoonSums.get(id);
                                }
                                const activeduration = this.activeduration;
                                const res = [];
                                const playerData = activeduration
                                    ? this.buffVolumesStatContainer
                                          .boonVolumeActiveStats[
                                          this.playerindex
                                      ]
                                    : this.buffVolumesStatContainer
                                          .boonVolumeStats[this.playerindex];
                                const activeTimes =
                                    this.phase.playerActiveTimes;
                                if (
                                    activeduration &&
                                    activeTimes[this.playerindex] < 1e-6
                                ) {
                                    res.push({
                                        icon: this.player.icon,
                                        name: this.player.name,
                                        avg: 0,
                                        data: [],
                                    });
                                } else {
                                    res.push({
                                        icon: this.player.icon,
                                        name: this.player.name,
                                        avg: playerData.avg,
                                        data: playerData.data,
                                    });
                                }
                                this.cacheBoonSums.set(id, res);
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("buff-volume-stats-target-component", {
                        props: ["playerindex", "targetindex"],
                        mixins: [buffComponent, encounterPhaseComponent],
                        template: `    <div>        <div>            <h3 class="text-center">Conditions</h3>            <buff-volume-table-component :outgoing="true" :id="'condition-volume-stats-target-table-' + target.id" :buffs="conditions"                :playerdata="condiData" :sums="condiSums" :playerindex="playerindex" :hidecustom="false"></buff-volume-table-component>        </div>        <div v-show="hasBoons" class="mt-2">            <h3 class="text-center">Boons</h3>            <buff-volume-table-component  :outgoing="false" :id="'boon-volume-stats-target-table-' + target.id" :buffs="boons"                :playerdata="boonData" :sums="[]" :hidecustom="false"></buff-volume-table-component>        </div>    </div>`,
                        data: function () {
                            return {
                                cacheCondi: new Map(),
                                cacheCondiSums: new Map(),
                                cacheBoon: new Map(),
                            };
                        },
                        computed: {
                            target: function () {
                                return logData.targets[this.targetindex];
                            },
                            targetPhaseIndex: function () {
                                return this.phase.targets.indexOf(
                                    this.targetindex
                                );
                            },
                            hasBoons: function () {
                                return (
                                    this.buffVolumesStatContainer
                                        .targetsBoonIncomingVolumeTotals[
                                        this.targetPhaseIndex
                                    ].avg > 0
                                );
                            },
                            condiData: function () {
                                const cacheID =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex;
                                if (this.cacheCondi.has(cacheID)) {
                                    return this.cacheCondi.get(cacheID);
                                }
                                const players = getActivePlayersForPhase(
                                    this.encounterPhase
                                );
                                const res = [];
                                if (this.targetPhaseIndex === -1) {
                                    for (let i = 0; i < players.length; i++) {
                                        if (!players[i]) {
                                            continue;
                                        }
                                        res.push({
                                            player: players[i],
                                            data: {
                                                avg: 0.0,
                                                data: [],
                                            },
                                        });
                                    }
                                } else {
                                    for (let i = 0; i < players.length; i++) {
                                        if (!players[i]) {
                                            continue;
                                        }
                                        res.push({
                                            player: players[i],
                                            data: this.buffVolumesStatContainer
                                                .targetsCondiVolumeStats[
                                                this.targetPhaseIndex
                                            ][i],
                                        });
                                    }
                                }
                                this.cacheCondi.set(cacheID, res);
                                return res;
                            },
                            condiSums: function () {
                                const cacheID = this.phaseindex;
                                if (this.cacheCondiSums.has(cacheID)) {
                                    return this.cacheCondiSums.get(cacheID);
                                }
                                const res = [];
                                if (this.targetPhaseIndex === -1) {
                                    res.push({
                                        icon: this.target.icon,
                                        name: this.target.name,
                                        avg: 0,
                                        data: [],
                                    });
                                } else {
                                    const targetData =
                                        this.buffVolumesStatContainer
                                            .targetsCondiIncomingVolumeTotals[
                                            this.targetPhaseIndex
                                        ];
                                    res.push({
                                        icon: this.target.icon,
                                        name: this.target.name,
                                        avg: targetData.avg,
                                        data: targetData.data,
                                    });
                                }
                                this.cacheCondiSums.set(cacheID, res);
                                return res;
                            },
                            boonData: function () {
                                const cacheID = this.phaseindex;
                                if (this.cacheBoon.has(cacheID)) {
                                    return this.cacheBoon.get(cacheID);
                                }
                                const res = [];
                                if (
                                    this.targetPhaseIndex === -1 ||
                                    !this.hasBoons
                                ) {
                                    res.push({
                                        player: this.target,
                                        data: {
                                            avg: 0.0,
                                            data: [],
                                        },
                                    });
                                } else {
                                    const targetData =
                                        this.buffsStatContainer
                                            .targetsBoonIncomingVolumeTotals[
                                            this.targetPhaseIndex
                                        ];
                                    res.push({
                                        player: this.target,
                                        data: targetData,
                                    });
                                }
                                this.cacheBoon.set(cacheID, res);
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("buff-volume-table-component", {
                        props: [
                            "buffs",
                            "playerdata",
                            "outgoing",
                            "sums",
                            "id",
                            "playerindex",
                            "hidecustom",
                        ],
                        template: `    <div v-if="buffs.length > 0">        <img v-if="outgoing" class="mb-1 icon" :src="UIIcons.QuestionMark"            :data-original-title="tooltipExplOut" />        <img v-if="!outgoing" class="mb-1 icon" :src="UIIcons.QuestionMark"            :data-original-title="tooltipExplInc" />        <div v-if="colPageCount > 0">            <table-scroll-component :min="0" :max="colPageCount" :width="'600px'" :height="'10px'" :transform="transFormString" :pagestructure="colStructure"></table-scroll-component>        </div>        <table class="table table-sm table-striped table-hover" cellspacing="0" width="100%" :id="tableid">            <thead>                <tr>                    <th class="sub-cell" :class="getHeaderClass('Sub')" @click="sortBy('Sub')">Sub</th>                    <th class="prof-cell" :class="getHeaderClass('Prof')" @click="sortBy('Prof')"></th>                    <th class="text-left" :class="getHeaderClass('Name')" @click="sortBy('Name')">Name</th>                    <th class="stat-cell" v-for="(buff, index) in buffs" :class="getHeaderClass('Data', index)" @click="sortBy('Data', index)"                        v-show="isInColPage(index)"                        :data-original-title="buff.name + (buff.description ? '<br> ' + buff.description : '')">                        <img :src="buff.icon" :alt="buff.name" class="icon icon-hover">                    </th>                </tr>            </thead>            <tbody>                <tr v-show="!row.player.notInSquad || !hidecustom" v-for="row in sortData(playerdata)" :class="{active: row.player.group && row.player.id === playerindex}">                    <td :class="getBodyClass('Sub')">{{ row.player.group ? row.player.group : '-' }}</td>                    <td :class="getBodyClass('Prof')" :data-original-title="row.player.profession ? row.player.profession : row.player.name">                        <img :src="row.player.icon"                            :alt="row.player.profession ? row.player.profession : row.player.name" class="icon">                        <span style="display:none">                            {{ row.player.profession ? row.player.profession : row.player.name}}                        </span>                    </td>                    <td class="text-left" :class="getBodyClass('Name')">                        {{ row.player.name }}                    </td>                    <td v-for=" (buff, index) in buffs"  :class="getBodyClass('Data', index)"                        v-show="isInColPage(index)"                        :data-original-title="getCellTooltip(buff, row.data.data[index])">                        {{ getCellValue(buff, row.data.data[index]) }}                    </td>                </tr>            </tbody>            <tfoot v-show="sums.length > 0">                <tr v-for="sum in sums">                    <td></td>                    <td v-if="sum.icon" :data-original-title="sum.name"><img :src="sum.icon" :alt="sum.name"                            class="icon"></td>                    <td v-else></td>                    <td class="text-left">{{sum.name}}</td>                    <td v-for=" (buff, index) in buffs"                        v-show="isInColPage(index)"                        :data-original-title="getCellTooltip(buff, sum.data[index], !!sum.icon)">                        {{ getCellValue(buff, sum.data[index]) }}                    </td>                </tr>            </tfoot>        </table>    </div>`,
                        mixins: [
                            numberComponent,
                            sortedTableComponent,
                            colSliderComponent(maxBuffColumns),
                        ],
                        data: function () {
                            return {
                                sortdata: {
                                    order: "asc",
                                    index: -1,
                                    key: "Sub",
                                },
                            };
                        },
                        methods: {
                            sortBy: function (key, index) {
                                this.sortByBase(this.sortdata, key, index);
                            },
                            getHeaderClass: function (key, index) {
                                return this.getHeaderClassBase(
                                    this.sortdata,
                                    key,
                                    index
                                );
                            },
                            getBodyClass: function (key, index) {
                                var classes = this.getBodyClassBase(
                                    this.sortdata,
                                    key,
                                    index
                                );
                                return classes;
                            },
                            sortData: function (rows) {
                                var order =
                                    this.sortdata.order === "asc" ? 1 : -1;
                                switch (this.sortdata.key) {
                                    case "Sub":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    (x.player.group -
                                                        y.player.group) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Prof":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    this.sortByPlayerProfession(
                                                        x,
                                                        y
                                                    ) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Name":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Data":
                                        var index = this.sortdata.index;
                                        function getValue(rowValue) {
                                            var value =
                                                rowValue.data.data[index];
                                            if (value instanceof Array) {
                                                return value[0] ?? 0;
                                            }
                                            return value ?? 0;
                                        }
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    (getValue(x) -
                                                        getValue(y)) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    default:
                                        return null;
                                        break;
                                }
                                return rows;
                            },
                            getCellTooltip: function (buff, val, actorSum) {
                                if (val instanceof Array) {
                                    if (!actorSum) {
                                        if (this.outgoing && val[1] > 0) {
                                            var res = "";
                                            if (val[1] > 0) {
                                                res +=
                                                    res.length > 0
                                                        ? "<br>"
                                                        : "";
                                                res +=
                                                    val[1] +
                                                    (buff.stacking ? "" : "%") +
                                                    " by extension";
                                            }
                                            return res.length > 0 ? res : false;
                                        } else if (
                                            !this.outgoing &&
                                            (val[1] > 0 || val[2] > 0)
                                        ) {
                                            var res = "";
                                            if (val[1] > 0) {
                                                res +=
                                                    res.length > 0
                                                        ? "<br>"
                                                        : "";
                                                res +=
                                                    val[1] +
                                                    (buff.stacking ? "" : "%") +
                                                    " by extension";
                                            }
                                            if (val[2] > 0) {
                                                res +=
                                                    res.length > 0
                                                        ? "<br>"
                                                        : "";
                                                res +=
                                                    val[2] +
                                                    (buff.stacking ? "" : "%") +
                                                    " by unknown extension";
                                            }
                                            return res.length > 0 ? res : false;
                                        }
                                    } else {
                                        return false;
                                    }
                                }
                                return false;
                            },
                            getCellValue: function (buff, val) {
                                var value = val;
                                var force = false;
                                if (val instanceof Array) {
                                    value = val[0];
                                    force =
                                        this.outgoing &&
                                        (val[1] > 0 || val[2] > 0);
                                }
                                if (value > 0 || force) {
                                    return buff.stacking ? value : value + "%";
                                }
                                return "-";
                            },
                        },
                        computed: {
                            transFormString: function () {
                                const translateValue =
                                    mainComponentWidth * 0.34;
                                return `translate(${translateValue}px)`;
                            },
                            colPageCount: function () {
                                return (
                                    this.buffs.length -
                                    this.colStructure.perpage
                                );
                            },
                            tableid: function () {
                                return this.id;
                            },
                            UIIcons: function () {
                                return UIIcons;
                            },
                            tooltipExplInc: function () {
                                return `<ul style='text-align:left;margin-block-end: 0.3em;'>
                        <li>Buffs applied for an infinite duration are ignored</li>
                        <li>The value shown in the row is "incoming + incoming by extensions"</li>
                        <li>By extension is "incoming by extensions". This includes unknown extensions.</li>
                        <li>By unknown extension is "incoming by unknown extensions"</li>
                        </ul>`;
                            },
                            tooltipExplOut: function () {
                                return `<ul style='text-align:left;margin-block-end: 0.3em;'>
                        <li>Buffs applied for an infinite duration are ignored</li>
                        <li>The value shown in the row is "outgoing + extensions you are the source"</li>
                        <li>By extension is "extensions you are the source"</li>
                        </ul>`;
                            },
                        },
                    });
                }
                {
                    function getDefaultBuffVolumeTableSubComponent() {
                        if (
                            validateStartPath(
                                "HealingStatistics/Buffs/Volumes"
                            ) ||
                            validateStartPath("Statistics/Buffs/Volumes")
                        ) {
                            const setting = EIUrlParams.get("startPage");
                            const compo = setting.split("/")[2];
                            switch (compo) {
                                case "Boons":
                                    return 0;
                                case "OffensiveBuffs":
                                    return hasOffBuffs() ? 1 : 0;
                                case "SupportBuffs":
                                    return hasSupBuffs() ? 2 : 0;
                                case "DefensiveBuffs":
                                    return hasDefBuffs() ? 3 : 0;
                                case "Conditions":
                                    return hasConditions() ? 5 : 0;
                                case "GearBuffs":
                                    return hasGearBuffs() ? 4 : 0;
                                case "Debuffs":
                                    return hasDebuffs() ? 7 : 0;
                                case "Personal Buffs":
                                    return hasPersBuffs() ? 6 : 0;
                            }
                        }
                        return 0;
                    }
                    Vue.component("buff-volume-tables-component", {
                        props: ["phaseindex", "playerindex"],
                        template: `    <div>        <ul class="nav nav-tabs">            <li>                <a class="nav-link" :class="{active: tab === 0}" @click="tab = 0">Boons</a>            </li>            <li v-if="hasOffBuffs">                <a class="nav-link" :class="{active: tab === 1}" @click="tab = 1">Offensive Buffs</a>            </li>            <li v-if="hasSupBuffs">                <a class="nav-link" :class="{active: tab === 2}" @click="tab = 2">Support Buffs</a>            </li>            <li v-if="hasDefBuffs">                <a class="nav-link" :class="{active: tab === 3}" @click="tab = 3">Defensive Buffs</a>            </li>            <li v-if="hasConditions">                <a class="nav-link" :class="{active: tab === 5}" @click="tab = 5">Conditions</a>            </li>            <li v-if="hasGearBuffs">                <a class="nav-link" :class="{active: tab === 4}" @click="tab = 4">Gear Buffs</a>            </li>            <li v-if="hasDebuffs">                <a class="nav-link" :class="{active: tab === 7}" @click="tab = 7">Debuffs</a>            </li>            <li v-if="hasPersBuffs">                <a class="nav-link" :class="{active: tab === 6}" @click="tab = 6">Personal Buffs</a>            </li>        </ul>        <div :key="'activeduration'" class="d-flex flex-row justify-content-center mt-1 mb-1" v-if="showActiveDuration">            <ul class="nav nav-pills d-flex flex-row justify-content-center scale85">                <li class="nav-item">                    <a class="nav-link" @click="activeduration = 0" data-original-title="Buffs volumes applications based on currently selected phase."                       :class="{active: activeduration === 0}">Phase duration</a>                </li>                <li class="nav-item">                    <a class="nav-link" @click="activeduration = 1" data-original-title="Buffs volumes applications based on currently selected phase. Removed dead and disconnected times."                        :class="{active: activeduration === 1 }">Phase active duration</a>                </li>            </ul>        </div>        <keep-alive>            <buff-volume-stats-component v-if="tab < 4" :key="'buffs-volume'" :type="tab" :phaseindex="phaseindex"                :playerindex="playerindex" :activeduration="activeduration"></buff-volume-stats-component>            <gear-buff-volume-table-component v-if="tab === 4" :key="'gearbuffs-volume'" :phaseindex="phaseindex"                :playerindex="playerindex" :activeduration="activeduration"></gear-buff-volume-table-component>            <conditions-volume-table-component v-if="tab === 5" :key="'conditions-volume'" :phaseindex="phaseindex"                :playerindex="playerindex" :activeduration="activeduration"></conditions-volume-table-component>            <debuff-volume-table-component v-if="tab === 7" :key="'debuffs-volume'" :phaseindex="phaseindex"                :playerindex="playerindex" :activeduration="activeduration"></debuff-volume-table-component>            <personal-buff-volume-table-component v-if="tab === 6" :key="'persbuffs-volume'" :phaseindex="phaseindex"                :playerindex="playerindex" :activeduration="activeduration"></personal-buff-volume-table-component>        </keep-alive>    </div>`,
                        data: function () {
                            return {
                                activeduration: 0,
                                tab: getDefaultBuffVolumeTableSubComponent(),
                            };
                        },
                        computed: {
                            showActiveDuration: function () {
                                return this.tab < 8 || this.tab > 10;
                            },
                            hasOffBuffs: function () {
                                return hasOffBuffs();
                            },
                            hasDefBuffs: function () {
                                return hasDefBuffs();
                            },
                            hasSupBuffs: function () {
                                return hasSupBuffs();
                            },
                            hasGearBuffs: function () {
                                return hasGearBuffs();
                            },
                            hasDebuffs: function () {
                                return hasDebuffs();
                            },
                            hasConditions: function () {
                                return hasConditions();
                            },
                            hasPersBuffs: function () {
                                return hasPersBuffs();
                            },
                        },
                    });
                }
                {
                    Vue.component("gear-buff-volume-table-component", {
                        props: ["playerindex", "activeduration"],
                        mixins: [buffComponent, encounterPhaseComponent],
                        template: `    <div>        <buff-volume-table-component :key="'gear-buff-volume-stats-table'"  :outgoing="false"            :id="'gear-buff-volume-stats-table'" :buffs="gears" :playerdata="buffData" :sums="[]" :playerindex="playerindex" :hidecustom="false">        </buff-volume-table-component>    </div>`,
                        data: function () {
                            return {
                                cache: new Map(),
                            };
                        },
                        computed: {
                            buffData: function () {
                                const cacheID =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex;
                                if (this.cache.has(cacheID)) {
                                    return this.cache.get(cacheID);
                                }

                                const players = getActiveNonFakePlayersForPhase(
                                    this.encounterPhase
                                );
                                var getData = function (stats) {
                                    var uptimes = [];
                                    var i;
                                    for (i = 0; i < players.length; i++) {
                                        var player = players[i];
                                        if (!player) {
                                            continue;
                                        }
                                        uptimes.push({
                                            player: player,
                                            data: stats[i],
                                        });
                                    }
                                    return uptimes;
                                };
                                var res;
                                if (this.activeduration) {
                                    res = getData(
                                        this.buffVolumesStatContainer
                                            .gearBuffVolumeActiveStats
                                    );
                                } else {
                                    res = getData(
                                        this.buffVolumesStatContainer
                                            .gearBuffVolumeStats
                                    );
                                }
                                this.cache.set(cacheID, res);
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("debuff-volume-table-component", {
                        props: ["playerindex", "activeduration"],
                        mixins: [buffComponent, encounterPhaseComponent],
                        template: `    <div>        <buff-volume-table-component :key="'debuff-volume-stats-table'"  :outgoing="false"            :id="'debuff-volume-stats-table'" :buffs="debuffs" :playerdata="buffData" :sums="[]" :playerindex="playerindex" :hidecustom="false">        </buff-volume-table-component>    </div>`,
                        data: function () {
                            return {
                                cache: new Map(),
                            };
                        },
                        computed: {
                            buffData: function () {
                                const cacheID =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex +
                                    "-" +
                                    this.activeduration;
                                if (this.cache.has(cacheID)) {
                                    return this.cache.get(cacheID);
                                }

                                const players = getActiveNonFakePlayersForPhase(
                                    this.encounterPhase
                                );
                                var getData = function (stats) {
                                    var uptimes = [];
                                    var i;
                                    for (i = 0; i < players.length; i++) {
                                        var player = players[i];
                                        if (!player) {
                                            continue;
                                        }
                                        uptimes.push({
                                            player: player,
                                            data: stats[i],
                                        });
                                    }
                                    return uptimes;
                                };
                                var res;
                                if (this.activeduration) {
                                    res = getData(
                                        this.buffVolumesStatContainer
                                            .debuffVolumeActiveStats
                                    );
                                } else {
                                    res = getData(
                                        this.buffVolumesStatContainer
                                            .debuffVolumeStats
                                    );
                                }
                                this.cache.set(cacheID, res);
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("conditions-volume-table-component", {
                        props: ["playerindex", "activeduration"],
                        mixins: [buffComponent, encounterPhaseComponent],
                        template: `    <div>        <buff-volume-table-component :key="'conditions-volume-stats-table'" :outgoing="false"            :id="'conditions-volume-stats-table'" :buffs="conditions" :playerdata="buffData[0]" :sums="buffData[1]" :playerindex="playerindex" :hidecustom="false">        </buff-volume-table-component>    </div>`,
                        data: function () {
                            return {
                                cache: new Map(),
                            };
                        },
                        computed: {
                            buffData: function () {
                                const cacheID =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex +
                                    "-" +
                                    this.activeduration;
                                if (this.cache.has(cacheID)) {
                                    return this.cache.get(cacheID);
                                }
                                var activeduration = this.activeduration;
                                var activeTimes = this.phase.playerActiveTimes;

                                const players = getActiveNonFakePlayersForPhase(
                                    this.encounterPhase
                                );
                                var getData = function (uptimesStats) {
                                    var uptimes = [];
                                    var avg = [],
                                        groupeAvg = [],
                                        totalAvg = [];
                                    var groupCount = [],
                                        totalCount = 0;
                                    for (var i = 0; i < players.length; i++) {
                                        var player = players[i];
                                        if (!player) {
                                            continue;
                                        }
                                        uptimes.push({
                                            player: player,
                                            data: uptimesStats[i],
                                        });

                                        if (
                                            activeduration &&
                                            activeTimes[i] < 1e-6
                                        ) {
                                            continue;
                                        }
                                        if (player.notInSquad) {
                                            continue;
                                        }
                                        var playerWeight = activeduration
                                            ? activeTimes[i]
                                            : 1;
                                        if (!groupeAvg[player.group]) {
                                            groupeAvg[player.group] = [];
                                            groupCount[player.group] = 0;
                                        }
                                        totalCount += playerWeight;
                                        groupCount[player.group] +=
                                            playerWeight;
                                        for (
                                            var j = 0;
                                            j < uptimesStats[i].data.length;
                                            j++
                                        ) {
                                            totalAvg[j] =
                                                (totalAvg[j] || 0) +
                                                playerWeight *
                                                    (uptimesStats[i].data[
                                                        j
                                                    ][0] || 0);
                                            groupeAvg[player.group][j] =
                                                (groupeAvg[player.group][j] ||
                                                    0) +
                                                playerWeight *
                                                    (uptimesStats[i].data[
                                                        j
                                                    ][0] || 0);
                                        }
                                    }
                                    for (var i = 0; i < groupeAvg.length; i++) {
                                        if (groupeAvg[i]) {
                                            for (
                                                var k = 0;
                                                k < groupeAvg[i].length;
                                                k++
                                            ) {
                                                groupeAvg[i][k] =
                                                    Math.round(
                                                        (1000 *
                                                            groupeAvg[i][k]) /
                                                            groupCount[i]
                                                    ) / 1000;
                                            }
                                            avg.push({
                                                name: "Group " + i,
                                                data: groupeAvg[i],
                                            });
                                        }
                                    }
                                    for (var k = 0; k < totalAvg.length; k++) {
                                        totalAvg[k] =
                                            Math.round(
                                                (1000 * totalAvg[k]) /
                                                    totalCount
                                            ) / 1000;
                                    }
                                    avg.push({
                                        name: "Total",
                                        data: totalAvg,
                                    });
                                    return [uptimes, avg];
                                };
                                var res;
                                if (this.activeduration) {
                                    res = getData(
                                        this.buffVolumesStatContainer
                                            .conditionsVolumeActiveStats
                                    );
                                } else {
                                    res = getData(
                                        this.buffVolumesStatContainer
                                            .conditionsVolumeStats
                                    );
                                }
                                this.cache.set(cacheID, res);
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("personal-buff-volume-table-component", {
                        props: ["playerindex", "activeduration"],
                        mixins: [buffComponent, encounterPhaseComponent],
                        template: `    <div>        <ul class="nav nav-pills d-flex flex-row justify-content-center mt-1 mb-1 scale85">            <li v-for="base in bases" class="nav-item">                <a class="nav-link" @click="persBuffMode = base" :class="{active: persBuffMode === base}">{{ base }}</a>            </li>        </ul>        <div v-for="(spec, id) in orderedSpecs" class="mt-1 mb-1">            <div v-show="specToBase[spec.name] === persBuffMode">                <h3 class="text-center">{{ spec.name }}</h3>                <buff-volume-table-component :target="null"  :outgoing="false" :id="'persbuffs-volume-stats-table' + '_' + spec.name"                    :buffs="persBuffs[id]" :playerdata="data[id]" :sums="[]" :playerindex="playerindex" :hidecustom="false"></buff-table-component>            </div>        </div>    </div>`,
                        data: function () {
                            return {
                                bases: [],
                                persBuffMode: "Warrior",
                                cache: new Map(),
                                specToBase: SpecToBase,
                            };
                        },
                        computed: {
                            data: function () {
                                // Ordered specs depend on encounter phase
                                const id =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex;
                                if (this.cache.has(id)) {
                                    return this.cache.get(id);
                                }
                                var res = [];
                                for (
                                    var i = 0;
                                    i < this.orderedSpecs.length;
                                    i++
                                ) {
                                    var spec = this.orderedSpecs[i];
                                    var dataBySpec = [];
                                    for (var j = 0; j < spec.ids.length; j++) {
                                        dataBySpec.push({
                                            player: logData.players[
                                                spec.ids[j]
                                            ],
                                            data: this.activeduration
                                                ? this.buffVolumesStatContainer
                                                      .persBuffVolumeActiveStats[
                                                      spec.ids[j]
                                                  ]
                                                : this.buffVolumesStatContainer
                                                      .persBuffVolumeStats[
                                                      spec.ids[j]
                                                  ],
                                        });
                                    }
                                    res.push(dataBySpec);
                                }
                                this.cache.set(id, res);
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("dmgdist-player-component", {
                        props: ["playerindex", "phaseindex", "activetargets"],
                        template: `    <div>        <div v-if="player.minions.length > 0">            <ul class="nav nav-tabs">                <li>                    <a class="nav-link" :class="{active: distmode === -1}" @click="distmode = -1">{{player.name}}</a>                </li>                <li v-for="(minion, mindex) in player.minions">                    <a class="nav-link" :class="{active: distmode === mindex}"                        @click="distmode = mindex">{{minion.name}}</a>                </li>            </ul>        </div>        <div v-if="!targetless" class="d-flex flex-row justify-content-center mt-1 mb-1">            <ul class="nav nav-pills scale85">                <li class="nav-item">                    <a class="nav-link" @click="targetmode = 1" data-original-title="Against selected target(s)."                       :class="{active: targetmode}">Target</a>                </li>                <li class="nav-item">                    <a class="nav-link" @click="targetmode = 0" data-original-title="Against all enemies."                       :class="{active: !targetmode }">All</a>                </li>            </ul>        </div>        <damagedist-table-component :dmgdist="targetmode === 0 ? dmgdist : dmgdisttarget"            :tableid="'dmgdist-' + playerindex" :actorindex="playerindex" :minionindex="distmode"             :player="true" :istarget="targetmode === 1"            :phaseindex="phaseindex"></damagedist-table-component>    </div>`,
                        data: function () {
                            return {
                                distmode: -1,
                                targetless: logData.targetless,
                                targetmode: logData.targetless ? 0 : 1,
                                cacheTarget: new Map(),
                            };
                        },
                        computed: {
                            phase: function () {
                                return logData.phases[this.phaseindex];
                            },
                            player: function () {
                                return logData.players[this.playerindex];
                            },
                            dmgdist: function () {
                                if (this.distmode === -1) {
                                    return this.player.details.dmgDistributions[
                                        this.phaseindex
                                    ];
                                }
                                return this.player.details.minions[
                                    this.distmode
                                ].dmgDistributions[this.phaseindex];
                            },
                            dmgdisttarget: function () {
                                let cacheID =
                                    this.phaseindex + "-" + this.distmode + "-";
                                cacheID += getTargetCacheID(this.activetargets);
                                if (this.cacheTarget.has(cacheID)) {
                                    return this.cacheTarget.get(cacheID);
                                }
                                const dist = {
                                    contributedDamage: 0,
                                    contributedDownContribution: 0,
                                    contributedBreakbarDamage: 0,
                                    contributedShieldDamage: 0,
                                    totalDamage: 0,
                                    totalBreakbarDamage: 0,
                                    totalCasting: 0,
                                    distribution: [],
                                };
                                const rows = new Map();
                                for (
                                    let i = 0;
                                    i < this.activetargets.length;
                                    i++
                                ) {
                                    const targetid = this.activetargets[i];
                                    const targetDist =
                                        this.distmode === -1
                                            ? this.player.details
                                                  .dmgDistributionsTargets[
                                                  this.phaseindex
                                              ][targetid]
                                            : this.player.details.minions[
                                                  this.distmode
                                              ].dmgDistributionsTargets[
                                                  this.phaseindex
                                              ][targetid];
                                    dist.contributedDamage +=
                                        targetDist.contributedDamage;
                                    dist.contributedBreakbarDamage +=
                                        targetDist.contributedBreakbarDamage;
                                    dist.contributedDownContribution +=
                                        targetDist.contributedDownContribution;
                                    dist.totalDamage += targetDist.totalDamage;
                                    dist.totalBreakbarDamage +=
                                        targetDist.totalBreakbarDamage;
                                    dist.contributedShieldDamage +=
                                        targetDist.contributedShieldDamage;
                                    dist.totalCasting = targetDist.totalCasting;
                                    const distribution =
                                        targetDist.distribution;
                                    for (
                                        let k = 0;
                                        k < distribution.length;
                                        k++
                                    ) {
                                        const targetDistribution =
                                            distribution[k];
                                        if (rows.has(targetDistribution[1])) {
                                            const row = rows.get(
                                                targetDistribution[1]
                                            );
                                            row[2] += targetDistribution[2];
                                            if (targetDistribution[14]) {
                                                if (row[14] === 0) {
                                                    row[3] =
                                                        targetDistribution[3];
                                                    row[4] =
                                                        targetDistribution[4];
                                                } else {
                                                    row[3] = Math.min(
                                                        targetDistribution[3],
                                                        row[3]
                                                    );
                                                    row[4] = Math.max(
                                                        targetDistribution[4],
                                                        row[4]
                                                    );
                                                }
                                            }
                                            row[6] += targetDistribution[6];
                                            row[7] += targetDistribution[7];
                                            row[8] += targetDistribution[8];
                                            row[9] += targetDistribution[9];
                                            // skip 10
                                            // skip 11
                                            row[12] += targetDistribution[12];
                                            row[13] += targetDistribution[13];
                                            row[14] += targetDistribution[14];
                                            // skip 15
                                            row[16] += targetDistribution[16];
                                            row[17] += targetDistribution[17];
                                            // skip 18
                                            // skip 19
                                            // skip 20
                                            // skip 21
                                            row[22] += targetDistribution[22];
                                        } else {
                                            rows.set(
                                                targetDistribution[1],
                                                targetDistribution.slice(0)
                                            );
                                        }
                                    }
                                }
                                rows.forEach(function (value, key, map) {
                                    dist.distribution.push(value);
                                });
                                dist.contributedDamage = Math.max(
                                    dist.contributedDamage,
                                    0
                                );
                                dist.totalDamage = Math.max(
                                    dist.totalDamage,
                                    0
                                );
                                dist.contributedShieldDamage = Math.max(
                                    dist.contributedShieldDamage,
                                    0
                                );
                                dist.totalCasting = Math.max(
                                    dist.totalCasting,
                                    0
                                );
                                this.cacheTarget.set(cacheID, dist);
                                return dist;
                            },
                        },
                    });
                }
                {
                    Vue.component("dmgtakendist-player-component", {
                        props: ["playerindex", "phaseindex"],
                        template: `    <div>        <div v-if="player.minions.length > 0">            <ul class="nav nav-tabs">                <li>                    <a class="nav-link" :class="{active: distmode === -1}" @click="distmode = -1">{{player.name}}</a>                </li>                <li v-for="(minion, mindex) in player.minions">                    <a class="nav-link" :class="{active: distmode === mindex}"                        @click="distmode = mindex">{{minion.name}}</a>                </li>            </ul>        </div>        <damagedist-table-component :dmgdist="dmgtaken" :tableid="'dmgtakendist-' + playerindex"             :actorindex="-1" :minionindex="distmode" :istarget="false" :player="true"            :phaseindex="phaseindex">        </damagedist-table-component>    </div>`,
                        data: function () {
                            return {
                                distmode: -1,
                            };
                        },
                        computed: {
                            player: function () {
                                return logData.players[this.playerindex];
                            },
                            dmgtaken: function () {
                                if (this.distmode === -1) {
                                    return this.player.details
                                        .dmgDistributionsTaken[this.phaseindex];
                                }
                                return this.player.details.minions[
                                    this.distmode
                                ].dmgDistributionsTaken[this.phaseindex];
                            },
                        },
                    });
                }
                {
                    Vue.component("damagedist-table-component", {
                        props: [
                            "dmgdist",
                            "tableid",
                            "actorindex",
                            "minionindex",
                            "istarget",
                            "phaseindex",
                            "player",
                        ],
                        template: `    <div>        <div v-if="actor !== null" class="mb-1 mt-1">            <div v-if="isminion">                <p style="display: table-row;">                    {{actor.name}} did {{round3(100*dmgdist.contributedDamage/dmgdist.totalDamage)}}% of its master's total                    {{istarget ? 'Target' :''}} damage ({{dmgdist.contributedDamage}})                </p>                <p v-if="hasBreakbarDamage && dmgdist.contributedBreakbarDamage > 0" style="display: table-row;">                    {{actor.name}} did {{round3(100*dmgdist.contributedBreakbarDamage/dmgdist.totalBreakbarDamage)}}% of its master's total                    {{istarget ? 'Target' :''}} breakbar damage ({{round1(dmgdist.contributedBreakbarDamage)}})                </p>            </div>            <div v-else>                <p style="display: table-row;">                    {{actor.name}} did {{round3(100*dmgdist.contributedDamage/dmgdist.totalDamage)}}% of their total {{istarget ?                        'Target' :''}} damage ({{dmgdist.contributedDamage}})                </p>                              <p v-if="hasBreakbarDamage && dmgdist.contributedBreakbarDamage > 0" style="display: table-row;">                    {{actor.name}} did {{round3(100*dmgdist.contributedBreakbarDamage/dmgdist.totalBreakbarDamage)}}% of their total                    {{istarget ? 'Target' :''}} breakbar damage ({{round1(dmgdist.contributedBreakbarDamage)}})                </p>            </div>        </div>        <table class="table table-sm table-striped table-hover" cellspacing="0" width="100%" :id="tableid">            <thead>                <tr>                    <th class="text-left" :class="getHeaderClass('Skill')" @click="sortBy('Skill')">                        Skill                    </th>                    <th class="damage-dist-cell"                          :class="getHeaderClass('Data', 0)" @click="sortBy('Data', 0, x => getDamage(x))"                        data-original-title="% Damage">                        % <img :src="UIIcons.Damage" alt="Damage"                        class="icon">                    </th>                    <th class="damage-dist-cell"                         :class="getHeaderClass('Data', 1)" @click="sortBy('Data', 1, x => getDamage(x))"                        data-original-title="Damage">                        <img :src="UIIcons.Damage" alt="Damage"                            class="icon icon-hover">                    </th>                    <th class="damage-dist-cell"                         :class="getHeaderClass('Data', 2)" @click="sortBy('Data', 2, x => getBarrierDamage(x))"                        data-original-title="Damage against barrier. Not necessarily included in total damage">                        <img :src="UIIcons.Barrier"                            alt="Barrier Damage" class="icon icon-hover">                    </th>                    <th class="damage-dist-cell"                         :class="getHeaderClass('Data', 3)" @click="sortBy('Data', 3, x => getMinDamage(x))"                            data-original-title="Minimum Damage">                        Min <img :src="UIIcons.Damage" alt="Damage"                        class="icon">                    </th>                    <th class="damage-dist-cell"                         :class="getHeaderClass('Data', 4)" @click="sortBy('Data', 4, x => round(getDamage(x)/getConnectedHits(x)))"                         data-original-title="Average Damage">                        Avg <img :src="UIIcons.Damage" alt="Damage"                        class="icon">                    </th>                    <th class="damage-dist-cell"                         :class="getHeaderClass('Data', 5)" @click="sortBy('Data', 5, x => getMaxDamage(x))"                            data-original-title="Maximum Damage">                        Max <img :src="UIIcons.Damage" alt="Damage"                        class="icon">                    </th>                    <th class="damage-dist-cell" v-if="wvw && actor !== null" :class="getHeaderClass('Data', 22)" @click="sortBy('Data', 22, x => getDownContribution(x))"                        data-original-title="Down Contribution">                         <img :src="UIIcons.Damage" alt="Damage"                            class="icon">                        /                        <img :src="UIIcons.DownedEnemy" alt="Down"                            class="icon">                    </th>                     <th v-if="hasBreakbarDamage" class="damage-dist-cell"                          :class="getHeaderClass('Data', 6)" @click="sortBy('Data', 6, x => getBreakbarDamage(x))"                            data-original-title="% Breakbar Damage">                        % <img :src="UIIcons.Breakbar" alt="Breakbar"                        class="icon">                    </th>                    <th v-if="hasBreakbarDamage" class="damage-dist-cell"                          :class="getHeaderClass('Data', 7)" @click="sortBy('Data', 7, x => getBreakbarDamage(x))"                         data-original-title="Breakbar Damage">                        <img :src="UIIcons.Breakbar" alt="Breakbar"                        class="icon icon-hover">                    </th>                    <th class="damage-dist-cell"                         :class="getHeaderClass('Data', 8)" @click="sortBy('Data', 8, x => getCast(x))"                        v-if="actor !== null"                        data-original-title="Cast">                                  #                        <img :src="UIIcons.Activation" alt="Cast"                            class="icon">                    </th>                    <th class="damage-dist-cell"                        :class="getHeaderClass('Data', 9)" @click="sortBy('Data', 9, x => getConnectedHits(x))"                        data-original-title="Hits">                                 <img :src="UIIcons.NumberOfTargets"                            alt="Hits" class="icon icon-hover">                    </th>                    <th class="damage-dist-cell" v-if="actor !== null"                         :class="getHeaderClass('Data', 10)" @click="sortBy('Data', 10, x => round2(getConnectedHits(x)/getCast(x)))"                        data-original-title="Hits per Cast">                            <img :src="UIIcons.NumberOfTargets"                            alt="Hits" class="icon">                            /                            #                            <img :src="UIIcons.Activation" alt="Cast"                            class="icon">                    </th>                    <th class="damage-dist-cell" v-if="actor !== null"                         :class="getHeaderClass('Data', 11)" @click="sortBy('Data', 11, x => round2(getDamage(x)/(0.001 * getCastDuration(x))))"                        data-original-title="Damage divided by time spent in animation">                        <img :src="UIIcons.Damage" alt="Damage"                            class="icon">                        /                        <img :src="UIIcons.Activation" alt="Activation Time"                            class="icon">                    </th>                            <th class="damage-dist-cell" v-if="actor !== null"                         :class="getHeaderClass('Data', 19)" @click="sortBy('Data', 19, x => round3(0.001 * getCastDurationNoInterrupt(x) / getCastNoInterrupt(x) ))"                         data-original-title="Average Casting Time (No interrupted skills) <br>Min and Max on hover"">                        Avg <img :src="UIIcons.Activation" alt="Activation Time"                        class="icon">                    </th>                    <th class="damage-dist-cell"                         :class="getHeaderClass('Data', 12)" @click="sortBy('Data', 12, x => round2(getCriticalHits(x)*100/getConnectedHits(x)))"                        data-original-title="Percent time hits critical">                        <img :src="UIIcons.Crit" alt="Crits"                            class="icon icon-hover">                    </th>                    <th class="damage-dist-cell"                         :class="getHeaderClass('Data', 13)" @click="sortBy('Data', 13, x => round2(getFlankingHits(x)*100/getConnectedHits(x)))"                        data-original-title="Percent time hits while flanking">                        <img :src="UIIcons.Flank" alt="Flank"                            class="icon icon-hover">                    </th>                    <th class="damage-dist-cell"                         :class="getHeaderClass('Data', 14)" @click="sortBy('Data', 14, x => round2(getGlancingHits(x)*100/getConnectedHits(x)))"                        data-original-title="Percent time hits while glancing">                        <img :src="UIIcons.Glance" alt="Glance"                            class="icon icon-hover">                    </th>                    <th class="damage-dist-cell"                         :class="getHeaderClass('Data', 15)" @click="sortBy('Data', 15, x => round2(100 * getAgainstMovingHits(x)/getConnectedHits(x)))"                        data-original-title="Damage against moving">                        <img :src="UIIcons.AgainstMoving"                            alt="Against Moving" class="icon icon-hover">                    </th>                    <th class="damage-dist-cell" v-if="actor !== null"                         :class="getHeaderClass('Data', 16)" @click="sortBy('Data', 16, x => getCastTimeWasted(x))"                        data-original-title="Time wasted interupting skill casts">                        <img :src="UIIcons.TimeWasted" alt="Wasted"                            class="icon icon-hover">                    </th>                    <th class="damage-dist-cell" v-if="actor !== null"                         :class="getHeaderClass('Data', 17)" @click="sortBy('Data', 17, x => getCastTimeSaved(x))"                        data-original-title="Time saved(in seconds) interupting skill casts">                        <img :src="UIIcons.TimeSaved" alt="Saved"                            class="icon icon-hover">                    </th>                 </tr>            </thead>            <tbody>                <tr v-for="row in sortData(dmgdist.distribution)" :class="{condi: getSkill(row).condi}">                    <td class="text-left" :class="getBodyClass('Skill')"                        :data-original-title="getSkill(row).name + ' ' + getSkillID(row)">                        <img :src="getSkill(row).icon" class="icon">                        {{getSkill(row).name.length > maxSkillCharacters ? (getSkill(row).name.slice(0, maxSkillCharacters)) + '...': getSkill(row).name}}                    </td>                    <td :class="getBodyClass('Data', 0)">                        {{ round3(100*getDamage(row)/dmgdist.contributedDamage) }}%                    </td>                    <td :class="getBodyClass('Data', 1)"                        :data-original-title="round2(getDamage(row)/phase.durationS) +' dps'">                        {{ getDamage(row) }}                    </td>                    <td :class="getBodyClass('Data', 2)"                        :data-original-title="round2(getBarrierDamage(row)/phase.durationS) +' dps'">                        {{ getBarrierDamage(row) }}                    </td>                    <td :class="getBodyClass('Data', 3)">                        {{ getMinDamage(row) }}                    </td>                    <td :class="getBodyClass('Data', 4)">                        {{ round(getDamage(row)/getConnectedHits(row)) }}                    </td>                    <td :class="getBodyClass('Data', 5)">                        {{ getMaxDamage(row) }}                    </td>                    <td v-if="wvw && actor !== null" :class="getBodyClass('Data', 22)">                        {{getDownContribution(row) < 0 ? 'N/A' : getDownContribution(row)}}                    </td>                    <td :class="getBodyClass('Data', 6)" v-if="hasBreakbarDamage">                        {{ round3(100*getBreakbarDamage(row)/dmgdist.contributedBreakbarDamage) }}%                    </td>                    <td :class="getBodyClass('Data', 7)" v-if="hasBreakbarDamage"                         :data-original-title="round2(getBreakbarDamage(row)/phase.durationS) +' bps'">                        {{ getBreakbarDamage(row) }}                    </td>                    <td :class="getCastBodyClass('Data', 8, row)" v-if="actor !== null">                        {{ (!getSkill(row).condi && getCast(row)) ? getCast(row) : ''}}                    </td>                    <td :class="getBodyClass('Data', 9)"                         :data-original-title="(getAllHits(row) - getConnectedHits(row)) + ' hit(s) not connected'">                        {{ getConnectedHits(row) }}                    </td>                    <td :class="getHitsPerCastBodyClass('Data', 10, row)" v-if="actor !== null"                         :data-original-title=" (!getSkill(row).condi && getAllHits(row) && getCast(row)) ? (showInequality(row) ? '<= ' : '') + round2(getAllHits(row)/getCast(row)) + ' with missed hits' : false" >                        {{(!getSkill(row).condi && getConnectedHits(row) && getCast(row)) ? round2(getConnectedHits(row)/getCast(row)) : ''}}                    </td>                    <td :class="getBodyClass('Data', 11)" v-if="actor !== null">                        {{(!getSkill(row).condi && getConnectedHits(row) && getCastDuration(row)) ? round2(getDamage(row)/(0.001 * getCastDuration(row))) : ''}}                    </td>                        <td :class="getBodyClass('Data', 19)" v-if="actor !== null"                        :data-original-title=" getCastDurationNoInterrupt(row) ?                             (                                'Min: ' + round3(0.001 * getMinCastingTimeNoInterrupt(row)) + 's' +                                 '<br> Max: '+ round3(0.001 * getMaxCastingTimeNoInterrupt(row)) + 's'                            )                             :                             null" >                        {{ getCastDurationNoInterrupt(row) ? round3(0.001 * getCastDurationNoInterrupt(row) / getCastNoInterrupt(row) ) + 's'  : ' '}}                    </td>                    <td :class="getBodyClass('Data', 12)"                         :data-original-title="(!getSkill(row).condi && getConnectedHits(row)) ? getCriticalHits(row) +' out of ' + getConnectedHits(row) + ' connected hit(s) <br> Damage: ' + getCriticalDamage(row) + '<br>' + round2(getCriticalDamage(row)*100/getDamage(row)) + '% of skill damage' : false">                        {{(!getSkill(row).condi && getConnectedHits(row)) ? round2(getCriticalHits(row)*100/getConnectedHits(row)) + '%' : ''}}                    </td>                    <td :class="getBodyClass('Data', 13)"                         :data-original-title="(!getSkill(row).condi && getConnectedHits(row)) ? getFlankingHits(row) +' out of ' + getConnectedHits(row) + ' connected hit(s)': false">                        {{(!getSkill(row).condi && getConnectedHits(row)) ? round2(getFlankingHits(row)*100/getConnectedHits(row)) + '%' : ''}}                    </td>                    <td :class="getBodyClass('Data', 14)"                         :data-original-title="(!getSkill(row).condi && getConnectedHits(row)) ? getGlancingHits(row) +' out of ' + getConnectedHits(row) + ' connected hit(s)': false">                        {{(!getSkill(row).condi && getConnectedHits(row)) ? round2(getGlancingHits(row)*100/getConnectedHits(row)) + '%' : ''}}                    </td>                    <td :class="getBodyClass('Data', 15)"                         :data-original-title="getAgainstMovingHits(row) +' out of ' + getConnectedHits(row) + ' connected hit(s)'">                        {{getConnectedHits(row) ? (round2(100 * getAgainstMovingHits(row)/getConnectedHits(row)) + '%') : ''}}                    </td>                    <td :class="getBodyClass('Data', 16)"  v-if="actor !== null"                        :data-original-title="getCastTimeWasted(row) ? round2(100.0 * getCastTimeWasted(row)/phase.durationS) + '% of the phase' : false">                        {{ getCastTimeWasted(row) ? getCastTimeWasted(row) + 's' : ''}}                    </td>                    <td :class="getBodyClass('Data', 17)" v-if="actor !== null"                        :data-original-title="getCastTimeSaved(row) ? round2(100.0 * getCastTimeSaved(row)/phase.durationS) + '% of the phase' : false">                        {{ getCastTimeSaved(row) ? getCastTimeSaved(row) + 's' : ''}}                    </td>                </tr>            </tbody>            <tfoot class="text-dark">                <tr>                    <td class="text-left">                        Total                    </td>                    <td></td>                    <td :data-original-title="Math.round(dmgdist.contributedDamage/phase.durationS) +' dps'">                        {{dmgdist.contributedDamage}}                    </td>                    <td :data-original-title="Math.round(dmgdist.contributedShieldDamage/phase.durationS) +' dps'">                        {{dmgdist.contributedShieldDamage}}                    </td>                    <td></td>                    <td></td>                    <td></td>                       <td v-if="wvw && actor !== null">                        {{dmgdist.contributedDownContribution >= 0 ? dmgdist.contributedDownContribution : ''}}                    </td>                    <td v-if="hasBreakbarDamage"></td>                    <td v-if="hasBreakbarDamage" :data-original-title="Math.round(dmgdist.contributedBreakbarDamage/phase.durationS) +' bps'">                        {{dmgdist.contributedBreakbarDamage}}                    </td>                    <td v-if="actor !== null"></td>                               <td></td>                    <td v-if="actor !== null"></td>                    <td v-if="actor !== null">                        {{round2(dmgdist.contributedDamage/(0.001 * dmgdist.totalCasting))}}                    </td>                    <td v-if="actor !== null"></td>                    <td></td>                    <td></td>                    <td></td>                    <td></td>                    <td v-if="actor !== null"></td>                    <td v-if="actor !== null"></td>                </tr>            </tfoot>        </table>    </div>`,
                        data: function () {
                            return {
                                wvw: logData.wvw,
                                sortdata: {
                                    order: "desc",
                                    index: 1,
                                    key: "Data",
                                    sortFunc: (row) => this.getDamage(row),
                                },
                            };
                        },
                        mixins: [
                            numberComponent,
                            sortedTableComponent,
                            sortedDistributionComponent,
                        ],
                        methods: {
                            getSkillID: function (data) {
                                return data[1];
                            },
                            getSkillIsBuff: function (data) {
                                return data[0];
                            },
                            getSkill: function (data) {
                                return findSkill(
                                    this.getSkillIsBuff(data),
                                    this.getSkillID(data)
                                );
                            },
                            showInequality: function (data) {
                                return (
                                    this.getCastDuration(data) === 0 &&
                                    this.getSkill(data).notAccurate
                                );
                            },
                            getConnectedHits: function (data) {
                                return data[6];
                            },
                            getCastDuration: function (data) {
                                return data[15];
                            },
                            getCastDurationNoInterrupt: function (data) {
                                return data[20];
                            },
                            getDamage: function (data) {
                                return data[2];
                            },
                            getCriticalDamage: function (data) {
                                return data[13];
                            },
                            getMinDamage: function (data) {
                                return data[3];
                            },
                            getMaxDamage: function (data) {
                                return data[4];
                            },
                            getBarrierDamage: function (data) {
                                return data[12];
                            },
                            getBreakbarDamage: function (data) {
                                return data[17];
                            },
                            getAllHits: function (data) {
                                return data[14];
                            },
                            getCriticalHits: function (data) {
                                return data[7];
                            },
                            getFlankingHits: function (data) {
                                return data[8];
                            },
                            getGlancingHits: function (data) {
                                return data[9];
                            },
                            getAgainstMovingHits: function (data) {
                                return data[16];
                            },
                            getCast: function (data) {
                                return data[5];
                            },
                            getCastNoInterrupt: function (data) {
                                return data[21];
                            },
                            getCastTimeWasted: function (data) {
                                return data[10];
                            },
                            getMinCastingTimeNoInterrupt: function (data) {
                                return data[18];
                            },
                            getMaxCastingTimeNoInterrupt: function (data) {
                                return data[19];
                            },
                            getCastTimeSaved: function (data) {
                                return data[11];
                            },
                            getDownContribution: function (data) {
                                return data[22];
                            },
                        },
                        computed: {
                            maxSkillCharacters: function () {
                                if (!this.actor) {
                                    return (
                                        (mainComponentWidth - 1450) / 10 + 25
                                    );
                                }
                                return (mainComponentWidth - 1450) / 10 + 15;
                            },
                            phase: function () {
                                return logData.phases[this.phaseindex];
                            },
                            isminion: function () {
                                return this.minionindex > -1;
                            },
                            actor: function () {
                                if (this.actorindex < 0) {
                                    return null;
                                }
                                var master = !this.player
                                    ? logData.targets[this.actorindex]
                                    : logData.players[this.actorindex];
                                if (this.isminion) {
                                    return master.minions[this.minionindex];
                                }
                                return master;
                            },
                            hasBreakbarDamage: function () {
                                return logData.hasBreakbarDamage;
                            },
                            UIIcons: function () {
                                return UIIcons;
                            },
                        },
                    });
                }
                {
                    Vue.component("dmgdist-target-component", {
                        props: ["targetindex", "phaseindex"],
                        template: `    <div>        <div v-if="target.minions.length > 0">            <ul class="nav nav-tabs">                <li>                    <a class="nav-link" :class="{active: distmode === -1}" @click="distmode = -1">{{target.name}}</a>                </li>                <li v-for="(minion, mindex) in target.minions">                    <a class="nav-link" :class="{active: distmode === mindex}"                        @click="distmode = mindex">{{minion.name}}</a>                </li>            </ul>        </div>        <damagedist-table-component :dmgdist="dmgdist" :tableid="'dmgdist-target-' + targetindex"            :actorindex="targetindex" :minionindex="distmode"             :player="false" :istarget="false"            :phaseindex="phaseindex"></damagedist-table-component>    </div>`,
                        data: function () {
                            return {
                                distmode: -1,
                            };
                        },
                        computed: {
                            target: function () {
                                return logData.targets[this.targetindex];
                            },
                            dmgdist: function () {
                                if (this.distmode === -1) {
                                    return this.target.details.dmgDistributions[
                                        this.phaseindex
                                    ];
                                }
                                return this.target.details.minions[
                                    this.distmode
                                ].dmgDistributions[this.phaseindex];
                            },
                        },
                    });
                }
                {
                    Vue.component("dmgtakendist-target-component", {
                        props: ["targetindex", "phaseindex"],
                        template: `    <div>        <div v-if="target.minions.length > 0">            <ul class="nav nav-tabs">                <li>                    <a class="nav-link" :class="{active: distmode === -1}" @click="distmode = -1">{{target.name}}</a>                </li>                <li v-for="(minion, mindex) in target.minions">                    <a class="nav-link" :class="{active: distmode === mindex}"                        @click="distmode = mindex">{{minion.name}}</a>                </li>            </ul>        </div>        <damagedist-table-component :dmgdist="dmgtaken" :tableid="'dmgtakendist-target-' + targetindex"             :actorindex="-1" :minionindex="distmode" :istarget="false" :player="false"            :phaseindex="phaseindex">        </damagedist-table-component>    </div>`,
                        data: function () {
                            return {
                                distmode: -1,
                            };
                        },
                        computed: {
                            target: function () {
                                return logData.targets[this.targetindex];
                            },
                            dmgtaken: function () {
                                if (this.distmode === -1) {
                                    return this.target.details
                                        .dmgDistributionsTaken[this.phaseindex];
                                }
                                return this.target.details.minions[
                                    this.distmode
                                ].dmgDistributionsTaken[this.phaseindex];
                            },
                        },
                    });
                }
                {
                    Vue.component("dmgmodifier-table-component", {
                        props: [
                            "phaseindex",
                            "id",
                            "playerindex",
                            "playerindices",
                            "activetargets",
                            "modifiers",
                            "modifiersdata",
                            "mode",
                            "sum",
                        ],
                        mixins: [
                            numberComponent,
                            sortedTableComponent,
                            colSliderComponent(maxBuffColumns),
                            encounterPhaseComponent,
                        ],
                        template: `    <div>        <div v-if="colPageCount > 0">            <table-scroll-component :min="0" :max="colPageCount" :width="'600px'" :height="'10px'" :transform="transFormString" :pagestructure="colStructure"></table-scroll-component>        </div>        <table class="table table-sm table-striped table-hover" cellspacing="0" width="100%" :id="tableid">            <thead>                <tr>                    <th class="sub-cell" :class="getHeaderClass('Sub')" @click="sortBy('Sub')">Sub</th>                    <th class="prof-cell" :class="getHeaderClass('Prof')" @click="sortBy('Prof')"></th>                    <th class="text-left" :class="getHeaderClass('Name')" @click="sortBy('Name')">Name</th>                    <th class="stat-cell" v-for="(modifier, index) in modifiers" :class="getHeaderClass('Data', index)"                         v-show="isInColPage(index)"                        @click="sortBy('Data', index)":data-original-title="modifier.name + '<br>' + modifier.tooltip">                        <img :src="modifier.icon" :alt="modifier.name" class="icon icon-hover">                    </th>                </tr>            </thead>            <tbody>                <tr v-for="row in sortData((mode ? tableDataTarget.rows : tableData.rows))"                    :class="{active: row.player.id === playerindex}">                    <td :class="getBodyClass('Sub')">{{row.player.group}}</td>                    <td :class="getBodyClass('Prof')":data-original-title="row.player.profession">                        <img :src="row.player.icon" :alt="row.player.profession" class="icon"><span                            style="display:none">{{row.player.profession}}</span>                    </td>                    <td :class="getBodyClass('Name')"class="text-left">{{row.player.name}}</td>                    <td v-for="(modifier, index) in modifiers" :class="getBodyClass('Data', index, modifier.approximate, getCellValue(row.data[index], modifier))"                        v-show="isInColPage(index)"                        :data-original-title="getTooltip(row.data[index], modifier)">                        {{getCellValue(row.data[index], modifier)}}                    </td>                </tr>            </tbody>            <tfoot v-if="sum">                <tr v-for="row in (mode ? tableDataTarget.sums : tableData.sums)">                    <td></td>                    <td></td>                    <td class="text-left">{{row.name}}</td>                    <td v-for="(modifier, index) in modifiers" :class="getSumClass(modifier.approximate,getCellValue(row.data[index], modifier))"                        v-show="isInColPage(index)"                        :data-original-title="getTooltip(row.data[index], modifier)">                        {{getCellValue(row.data[index], modifier)}}                    </td>                </tr>            </tfoot>        </table>    </div>`,
                        data: function () {
                            return {
                                cache: new Map(),
                                cacheTarget: new Map(),
                                sortdata: {
                                    order: "asc",
                                    index: -1,
                                    key: "Prof",
                                },
                            };
                        },
                        computed: {
                            transFormString: function () {
                                const translateValue =
                                    mainComponentWidth * 0.34;
                                return `translate(${translateValue}px)`;
                            },
                            tableid: function () {
                                return this.id;
                            },
                            phase: function () {
                                return logData.phases[this.phaseindex];
                            },
                            colPageCount: function () {
                                return (
                                    this.modifiers.length -
                                    this.colStructure.perpage
                                );
                            },
                            indicesToUse: function () {
                                var res = [];
                                if (this.playerindices !== null) {
                                    for (
                                        var i = 0;
                                        i < this.playerindices.length;
                                        i++
                                    ) {
                                        res.push(this.playerindices[i]);
                                    }
                                    return res;
                                }
                                const players = getActiveNonFakePlayersForPhase(
                                    this.encounterPhase
                                );
                                for (var i = 0; i < players.length; i++) {
                                    if (!players[i]) {
                                        continue;
                                    }
                                    res.push(i);
                                }
                                return res;
                            },
                            tableData: function () {
                                const cacheID =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex;
                                if (this.cache.has(cacheID)) {
                                    return this.cache.get(cacheID);
                                }
                                var rows = [];
                                var sums = [];
                                var groups = [];
                                var total = {
                                    name: "Total",
                                    data: [],
                                };
                                var j;
                                for (
                                    var i = 0;
                                    i < this.indicesToUse.length;
                                    i++
                                ) {
                                    var index = this.indicesToUse[i];
                                    var player = logData.players[index];
                                    if (
                                        !player.notInSquad &&
                                        !groups[player.group]
                                    ) {
                                        groups[player.group] = {
                                            name: "Group" + player.group,
                                            data: [],
                                        };
                                    }
                                    var dmgModifier =
                                        this.modifiersdata[index].data;
                                    var data = [];
                                    for (
                                        j = 0;
                                        j < this.modifiers.length;
                                        j++
                                    ) {
                                        data[j] = dmgModifier[j];
                                        if (!player.notInSquad) {
                                            if (!groups[player.group].data[j]) {
                                                groups[player.group].data[j] = [
                                                    0, 0, 0, 0,
                                                ];
                                            }
                                            if (!total.data[j]) {
                                                total.data[j] = [0, 0, 0, 0];
                                            }
                                            for (
                                                var k = 0;
                                                k < data[j].length;
                                                k++
                                            ) {
                                                groups[player.group].data[j][
                                                    k
                                                ] += data[j][k];
                                                total.data[j][k] += data[j][k];
                                            }
                                        }
                                    }
                                    rows.push({
                                        player: player,
                                        data: data,
                                    });
                                }
                                for (var i = 0; i < groups.length; i++) {
                                    if (groups[i]) {
                                        sums.push(groups[i]);
                                    }
                                }
                                sums.push(total);
                                var res = {
                                    rows: rows,
                                    sums: sums,
                                };
                                this.cache.set(cacheID, res);
                                return res;
                            },
                            tableDataTarget: function () {
                                let cacheID =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex;
                                cacheID += getTargetCacheID(this.activetargets);
                                if (this.cacheTarget.has(cacheID)) {
                                    return this.cacheTarget.get(cacheID);
                                }
                                var rows = [];
                                var sums = [];
                                var groups = [];
                                var total = {
                                    name: "Total",
                                    data: [],
                                };
                                var j;
                                for (
                                    var i = 0;
                                    i < this.indicesToUse.length;
                                    i++
                                ) {
                                    var index = this.indicesToUse[i];
                                    var player = logData.players[index];
                                    if (
                                        !player.notInSquad &&
                                        !groups[player.group]
                                    ) {
                                        groups[player.group] = {
                                            name: "Group" + player.group,
                                            data: [],
                                        };
                                    }
                                    var data = [];
                                    for (
                                        j = 0;
                                        j < this.modifiers.length;
                                        j++
                                    ) {
                                        data[j] = [0, 0, 0, 0];
                                        if (!player.notInSquad) {
                                            if (!groups[player.group].data[j]) {
                                                groups[player.group].data[j] = [
                                                    0, 0, 0, 0,
                                                ];
                                            }
                                            if (!total.data[j]) {
                                                total.data[j] = [0, 0, 0, 0];
                                            }
                                        }
                                    }
                                    var dmgModifier =
                                        this.modifiersdata[index].dataTarget;
                                    for (
                                        j = 0;
                                        j < this.activetargets.length;
                                        j++
                                    ) {
                                        var modifier =
                                            dmgModifier[this.activetargets[j]];
                                        for (
                                            var k = 0;
                                            k < this.modifiers.length;
                                            k++
                                        ) {
                                            var targetData = modifier[k];
                                            var curData = data[k];
                                            for (
                                                var l = 0;
                                                l < targetData.length;
                                                l++
                                            ) {
                                                curData[l] += targetData[l];
                                            }
                                        }
                                    }
                                    if (!player.notInSquad) {
                                        for (
                                            j = 0;
                                            j < this.modifiers.length;
                                            j++
                                        ) {
                                            for (
                                                var k = 0;
                                                k < data[j].length;
                                                k++
                                            ) {
                                                groups[player.group].data[j][
                                                    k
                                                ] += data[j][k];
                                                total.data[j][k] += data[j][k];
                                            }
                                        }
                                    }

                                    rows.push({
                                        player: player,
                                        data: data,
                                    });
                                }
                                for (var i = 0; i < groups.length; i++) {
                                    if (groups[i]) {
                                        sums.push(groups[i]);
                                    }
                                }
                                sums.push(total);
                                var res = {
                                    rows: rows,
                                    sums: sums,
                                };
                                this.cacheTarget.set(cacheID, res);
                                return res;
                            },
                        },
                        methods: {
                            sortBy: function (key, index) {
                                this.sortByBase(this.sortdata, key, index);
                            },
                            getHeaderClass: function (key, index) {
                                return this.getHeaderClassBase(
                                    this.sortdata,
                                    key,
                                    index
                                );
                            },
                            getBodyClass: function (
                                key,
                                index,
                                approximate,
                                cellValue
                            ) {
                                var classes = this.getBodyClassBase(
                                    this.sortdata,
                                    key,
                                    index
                                );
                                classes.approximate =
                                    cellValue !== "-" && cellValue !== "Tooltip"
                                        ? !!approximate
                                        : false;
                                return classes;
                            },
                            getSumClass: function (approximate, cellValue) {
                                var classes = {};
                                classes.approximate =
                                    cellValue !== "-" && cellValue !== "Tooltip"
                                        ? !!approximate
                                        : false;
                                return classes;
                            },
                            sortData: function (rows) {
                                var order =
                                    this.sortdata.order === "asc" ? 1 : -1;
                                switch (this.sortdata.key) {
                                    case "Sub":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    (x.player.group -
                                                        y.player.group) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Prof":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    this.sortByPlayerProfession(
                                                        x,
                                                        y
                                                    ) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Name":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Data":
                                        var index = this.sortdata.index;
                                        var modifier = this.modifiers[index];
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    (this.getNumericalCellValue(
                                                        x.data[index],
                                                        modifier
                                                    ) -
                                                        this.getNumericalCellValue(
                                                            y.data[index],
                                                            modifier
                                                        )) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    default:
                                        return null;
                                        break;
                                }
                                return rows;
                            },
                            getTooltip: function (item, mod) {
                                if (item[0] === 0) {
                                    return null;
                                }
                                var hits =
                                    item[0] + " out of " + item[1] + " hits";
                                var percent;
                                if (mod.skillBased) {
                                    percent =
                                        this.round3(
                                            (1000.0 * item[1]) /
                                                this.phase.duration
                                        ) + " hits/s";
                                } else {
                                    percent =
                                        this.round3(
                                            (100.0 * item[0]) / item[1]
                                        ) + " hit %";
                                }
                                var res = hits + "<br>" + percent;
                                if (item[2] === 0) {
                                    return res;
                                }
                                var gain;
                                if (mod.nonMultiplier) {
                                    gain = "Damage Done: ";
                                } else {
                                    gain = "Pure Damage: ";
                                }
                                gain += this.round(item[2]);
                                if (mod.nonMultiplier) {
                                    gain +=
                                        "<br>Total Damage: " +
                                        this.round3(
                                            (100.0 * item[2]) / item[3]
                                        ) +
                                        "%";
                                }
                                return res + "<br>" + gain;
                            },
                            getNumericalCellValue: function (item, mod) {
                                var cellValue = this.getCellValue(item, mod);
                                if (cellValue === "Tooltip") {
                                    return Number.MAX_SAFE_INTEGER;
                                } else if (cellValue === "-") {
                                    return 0;
                                }
                                return parseFloat(cellValue);
                            },
                            getCellValue: function (item, mod) {
                                if (item[2] === 0) {
                                    if (item[0] > 0) {
                                        return "Tooltip";
                                    }
                                    return "-";
                                }
                                if (mod.nonMultiplier) {
                                    return "Tooltip";
                                }
                                var damageIncrease = this.round3(
                                    100 * (item[3] / (item[3] - item[2]) - 1.0)
                                );
                                if (
                                    Math.abs(damageIncrease) < 1e-6 ||
                                    isNaN(damageIncrease) ||
                                    !isFinite(damageIncrease)
                                ) {
                                    return "-";
                                }
                                return damageIncrease + "%";
                            },
                        },
                    });
                }
                {
                    function getDefaultDamageModifiersSubComponent() {
                        if (!validateStartPath("Statistics/DamageModifiers")) {
                            return hasOutgoingDamageMods() ? 0 : 1;
                        }
                        const setting = EIUrlParams.get("startPage");
                        const compo = setting.split("/")[2];
                        switch (compo) {
                            case "OutgoingDamageModifiers":
                                return hasOutgoingDamageMods() ? 0 : 1;
                            case "IncomingDamageModifiers":
                                return hasIncomingDamageMods() ? 1 : 0;
                        }
                        return hasOutgoingDamageMods() ? 0 : 1;
                    }
                    Vue.component("dmgmodifier-stats-container-component", {
                        props: ["phaseindex", "playerindex", "activetargets"],
                        template: `    <div>        <ul class="nav nav-tabs" v-if="hasIncDamageMods && hasOutDamageMods">            <li>                <a class="nav-link" :class="{active: mode === 0}" @click="mode = 0"> Outgoing Damage                    Modifiers </a>            </li>            <li>                <a class="nav-link" :class="{active: mode === 1}" @click="mode = 1"> Incoming Damage                    Modifiers </a>            </li>        </ul>        <keep-alive>            <dmgmodifier-stats-component v-if="mode === 0" :key="'modifier-out'"                :phaseindex="phaseindex" :playerindex="playerindex" :activetargets="activetargets" :incoming="false">            </dmgmodifier-stats-component>            <dmgmodifier-stats-component v-if="mode === 1" :key="'modifier-inc'"                :phaseindex="phaseindex" :playerindex="playerindex" :activetargets="activetargets" :incoming="true">            </dmgmodifier-stats-component>        </keep-alive>    </div>`,
                        data: function () {
                            return {
                                mode: getDefaultDamageModifiersSubComponent(),
                            };
                        },
                        computed: {
                            hasOutDamageMods: function () {
                                return hasOutgoingDamageMods();
                            },
                            hasIncDamageMods: function () {
                                return hasIncomingDamageMods();
                            },
                        },
                    });
                }
                {
                    function getDefaultDamageModifiersSubSubComponent(
                        incoming,
                        dmgModifiersItem,
                        dmgModifiersCommon
                    ) {
                        let path =
                            "Statistics/DamageModifiers/" +
                            (incoming
                                ? "IncomingDamageModifiers"
                                : "OutgoingDamageModifiers");
                        if (!validateStartPath(path)) {
                            return dmgModifiersItem.length > 0
                                ? 0
                                : dmgModifiersCommon.length > 0
                                ? 1
                                : 2;
                        }
                        const setting = EIUrlParams.get("startPage");
                        const compo = setting.split("/")[3];
                        switch (compo) {
                            case "GearBasedDamageModifiers":
                                return dmgModifiersItem.length > 0
                                    ? 0
                                    : dmgModifiersCommon.length > 0
                                    ? 1
                                    : 2;
                            case "SharedDamageModifiers":
                                return dmgModifiersCommon.length > 0
                                    ? 1
                                    : dmgModifiersItem.length > 0
                                    ? 0
                                    : 2;
                            case "ClassBasedDamageModifiers":
                                return 2;
                        }
                        return dmgModifiersItem.length > 0
                            ? 0
                            : dmgModifiersCommon.length > 0
                            ? 1
                            : 2;
                    }
                    Vue.component("dmgmodifier-stats-component", {
                        props: [
                            "phaseindex",
                            "playerindex",
                            "activetargets",
                            "incoming",
                        ],
                        template: `    <div>        <ul class="nav nav-tabs">            <li v-if="itemModifiers.length > 0">                <a class="nav-link" :class="{active: displaymode === 0}" @click="displaymode = 0"> Gear Based Damage                    Modifiers </a>            </li>            <li v-if="commonModifiers.length > 0">                <a class="nav-link" :class="{active: displaymode === 1}" @click="displaymode = 1"> Shared Damage                    Modifiers </a>            </li>            <li>                <a class="nav-link" :class="{active: displaymode === 2}" @click="displaymode = 2"> Class Based Damage                    Modifiers </a>            </li>        </ul>        <ul v-if="!targetless" class="nav nav-pills d-flex flex-row justify-content-center mt-1 mb-1 scale85">            <li class="nav-item">                <a class="nav-link" @click="mode = 1" data-original-title="Against selected target(s)."                   :class="{active: mode}">Target</a>            </li>            <li class="nav-item">                <a class="nav-link" @click="mode = 0" data-original-title="Against all enemies."                   :class="{active: !mode }">All</a>            </li>        </ul>        <keep-alive>            <dmgmodifier-table-component v-if="displaymode === 0" :key="'gear' + extraID" :phaseindex="phaseindex"                :playerindex="playerindex" :activetargets="activetargets" :mode="mode"                :id="'damage-modifier-item-table' + extraID" :playerindices="null" :modifiers="itemModifiers"                :modifiersdata="dmgModifiersItemStats" :sum="true"></dmgmodifier-table-component>            <dmgmodifier-table-component v-if="displaymode === 1" :key="'common' + extraID" :phaseindex="phaseindex"                :playerindex="playerindex" :activetargets="activetargets" :mode="mode"                :id="'damage-modifier-common-table' + extraID" :playerindices="null" :modifiers="commonModifiers"                :modifiersdata="dmgModifiersCommonStats" :sum="true"></dmgmodifier-table-component>            <dmgmodifier-persstats-component v-if="displaymode === 2" :key="'pers' + extraID" :phaseindex="phaseindex"                :playerindex="playerindex" :activetargets="activetargets" :mode="mode" :incoming="incoming">            </dmgmodifier-persstats-component>        </keep-alive>    </div>`,
                        data: function () {
                            const dmgModifiersItem = this.incoming
                                ? logData.dmgIncModifiersItem
                                : logData.dmgModifiersItem;
                            const dmgModifiersCommon = this.incoming
                                ? logData.dmgIncModifiersCommon
                                : logData.dmgModifiersCommon;
                            return {
                                mode: logData.targetless ? 0 : 1,
                                targetless: logData.targetless,
                                displaymode:
                                    getDefaultDamageModifiersSubSubComponent(
                                        this.incoming,
                                        dmgModifiersItem,
                                        dmgModifiersCommon
                                    ),
                            };
                        },
                        computed: {
                            extraID: function () {
                                return this.incoming ? "inc" : "";
                            },
                            dmgModifiersItem: function () {
                                return this.incoming
                                    ? logData.dmgIncModifiersItem
                                    : logData.dmgModifiersItem;
                            },
                            dmgModifiersCommon: function () {
                                return this.incoming
                                    ? logData.dmgIncModifiersCommon
                                    : logData.dmgModifiersCommon;
                            },
                            dmgModifiersItemStats: function () {
                                return this.incoming
                                    ? this.phase.dmgIncModifiersItem
                                    : this.phase.dmgModifiersItem;
                            },
                            dmgModifiersCommonStats: function () {
                                return this.incoming
                                    ? this.phase.dmgIncModifiersCommon
                                    : this.phase.dmgModifiersCommon;
                            },
                            damageModMap: function () {
                                return this.incoming
                                    ? logData.damageIncModMap
                                    : logData.damageModMap;
                            },
                            phase: function () {
                                return logData.phases[this.phaseindex];
                            },
                            commonModifiers: function () {
                                var modifiers = [];
                                for (
                                    var i = 0;
                                    i < this.dmgModifiersCommon.length;
                                    i++
                                ) {
                                    modifiers.push(
                                        this.damageModMap[
                                            "d" + this.dmgModifiersCommon[i]
                                        ]
                                    );
                                }
                                return modifiers;
                            },
                            itemModifiers: function () {
                                var modifiers = [];
                                for (
                                    var i = 0;
                                    i < this.dmgModifiersItem.length;
                                    i++
                                ) {
                                    modifiers.push(
                                        this.damageModMap[
                                            "d" + this.dmgModifiersItem[i]
                                        ]
                                    );
                                }
                                return modifiers;
                            },
                        },
                    });
                }
                {
                    function getDefaultDamageModifiersClassSubComponent(
                        incoming
                    ) {
                        let path =
                            "Statistics/DamageModifiers/" +
                            (incoming
                                ? "IncomingDamageModifiers"
                                : "OutgoingDamageModifiers") +
                            "/ClassBasedDamageModifiers";
                        if (!validateStartPath(path)) {
                            return "None";
                        }
                        const setting = EIUrlParams.get("startPage");
                        const compo = setting.split("/")[4];
                        return compo ? compo : "None";
                    }
                    Vue.component("dmgmodifier-persstats-component", {
                        props: [
                            "phaseindex",
                            "playerindex",
                            "activetargets",
                            "mode",
                            "incoming",
                        ],
                        mixins: [encounterPhaseComponent],
                        template: `    <div>        <ul class="nav nav-pills d-flex flex-row justify-content-center mt-1 mb-1 scale85">            <li v-for="base in bases" class="nav-item">                <a class="nav-link" @click="specmode = base" :class="{active: specmode === base}">{{ base }}</a>            </li>        </ul>        <div>            <div v-for="(spec, index) in orderedSpecs" class="mt-1 mb-1">                <div v-show="specToBase[spec.name] === specmode">                    <h3 class="text-center">{{ spec.name }}</h3>                    <dmgmodifier-table-component :phaseindex="phaseindex" :playerindex="playerindex"                        :activetargets="activetargets" :mode="mode" :id="'damage-modifier-pers-table-'+spec.name + (incoming ? 'inc' : '')"                        :modifiers="personalModifiers[index]" :playerindices="spec.ids"                        :modifiersdata="dmgModifiersPersStats" :sum="false"></dmgmodifier-table-component>                </div>            </div>        </div>    </div>`,
                        data: function () {
                            return {
                                bases: [],
                                specmode:
                                    getDefaultDamageModifiersClassSubComponent(
                                        this.incoming
                                    ),
                                specToBase: SpecToBase,
                            };
                        },
                        computed: {
                            phase: function () {
                                return logData.phases[this.phaseindex];
                            },
                            damageModMap: function () {
                                return this.incoming
                                    ? logData.damageIncModMap
                                    : logData.damageModMap;
                            },
                            dmgModifiersPers: function () {
                                return this.incoming
                                    ? logData.dmgIncModifiersPers
                                    : logData.dmgModifiersPers;
                            },
                            dmgModifiersPersStats: function () {
                                return this.incoming
                                    ? this.phase.dmgIncModifiersPers
                                    : this.phase.dmgModifiersPers;
                            },
                            dmgModifiersPersStats0: function () {
                                let phase0 = logData.phases[0];
                                return this.incoming
                                    ? phase0.dmgIncModifiersPers
                                    : phase0.dmgModifiersPers;
                            },
                            orderedSpecs: function () {
                                var res = [];
                                var aux = new Set();
                                const players = getActivePlayersForPhase(
                                    this.encounterPhase
                                );
                                for (var i = 0; i < specs.length; i++) {
                                    var spec = specs[i];
                                    var pBySpec = [];
                                    for (var j = 0; j < players.length; j++) {
                                        if (
                                            players[j] &&
                                            players[j].profession === spec &&
                                            this.dmgModifiersPersStats0[j].data
                                                .length > 0
                                        ) {
                                            pBySpec.push(j);
                                        }
                                    }
                                    if (pBySpec.length) {
                                        aux.add(SpecToBase[spec]);
                                        res.push({
                                            ids: pBySpec,
                                            name: spec,
                                        });
                                    }
                                }
                                this.bases = [];
                                var _this = this;
                                aux.forEach(function (value, value2, set) {
                                    _this.bases.push(value);
                                });
                                if (
                                    this.specmode === "None" ||
                                    !this.bases.includes(this.specmode)
                                ) {
                                    this.specmode = this.bases[0];
                                }
                                return res;
                            },
                            personalModifiers: function () {
                                var res = [];
                                for (
                                    var i = 0;
                                    i < this.orderedSpecs.length;
                                    i++
                                ) {
                                    var spec = this.orderedSpecs[i];
                                    var data = [];
                                    for (
                                        var j = 0;
                                        j <
                                        this.dmgModifiersPers[spec.name].length;
                                        j++
                                    ) {
                                        data.push(
                                            this.damageModMap[
                                                "d" +
                                                    this.dmgModifiersPers[
                                                        spec.name
                                                    ][j]
                                            ]
                                        );
                                    }
                                    res.push(data);
                                }
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("damage-stats-component", {
                        props: ["activetargets", "playerindex", "phaseindex"],
                        template: `    <div>        <table class="table table-sm table-striped table-hover" cellspacing="0" width="100%" :id="tableid">            <thead>                <tr>                    <th class="sub-cell" :class="getHeaderClass('Sub')" @click="sortBy('Sub')">Sub</th>                    <th class="prof-cell" :class="getHeaderClass('Prof')" @click="sortBy('Prof')"></th>                    <th class="text-left" :class="getHeaderClass('Name')" @click="sortBy('Name')">Name</th>                    <th :class="getHeaderClass('Account')" @click="sortBy('Account')">Account</th>                    <th v-if="!targetless" :class="getHeaderClass('Data', 0)" @click="sortBy('Data', 0)" data-original-title="Power + Condition" class="damage-cell">                        Target <img :src="UIIcons.Damage" alt="All"                            class="icon">                    </th>                    <th v-if="!targetless" :class="getHeaderClass('Data', 1)" @click="sortBy('Data', 1)" data-original-title="Power" class="damage-cell">                        Target <img :src="UIIcons.Power" alt="Power"                             class="icon">                    </th>                    <th v-if="!targetless" :class="getHeaderClass('Data', 2)" @click="sortBy('Data', 2)" data-original-title="Condition" class="damage-cell">                        Target <img :src="UIIcons.ConditionDamage" alt="Condition"                        class="icon">                    </th>                    <th :class="getHeaderClass('Data', 3)" @click="sortBy('Data', 3)" v-if="!targetless && hasBreakbarDamage" data-original-title="Breakbar" class="damage-cell">                        Target <img :src="UIIcons.Breakbar" alt="Breakbar"                        class="icon">                    </th>                    <th :class="getHeaderClass('Data', 4)" @click="sortBy('Data', 4)" data-original-title="Power + Condition" class="damage-cell">                        All <img :src="UIIcons.Damage" alt="All"                        class="icon">                    </th>                    <th :class="getHeaderClass('Data', 5)" @click="sortBy('Data', 5)" data-original-title="Power" class="damage-cell">                        All <img :src="UIIcons.Power" alt="Power"                        class="icon">                    </th>                    <th :class="getHeaderClass('Data', 6)" @click="sortBy('Data', 6)" data-original-title="Condition" class="damage-cell">                        All <img :src="UIIcons.ConditionDamage" alt="Condition"                        class="icon">                    </th>                    <th :class="getHeaderClass('Data', 7)" @click="sortBy('Data', 7)" v-if="hasBreakbarDamage" data-original-title="Breakbar" class="damage-cell">                        All <img :src="UIIcons.Breakbar" alt="Breakbar"                        class="icon">                    </th>                </tr>            </thead>            <tbody>                <tr v-for="row in sortData(tableData.rows)" :class="{active: row.player.id === playerindex}">                    <td :class="getBodyClass('Sub')">{{row.player.group}}</td>                    <td :class="getBodyClass('Prof')" :data-original-title="row.player.profession">                        <img :src="row.player.icon" :alt="row.player.profession" class="icon"><span                            style="display:none">{{row.player.profession}}</span>                    </td>                    <td :class="getBodyClass('Name')" class="text-left">{{row.player.name}}</td>                    <td :class="getBodyClass('Account')">{{row.player.acc}}</td>                    <td v-if="!targetless" :class="getBodyClass('Data', 0)"                        :data-original-title="getPlayerTooltip(0, row, tableData.sums)">                        {{getPlayerCell(0, row)}}</td>                    <td v-if="!targetless" :class="getBodyClass('Data', 1)"                        :data-original-title="getPlayerTooltip(1, row, tableData.sums)">                        {{getPlayerCell(1, row)}}</td>                    <td v-if="!targetless" :class="getBodyClass('Data', 2)"                        :data-original-title="getPlayerTooltip(2, row, tableData.sums)">                        {{getPlayerCell(2, row)}}</td>                    <td v-if="!targetless && hasBreakbarDamage" :class="getBodyClass('Data', 3)"                        :data-original-title="computeTotalContribution(3, row.dps,tableData.sums)+ '<br>'+ computeGroupContribution(row.player.group, 3, row.dps,tableData.sums)">                        {{round1(row.dps[3])}}                    </td>                    <td :class="getBodyClass('Data', 4)"                        :data-original-title="getPlayerTooltip(4, row, tableData.sums)">                        {{getPlayerCell(4, row)}}</td>                    <td :class="getBodyClass('Data', 5)"                        :data-original-title="getPlayerTooltip(5, row, tableData.sums)">                        {{getPlayerCell(5, row)}}</td>                    <td :class="getBodyClass('Data', 6)"                        :data-original-title="getPlayerTooltip(6, row, tableData.sums)">                        {{getPlayerCell(6, row)}}</td>                    <td v-if="hasBreakbarDamage" :class="getBodyClass('Data', 7)"                        :data-original-title="computeTotalContribution(7, row.dps,tableData.sums)+ '<br>'+ computeGroupContribution(row.player.group, 7, row.dps,tableData.sums)">                        {{round1(row.dps[7])}}                    </td>                </tr>            </tbody>            <tfoot>                <tr v-for="sum in tableData.sums">                    <td></td>                    <td></td>                    <td class="text-left">{{sum.name}}</td>                    <td></td>                    <td v-if="!targetless" :data-original-title="getSumTooltip(0, sum)">                        {{getSumCell(0, sum)}}</td>                    <td v-if="!targetless" :data-original-title="getSumTooltip(1, sum)">                        {{getSumCell(1, sum)}}</td>                    <td v-if="!targetless" :data-original-title="getSumTooltip(2, sum)">                        {{getSumCell(2, sum)}}</td>                    <td v-if="!targetless && hasBreakbarDamage">                        {{round1(sum.dps[3])}}                    </td>                    <td :data-original-title="getSumTooltip(4, sum)">                        {{getSumCell(4, sum)}}</td>                    <td :data-original-title="getSumTooltip(5, sum)">                        {{getSumCell(5, sum)}}</td>                    <td :data-original-title="getSumTooltip(6, sum)">                        {{getSumCell(6, sum)}}</td>                    <td v-if="hasBreakbarDamage">                        {{round1(sum.dps[7])}}                    </td>                </tr>            </tfoot>        </table>    </div>`,
                        mixins: [
                            numberComponent,
                            sortedTableComponent,
                            encounterPhaseComponent,
                        ],
                        data: function () {
                            return {
                                targetless: logData.targetless,
                                showDamage: logData.wvw,
                                cacheTarget: new Map(),
                                sortdata: {
                                    order: "desc",
                                    key: "Data",
                                    index: logData.targetless ? 4 : 0,
                                },
                            };
                        },
                        methods: {
                            sortBy: function (key, index) {
                                this.sortByBase(this.sortdata, key, index);
                            },
                            getHeaderClass: function (key, index) {
                                return this.getHeaderClassBase(
                                    this.sortdata,
                                    key,
                                    index
                                );
                            },
                            getBodyClass: function (key, index, approximate) {
                                var classes = this.getBodyClassBase(
                                    this.sortdata,
                                    key,
                                    index
                                );
                                classes.approximate = !!approximate;
                                return classes;
                            },
                            sortData: function (rows) {
                                var order =
                                    this.sortdata.order === "asc" ? 1 : -1;
                                switch (this.sortdata.key) {
                                    case "Sub":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    (x.player.group -
                                                        y.player.group) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Prof":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    this.sortByPlayerProfession(
                                                        x,
                                                        y
                                                    ) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Name":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Account":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                this.sortByPlayerAccount(x, y)
                                        );
                                        break;
                                    case "Data":
                                        var index = this.sortdata.index;
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    (x.dps[index] -
                                                        y.dps[index]) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    default:
                                        return null;
                                        break;
                                }
                                return rows;
                            },
                            computeTotalContribution: function (
                                index,
                                row,
                                sums
                            ) {
                                return (
                                    this.round2(
                                        (row[index] * 100) /
                                            sums[sums.length - 1].dps[index]
                                    ) + "% of total"
                                );
                            },
                            computeGroupContribution: function (
                                groupIndex,
                                index,
                                row,
                                sums
                            ) {
                                var sumId = 0;
                                for (
                                    var sumId = 0;
                                    sumId < sums.length;
                                    sumId++
                                ) {
                                    if (sums[sumId].name.includes(groupIndex)) {
                                        break;
                                    }
                                }
                                return (
                                    this.round2(
                                        (row[index] * 100) /
                                            sums[sumId].dps[index]
                                    ) + "% of group"
                                );
                            },
                            getPlayerTooltip: function (index, row, sums) {
                                return (
                                    (!this.showDamage
                                        ? row.dps[index]
                                        : this.round(
                                              row.dps[index] /
                                                  this.phase.durationS
                                          )) +
                                    " damage" +
                                    "<br>" +
                                    this.computeTotalContribution(
                                        index,
                                        row.dps,
                                        sums
                                    ) +
                                    "<br>" +
                                    this.computeGroupContribution(
                                        row.player.group,
                                        index,
                                        row.dps,
                                        sums
                                    )
                                );
                            },
                            getPlayerCell: function (index, row) {
                                return this.showDamage
                                    ? row.dps[index]
                                    : this.round(
                                          row.dps[index] / this.phase.durationS
                                      );
                            },
                            getSumTooltip: function (index, row) {
                                return (
                                    (!this.showDamage
                                        ? row.dps[index]
                                        : this.round(
                                              row.dps[index] /
                                                  this.phase.durationS
                                          )) + " damage"
                                );
                            },
                            getSumCell: function (index, row) {
                                return this.showDamage
                                    ? row.dps[index]
                                    : this.round(
                                          row.dps[index] / this.phase.durationS
                                      );
                            },
                        },
                        computed: {
                            tableid: function () {
                                return "dps-table";
                            },
                            phase: function () {
                                return logData.phases[this.phaseindex];
                            },
                            hasBreakbarDamage: function () {
                                return logData.hasBreakbarDamage;
                            },
                            tableData: function () {
                                var cacheID =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex +
                                    "-";
                                cacheID += getTargetCacheID(this.activetargets);
                                if (this.cacheTarget.has(cacheID)) {
                                    return this.cacheTarget.get(cacheID);
                                }
                                var rows = [];
                                var sums = [];
                                var total = [0, 0, 0, 0, 0, 0, 0, 0];
                                var groups = [];
                                var i, j;
                                const players = getActivePlayersForPhase(
                                    this.encounterPhase
                                );
                                for (
                                    i = 0;
                                    i < this.phase.dpsStats.length;
                                    i++
                                ) {
                                    var player = players[i];
                                    if (!player) {
                                        continue;
                                    }
                                    var dpsStat = this.phase.dpsStats[i];
                                    var dpsTargetStat = [0, 0, 0, 0];
                                    for (
                                        j = 0;
                                        j < this.activetargets.length;
                                        j++
                                    ) {
                                        var tar =
                                            this.phase.dpsStatsTargets[i][
                                                this.activetargets[j]
                                            ];
                                        for (
                                            var k = 0;
                                            k < dpsTargetStat.length;
                                            k++
                                        ) {
                                            dpsTargetStat[k] += tar[k];
                                        }
                                    }
                                    if (!groups[player.group]) {
                                        groups[player.group] = [
                                            0, 0, 0, 0, 0, 0, 0, 0,
                                        ];
                                    }
                                    var dps = dpsTargetStat.concat(dpsStat);
                                    for (j = 0; j < dps.length; j++) {
                                        total[j] += dps[j];
                                        groups[player.group][j] += dps[j];
                                    }
                                    rows.push({
                                        player: player,
                                        dps: dps,
                                    });
                                }
                                for (i = 0; i < groups.length; i++) {
                                    if (groups[i]) {
                                        sums.push({
                                            name: "Group " + i,
                                            dps: groups[i],
                                        });
                                    }
                                }
                                sums.push({
                                    name: "Total",
                                    dps: total,
                                });
                                var res = {
                                    rows: rows,
                                    sums: sums,
                                };
                                this.cacheTarget.set(cacheID, res);
                                return res;
                            },
                            UIIcons: function () {
                                return UIIcons;
                            },
                        },
                    });
                }
                {
                    Vue.component("deathrecap-component", {
                        props: ["playerindex", "phaseindex"],
                        template: `    <div>        <div v-if="recaps">            <div v-for="index in phaseRecaps">                <h3 v-if="phaseRecaps.length > 1" class="text-center">                    Death #{{index + 1}}                </h3>                <div v-if="!recaps[index].toKill">                    <h3 class="text-center">Player was instantly killed after down</h3>                    <div class="text-center">                        Took {{data.totalDamage.down[index]}}                        damage to go into downstate in                        {{data.totalSeconds.down[index]}} seconds                    </div>                </div>                <div v-else-if="!recaps[index].toDown">                    <h3 class="text-center">Player was instantly killed</h3>                    <div class="text-center">                        Took {{data.totalDamage.kill[index]}}                        damage in {{data.totalSeconds.kill[index]}} seconds before                        dying                    </div>                </div>                <div v-else>                    <div class="text-center">                        Took {{data.totalDamage.down[index]}}                        damage to go into downstate in                        {{data.totalSeconds.down[index]}} seconds                    </div>                    <div class="text-center">                        Took {{data.totalDamage.kill[index]}}                        damage in {{data.totalSeconds.kill[index]}} seconds before                        dying afterwards                    </div>                </div>                <graph-component :id="'deathrecap-' + playerindex + '-' + index" :layout="data.layout" :removerangecontrol="true"                    :data="[data.data[index]]"></graph-component>            </div>            <div v-show="phaseRecaps === null || phaseRecaps.length === 0">                <h3 class="text-center">Player has never died during this phase</h3>            </div>        </div>        <div v-else>            <h3 class="text-center">Player has never died</h3>        </div>    </div>`,
                        mixins: [numberComponent],
                        computed: {
                            phase: function () {
                                return logData.phases[this.phaseindex];
                            },
                            recaps: function () {
                                return logData.players[this.playerindex].details
                                    .deathRecap;
                            },
                            data: function () {
                                if (!this.recaps) {
                                    return null;
                                }
                                var res = {
                                    totalSeconds: {
                                        down: [],
                                        kill: [],
                                    },
                                    totalDamage: {
                                        down: [],
                                        kill: [],
                                    },
                                    data: [],
                                    layout: {},
                                };
                                for (var i = 0; i < this.recaps.length; i++) {
                                    var recap = this.recaps[i];
                                    var data = {
                                        y: [],
                                        x: [],
                                        type: "bar",
                                        textposition: "none",
                                        text: [],
                                        hoverinfo: "y+text",
                                        marker: {
                                            color: [],
                                        },
                                    };
                                    var j, totalSec, totalDamage;
                                    if (recap.toDown) {
                                        totalSec =
                                            (recap.toDown[0][0] -
                                                recap.toDown[
                                                    recap.toDown.length - 1
                                                ][0]) /
                                            1000;
                                        totalDamage = 0;
                                        for (
                                            j = recap.toDown.length - 1;
                                            j >= 0;
                                            j--
                                        ) {
                                            totalDamage += recap.toDown[j][2];
                                            data.x.push(
                                                this.round3(
                                                    recap.toDown[j][0] / 1000 -
                                                        this.phase.start
                                                )
                                            );
                                            data.y.push(recap.toDown[j][2]);
                                            data.text.push(
                                                recap.toDown[j][3] +
                                                    " - " +
                                                    findSkill(
                                                        recap.toDown[j][4],
                                                        recap.toDown[j][1]
                                                    ).name
                                            );
                                            data.marker.color.push(
                                                "rgb(0,255,0,1)"
                                            );
                                        }
                                        res.totalSeconds.down[i] = totalSec;
                                        res.totalDamage.down[i] = totalDamage;
                                    }
                                    if (recap.toKill) {
                                        totalSec =
                                            (recap.toKill[0][0] -
                                                recap.toKill[
                                                    recap.toKill.length - 1
                                                ][0]) /
                                            1000;
                                        totalDamage = 0;
                                        for (
                                            j = recap.toKill.length - 1;
                                            j >= 0;
                                            j--
                                        ) {
                                            totalDamage += recap.toKill[j][2];
                                            data.x.push(
                                                this.round3(
                                                    recap.toKill[j][0] / 1000 -
                                                        this.phase.start
                                                )
                                            );
                                            data.y.push(recap.toKill[j][2]);
                                            data.text.push(
                                                recap.toKill[j][3] +
                                                    " - " +
                                                    findSkill(
                                                        recap.toKill[j][4],
                                                        recap.toKill[j][1]
                                                    ).name
                                            );
                                            data.marker.color.push(
                                                recap.toDown
                                                    ? "rgb(255,0,0,1)"
                                                    : "rgb(0,255,0,1)"
                                            );
                                        }
                                        res.totalSeconds.kill[i] = totalSec;
                                        res.totalDamage.kill[i] = totalDamage;
                                    }
                                    res.data.push(data);
                                }
                                res.layout = {
                                    title: "Damage Taken",
                                    font: {
                                        color: "#ffffff",
                                    },
                                    height: 600,
                                    paper_bgcolor: "rgba(0,0,0,0)",
                                    plot_bgcolor: "rgba(0,0,0,0)",
                                    showlegend: false,
                                    bargap: 0.05,
                                    yaxis: {
                                        title: "Damage",
                                        tickformat: ",d",
                                    },
                                    xaxis: {
                                        title: "Time(seconds)",
                                        type: "category",
                                        tickmode: "auto",
                                        nticks: 8,
                                    },
                                };
                                return res;
                            },
                            phaseRecaps: function () {
                                if (!this.recaps) {
                                    return null;
                                }
                                var res = [];
                                for (var i = 0; i < this.recaps.length; i++) {
                                    var time = this.recaps[i].time / 1000.0;
                                    if (
                                        this.phase.start <= time &&
                                        this.phase.end >= time
                                    ) {
                                        res.push(i);
                                    }
                                }
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("defense-stats-component", {
                        props: ["phaseindex", "playerindex"],
                        template: `    <div>        <table class="table table-sm table-striped table-hover" cellspacing="0" width="100%" :id="tableid">            <thead>                <tr>                    <th class="sub-cell" :class="getHeaderClass('Sub')" @click="sortBy('Sub')">                        Sub                    </th>                    <th class="prof-cell" :class="getHeaderClass('Prof')" @click="sortBy('Prof')">                    </th>                    <th class="text-left" :class="getHeaderClass('Name')" @click="sortBy('Name')">                        Name                    </th>                    <th class="text-left" :class="getHeaderClass('Account')" @click="sortBy('Account')">                        Account                    </th>                    <th class="damage-cell" :class="getHeaderClass('Data', 0)" @click="sortBy('Data', 0)"                        data-original-title="Damage taken">                        <img :src="UIIcons.Damage"                            alt="Damage Taken" class="icon icon-hover">                    </th>                    <th class="damage-cell" :class="getHeaderClass('Data', 1)" @click="sortBy('Data', 1)"                        data-original-title="Damage absorbed by barrier">                        <img :src="UIIcons.Barrier"                            alt="Damage Barrier" class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 2)" @click="sortBy('Data', 2)"                        data-original-title="Number of hits missed against">                        <img :src="UIIcons.Miss" alt="Missed"                            class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 3)" @click="sortBy('Data', 3)"                        data-original-title="Number of times interrupted">                        <img :src="UIIcons.Interrupt" alt="Interrupted"                            class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 17)" @click="sortBy('Data', 17)"                        data-original-title="CC">                                          <img :src="UIIcons.CC" alt="CC"                            class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 4)" @click="sortBy('Data', 4)"                        data-original-title="Number of times was invulnerable to damage">                        <img :src="UIIcons.Invul" alt="Invuln"                            class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 5)" @click="sortBy('Data', 5)"                        data-original-title="Number of evades">                        <img :src="UIIcons.Evade" alt="Evaded"                            class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 6)" @click="sortBy('Data', 6)"                        data-original-title="Number of times blocked an attack">                        <img :src="UIIcons.Block" alt="Blocked"                            class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 7)" @click="sortBy('Data', 7)"                        data-original-title="Number of dodge + mirage cloak">                        <img :src="UIIcons.Dodge" alt="Dodge"                            class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 8)" @click="sortBy('Data', 8)"                        data-original-title="Condition Cleanse">                        <img :src="UIIcons.Cleanse" alt="Condition Cleanse"                            class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 10)" @click="sortBy('Data', 10)"                        data-original-title="Boon Strips">                        <img :src="UIIcons.Strip" alt="Boon Strips"                            class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 12)" @click="sortBy('Data', 12)"                        data-original-title="Times downed">                        <img :src="UIIcons.DownedAlly" alt="Downs"                            class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 16)" @click="sortBy('Data', 16)"                        data-original-title="Damage taken while downed">                        <img :src="UIIcons.Damage" alt="Damage"                            class="icon">                            &#8658                        <img :src="UIIcons.DownedAlly"                            alt="Downed"                             class="icon">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 14)" @click="sortBy('Data', 14)"                        data-original-title="Times died">                        <img :src="UIIcons.Dead" alt="Dead"                            class="icon icon-hover">                    </th>                </tr>            </thead>            <tbody>                <tr v-for="row in sortData(tableData.rows)" :class="{active: row.player.id === playerindex}">                    <td :class="getBodyClass('Sub')">                        {{row.player.group}}                    </td>                    <td :class="getBodyClass('Prof')" :data-original-title="row.player.profession">                        <img :src="row.player.icon" :alt="row.player.profession" class="icon"><span                            style="display:none">{{row.player.profession}}</span>                    </td>                    <td :class="getBodyClass('Name')" class="text-left">                        {{row.player.name}}                    </td>                    <td :class="getBodyClass('Account')" class="text-left">                        {{row.player.acc}}                    </td>                    <td :class="getBodyClass('Data', 0)">                        {{row.def[0]}}                    </td>                    <td :class="getBodyClass('Data', 1)">                        {{row.def[1]}}                    </td>                    <td :class="getBodyClass('Data', 2)">                        {{row.def[2]}}                    </td>                    <td :class="getBodyClass('Data', 3)">                        {{row.def[3]}}                    </td>                    <td :class="getBodyClass('Data', 17)" :data-original-title="round3(row.def[18]/1000) + ' seconds'">                        {{row.def[17]}}                    </td>                    <td :class="getBodyClass('Data', 4)">                        {{row.def[4]}}                    </td>                    <td :class="getBodyClass('Data', 5)">                        {{row.def[5]}}                    </td>                    <td :class="getBodyClass('Data', 6)">                        {{row.def[6]}}                    </td>                    <td :class="getBodyClass('Data', 7)">                        {{row.def[7]}}                    </td>                    <td :class="getBodyClass('Data', 8)" :data-original-title="row.def[9] + ' seconds'">                        {{row.def[8]}}                    </td>                    <td :class="getBodyClass('Data', 10)" :data-original-title="row.def[11] + ' seconds'">                        {{row.def[10]}}                    </td>                    <td :class="getBodyClass('Data', 12)" :data-original-title="row.def[13]">                        {{row.def[12]}}                    </td>                    <td :class="getBodyClass('Data', 16)">                        {{row.def[16]}}                    </td>                    <td :class="getBodyClass('Data', 14)" :data-original-title="row.def[15]">                        {{row.def[14]}}                    </td>                </tr>            </tbody>            <tfoot>                <tr v-for="sum in tableData.sums">                    <td></td>                    <td></td>                    <td class="text-left">{{sum.name}}</td>                    <td></td>                    <td>{{sum.def[0]}}</td>                    <td>{{sum.def[1]}}</td>                    <td>{{sum.def[2]}}</td>                    <td>{{sum.def[3]}}</td>                    <td>{{sum.def[17]}}</td>                    <td>{{sum.def[4]}}</td>                    <td>{{sum.def[5]}}</td>                    <td>{{sum.def[6]}}</td>                    <td>{{sum.def[7]}}</td>                    <td>{{sum.def[8]}}</td>                    <td>{{sum.def[10]}}</td>                    <td>{{sum.def[12]}}</td>                    <td>{{sum.def[16]}}</td>                    <td>{{sum.def[14]}}</td>                </tr>            </tfoot>        </table>    </div>`,
                        mixins: [
                            numberComponent,
                            sortedTableComponent,
                            encounterPhaseComponent,
                        ],
                        data: function () {
                            return {
                                cache: new Map(),
                                sortdata: {
                                    order: "desc",
                                    index: 0,
                                    key: "Data",
                                },
                            };
                        },
                        methods: {
                            sortBy: function (key, index) {
                                this.sortByBase(this.sortdata, key, index);
                            },
                            getHeaderClass: function (key, index) {
                                return this.getHeaderClassBase(
                                    this.sortdata,
                                    key,
                                    index
                                );
                            },
                            getBodyClass: function (key, index) {
                                var classes = this.getBodyClassBase(
                                    this.sortdata,
                                    key,
                                    index
                                );
                                return classes;
                            },
                            sortData: function (rows) {
                                var order =
                                    this.sortdata.order === "asc" ? 1 : -1;
                                switch (this.sortdata.key) {
                                    case "Sub":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    (x.player.group -
                                                        y.player.group) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Prof":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    this.sortByPlayerProfession(
                                                        x,
                                                        y
                                                    ) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Name":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Account":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                this.sortByPlayerAccount(x, y)
                                        );
                                        break;
                                    case "Data":
                                        var index = this.sortdata.index;
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    (x.def[index] -
                                                        y.def[index]) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    default:
                                        return null;
                                        break;
                                }
                                return rows;
                            },
                        },
                        computed: {
                            tableid: function () {
                                return "def-table";
                            },
                            phase: function () {
                                return logData.phases[this.phaseindex];
                            },
                            tableData: function () {
                                const cacheID =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex;
                                if (this.cache.has(cacheID)) {
                                    return this.cache.get(cacheID);
                                }
                                const dataLength =
                                    this.phase.defStats[0].length;
                                var rows = [];
                                var sums = [];
                                var total = new Array(dataLength).fill(0);
                                var groups = [];
                                const players = getActiveNonFakePlayersForPhase(
                                    this.encounterPhase
                                );
                                for (
                                    var i = 0;
                                    i < this.phase.defStats.length;
                                    i++
                                ) {
                                    var def = this.phase.defStats[i];
                                    var player = players[i];
                                    if (!player) {
                                        continue;
                                    }
                                    rows.push({
                                        player: player,
                                        def: def,
                                    });
                                    if (!groups[player.group]) {
                                        groups[player.group] = new Array(
                                            dataLength
                                        ).fill(0);
                                    }
                                    for (var j = 0; j < def.length; j++) {
                                        if (typeof def[j] === "string") {
                                            continue;
                                        }
                                        total[j] += def[j];
                                        groups[player.group][j] += def[j];
                                    }
                                }
                                for (var i = 0; i < groups.length; i++) {
                                    if (groups[i]) {
                                        sums.push({
                                            name: "Group " + i,
                                            def: groups[i],
                                        });
                                    }
                                }
                                sums.push({
                                    name: "Total",
                                    def: total,
                                });
                                var res = {
                                    rows: rows,
                                    sums: sums,
                                };
                                this.cache.set(cacheID, res);
                                return res;
                            },
                            UIIcons: function () {
                                return UIIcons;
                            },
                        },
                    });
                }
                {
                    Vue.component("encounter-component", {
                        props: ["light", "encounters"],
                        template: `    <div class="card fight-summary" style="min-width: 350px;">        <h3 v-if="isMultiEncounterLog" class="card-header text-center" >            <a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Select Encounter">                <div :style="getMinWidth()">{{ encounterData.nameNoMode }}</div>                <span class="caret"></span>            </a>            <ul class="dropdown-menu p-2 font-weight-normal scrollabledropdown" :style="getMinWidth()" style="max-height: 500px;">                <li v-for="(encounterData, index) in encountersData" :key="index" :style="index === 0 ? {'border-bottom': '2px solid #bbb;'} : ''">                   <a @click="select(index)" @click.stop="stopClickEvent" href="#" class="dropdown-item"                        style="font-size: 1.0em; text-overflow: ellipsis; overflow: hidden; white-space: nowrap;">                                 <img class="icon-ll" :src="encounterData.icon">                        {{encounterData.name}}                    </a>                </li>            </ul>        </h3>        <h3 v-if="!isMultiEncounterLog" class="card-header text-center">            {{ encounterData.nameNoMode }}        </h3>        <h7 class="card-header-fightMode text-center" v-if="!!encounterData.mode" :class="fightModeColorClass(encounterData.mode)">{{ encounterData.mode }}</h7>        <div class="card-body card-body-encounter container">            <div class="d-flex flex-row justify-content-center align-items-center">                <div class="d-flex flex-column mr-3 justify-content-center">                    <div v-if="encounterData.instanceBuffs" class="d-flex flex-row justify-content-around mb-1">                        <span v-for="instanceBuff in encounterData.instanceBuffs">                            {{instanceBuff.stack > 1 ? instanceBuff.stack + ' x' : ''}}                            <img :data-original-title="instanceBuff.buff.name + (instanceBuff.buff.description ? '<br> ' + instanceBuff.buff.description : '')"                                 :src="instanceBuff.buff.icon" class="icon icon-hover" />                        </span>                    </div>                    <img class="encounter-icon" :src="encounterData.icon" :alt="encounterData.nameNoMode">                </div>                <div class="ml-1 d-flex flex-column justify-content-center">                    <div v-if="!encounterData.hideTargets" class="mb-1" v-for="target in encounterData.targets">                        <div class="small" style="text-align:center;">                            {{target.name}}                        </div>                        <div :data-original-title="healthRemaining(target)">                            <div class="healthBar" :style="{'background': getGradient(target)}">                            </div>                            <div v-if="target.health > 0" class="super-small" style="text-align: center;">                                {{ targetHealthValues(target) }}                            </div>                        </div>                    </div>                    <div v-if="encounterData.hideTargets" class="mb-1">                        <div>Players: {{ encounterData.playerCount }}</div>                        <div>Friendlies: {{ encounterData.nonSquadFriendlyCount }}</div>                        <div>Enemies: {{ encounterData.targetCount }}</div>                    </div>                    <div class="mb-2 mt-2">Duration: {{ encounterData.duration }}</div>                    <div class="mb-2" v-if="fractalScale > 0">Fractal Scale: {{ fractalScale }}</div>                    <div class="mb-2" v-if="!!instancePrivacy">{{ instancePrivacy }}</div>                    <div class="mb-2 text-warning" v-if="encounterData.start"> {{ encounterData.start }}</div>                    <div v-if="!encounterData.hideResult" class="text" :class="resultStatus.class">                        Result: {{resultStatus.text}}                    </div>                </div>            </div>        </div>    </div>`,
                        data: function () {
                            return {
                                isMultiEncounterLog: IsMultiEncounterLog,
                            };
                        },
                        methods: {
                            getMinWidth: function () {
                                let width = 0;
                                for (
                                    let i = 0;
                                    i < this.encountersData.length;
                                    i++
                                ) {
                                    width = Math.max(
                                        this.encountersData[i].nameNoMode
                                            .length * 13,
                                        width
                                    );
                                }
                                width += 40;
                                return {
                                    "min-width": width + "px",
                                };
                            },
                            stopClickEvent: function (event) {
                                event.stopPropagation();
                            },
                            select: function (encounterIndex) {
                                for (
                                    let i = 0;
                                    i < this.encounters.length;
                                    i++
                                ) {
                                    this.encounters[i].active = false;
                                }
                                this.encounters[encounterIndex].active = true;
                                const index =
                                    reactiveLogdata.activeEncounterPhaseData[
                                        encounterIndex
                                    ].phase;
                                // Select phase
                                for (
                                    var i = 0;
                                    i < reactiveLogdata.phases.length;
                                    i++
                                ) {
                                    reactiveLogdata.phases[i].active = false;
                                }
                                reactiveLogdata.phases[index].active = true;
                                // Select an appropriate player
                                const encounterPhase =
                                    logData.phases[
                                        this.encounters[encounterIndex].index
                                    ];
                                const players =
                                    getActiveNonFakePlayersForPhase(
                                        encounterPhase
                                    );
                                let selectedPlayerIndex =
                                    reactiveLogdata.activeEncounterPhaseData[
                                        encounterIndex
                                    ].player;
                                for (
                                    let i = 0;
                                    i < reactiveLogdata.players.length;
                                    i++
                                ) {
                                    reactiveLogdata.players[i].active = false;
                                }
                                if (players[selectedPlayerIndex]) {
                                    reactiveLogdata.players[
                                        selectedPlayerIndex
                                    ].active = true;
                                } else {
                                    const originalPlayer =
                                        logData.players[selectedPlayerIndex];
                                    selectedPlayerIndex = -1;
                                    // Look for the same player that is active in that encounter
                                    for (
                                        let i = 0;
                                        i < logData.players.length;
                                        i++
                                    ) {
                                        const curPlayer = logData.players[i];
                                        if (
                                            curPlayer.acc ===
                                                originalPlayer.acc &&
                                            players[i]
                                        ) {
                                            selectedPlayerIndex = i;
                                            break;
                                        }
                                    }
                                    if (selectedPlayerIndex >= 0) {
                                        reactiveLogdata.players[
                                            selectedPlayerIndex
                                        ].active = true;
                                    } else {
                                        // Default to pov player active in that encounter
                                        for (
                                            let i = 0;
                                            i < logData.players.length;
                                            i++
                                        ) {
                                            const curPlayer =
                                                logData.players[i];
                                            if (curPlayer.isPoV && players[i]) {
                                                selectedPlayerIndex = i;
                                                break;
                                            }
                                        }
                                        reactiveLogdata.players[
                                            selectedPlayerIndex
                                        ].active = true;
                                    }
                                    reactiveLogdata.activeEncounterPhaseData[
                                        encounterIndex
                                    ].player = selectedPlayerIndex;
                                }
                            },
                            getGradient: function (target) {
                                var hpLeftPercent = target.hpLeftPercent;
                                var healthAndBarrier =
                                    hpLeftPercent + target.barrierLeftPercent;
                                if (healthAndBarrier > 100) {
                                    // So that barrier remains fully visible like in game
                                    hpLeftPercent -= healthAndBarrier - 100;
                                    healthAndBarrier = 100;
                                }
                                var red = "red " + hpLeftPercent + "%";
                                var yellow =
                                    "yellow " +
                                    hpLeftPercent +
                                    "% " +
                                    healthAndBarrier +
                                    "%";
                                var green = "green " + healthAndBarrier + "%";
                                var template = `linear-gradient(to right, ${red}, ${yellow}, ${green})`;
                                return template;
                            },
                            healthRemaining: function (target) {
                                var hpLeft = target.hpLeft;
                                var barrierLeft = target.barrierLeft;
                                if (hpLeft > 0 && barrierLeft > 0) {
                                    return (
                                        "Remaining:<br>Health: " +
                                        hpLeft +
                                        "<br>Barrier: " +
                                        barrierLeft
                                    );
                                } else if (hpLeft > 0 && barrierLeft == 0) {
                                    return "Remaining:<br>Health: " + hpLeft;
                                } else if (barrierLeft > 0) {
                                    return (
                                        "Remaining:<br>Barrier: " + barrierLeft
                                    );
                                }
                                return false;
                            },
                            targetHealthValues: function (target) {
                                var health = target.health;
                                var hpLeft = target.hpLeftPercent;
                                var barrierLeft = target.barrierLeftPercent;
                                if (
                                    (hpLeft > 0 && barrierLeft > 0) ||
                                    (hpLeft == 0 && barrierLeft > 0)
                                ) {
                                    // If only barrier is left, show 0 + x.y barrier
                                    return (
                                        health +
                                        " HP (" +
                                        hpLeft +
                                        "% + " +
                                        barrierLeft +
                                        "%)"
                                    );
                                } else if (hpLeft > 0 && barrierLeft == 0) {
                                    return health + " HP (" + hpLeft + "%)";
                                }
                                return health + " HP";
                            },
                            fightModeColorClass: function (mode) {
                                switch (mode) {
                                    case "Unknown":
                                        return {
                                            "fightModeUnknown-light":
                                                this.light,
                                            "fightModeUnknown-dark":
                                                !this.light,
                                        };
                                        break;
                                    case "Story Mode":
                                        return {
                                            "fightModeStory-light": this.light,
                                            "fightModeStory-dark": !this.light,
                                        };
                                        break;
                                    case "Quickplay Normal Mode":
                                        return {
                                            "fightModeQuickplay-light":
                                                this.light,
                                            "fightModeQuickplay-dark":
                                                !this.light,
                                        };
                                        break;
                                    case "Emboldened Normal Mode":
                                        return {
                                            "fightModeEmboldened-light":
                                                this.light,
                                            "fightModeEmboldened-dark":
                                                !this.light,
                                        };
                                        break;
                                    case "Normal Mode":
                                        return {
                                            "fightModeNormal-light": this.light,
                                            "fightModeNormal-dark": !this.light,
                                        };
                                        break;
                                    case "Challenge Mode":
                                        return {
                                            "fightModeChallenge-light":
                                                this.light,
                                            "fightModeChallenge-dark":
                                                !this.light,
                                        };
                                        break;
                                    case "Legendary Challenge Mode":
                                        return {
                                            "fightModeLegendary-light":
                                                this.light,
                                            "fightModeLegendary-dark":
                                                !this.light,
                                        };
                                        break;
                                    default:
                                        break;
                                }
                                return;
                            },
                        },
                        computed: {
                            encountersData: function () {
                                let res = [];
                                for (
                                    let j = 0;
                                    j < logData.phases.length;
                                    j++
                                ) {
                                    const phase = logData.phases[j];
                                    if (
                                        phase.type === PhaseTypes.SUBPHASE ||
                                        phase.type === PhaseTypes.TIMEFRAME
                                    ) {
                                        continue;
                                    }
                                    const targets = [];
                                    const noTargets = logData.targetless;
                                    let targetCount = 0;
                                    let presentAccounts = new Set();
                                    for (
                                        let i = 0;
                                        i < phase.targets.length;
                                        i++
                                    ) {
                                        if (phase.targetPriorities[i] > 0) {
                                            continue;
                                        }
                                        targetCount++;
                                        if (!noTargets && targets.length < 10) {
                                            const targetIndex =
                                                phase.targets[i];
                                            const targetData =
                                                logData.targets[targetIndex];
                                            targets.push(targetData);
                                        }
                                    }
                                    const hideTargets =
                                        logData.wvw ||
                                        (phase.type === PhaseTypes.INSTANCE &&
                                            this.isMultiEncounterLog);
                                    const players =
                                        getActiveNonFakePlayersForPhase(phase);
                                    const squadPlayers = players.filter(
                                        (x) => x && !x.notInSquad
                                    );
                                    const nonSquadFriendlies = players.filter(
                                        (x) => x && x.notInSquad
                                    );
                                    const encounter = {
                                        nameNoMode:
                                            phase == logData.phases[0]
                                                ? logData.logName
                                                : phase.nameNoMode,
                                        name:
                                            phase == logData.phases[0]
                                                ? logData.logName
                                                : phase.name,
                                        success: phase.success,
                                        icon: phase.icon,
                                        duration: phase.encounterDuration,
                                        targets: targets,
                                        targetCount: targetCount,
                                        playerCount: squadPlayers.filter(
                                            (x) => {
                                                if (
                                                    presentAccounts.has(x.acc)
                                                ) {
                                                    return false;
                                                }
                                                presentAccounts.add(x.acc);
                                                return true;
                                            }
                                        ).length,
                                        nonSquadFriendlyCount:
                                            nonSquadFriendlies.length,
                                        mode: phase.mode,
                                        start: phase.startStatus,
                                        hideTargets: hideTargets,
                                        hideResult: hideTargets,
                                        instanceBuffs: null,
                                    };
                                    if (logData.instanceBuffs.length > 0) {
                                        const res = [];
                                        for (
                                            let i = 0;
                                            i < logData.instanceBuffs.length;
                                            i++
                                        ) {
                                            const cur =
                                                logData.instanceBuffs[i];
                                            if (
                                                cur[2] <= phase.start &&
                                                cur[3] >= phase.end
                                            ) {
                                                res.push({
                                                    buff: findSkill(
                                                        true,
                                                        cur[0]
                                                    ),
                                                    stack: cur[1],
                                                });
                                            }
                                        }
                                        if (res.length > 0) {
                                            encounter.instanceBuffs = res;
                                        }
                                    }
                                    res.push(encounter);
                                }
                                return res;
                            },
                            encounterData: function () {
                                for (
                                    let i = 0;
                                    i < this.encounters.length;
                                    i++
                                ) {
                                    const encounter = this.encounters[i];
                                    if (encounter.active) {
                                        return this.encountersData[i];
                                    }
                                }
                                return this.encountersData[0];
                            },
                            fractalScale: function () {
                                return logData.fractalScale;
                            },
                            instancePrivacy: function () {
                                return logData.instancePrivacy;
                            },
                            resultStatus: function () {
                                return this.encounterData.success
                                    ? {
                                          text: "Success",
                                          class: ["text-success"],
                                      }
                                    : {
                                          text: "Failure",
                                          class: ["text-danger"],
                                      };
                            },
                        },
                    });
                }
                {
                    Vue.component("food-component", {
                        props: ["phaseindex", "playerindex"],
                        template: `    <div class="mt-2">        <div v-if="data.start.length">            Started with:            <ul>                <li v-for="initial in data.start">                    {{initial.name}} <img class="icon" :alt="initial.name" :data-original-title="initial.description"                        :src="initial.icon">                    {{initial.stack > 1 ? "("+initial.stack+")" : ""}} ({{round3(initial.duration)}}                    seconds remaining)                </li>            </ul>        </div>        <div v-if="data.refreshed.length">            In phase consumable updates:            <ul>                <li v-for="refresh in data.refreshed">                    {{refresh.dimished ? 'suffered' : 'consumed'}} {{refresh.name}}                    <img class="icon" :alt="refresh.name" :data-original-title="refresh.description"                        :src="refresh.icon">                    {{refresh.stack > 1 ? "("+refresh.stack+")" : ""}}                    at {{round3(refresh.time)}}s ({{round3(refresh.duration)}}                    seconds)                </li>            </ul>        </div>        <div v-if="!data.refreshed.length && !data.start.length" class="text-center">            <h3>No consumable activity</h3>        </div>    </div>`,
                        data: function () {
                            return {
                                cache: new Map(),
                            };
                        },
                        mixins: [numberComponent],
                        computed: {
                            phase: function () {
                                return logData.phases[this.phaseindex];
                            },
                            food: function () {
                                return logData.players[this.playerindex].details
                                    .food;
                            },
                            data: function () {
                                if (this.cache.has(this.phase)) {
                                    return this.cache.get(this.phase);
                                }
                                const res = {
                                    start: [],
                                    refreshed: [],
                                };

                                const encounteredStartIDs = new Set();
                                const encounteredStartUniqueSlots = new Set();

                                for (
                                    let k = this.food.length - 1;
                                    k >= 0;
                                    k--
                                ) {
                                    const foodData = this.food[k];
                                    if (!foodData.name) {
                                        var skill = findSkill(
                                            true,
                                            foodData.id
                                        );
                                        foodData.name = skill.name;
                                        foodData.icon = skill.icon;
                                        foodData.description =
                                            skill.description;
                                    }
                                    let phaseFood = {};
                                    Object.assign(phaseFood, foodData);
                                    if (
                                        phaseFood.time <= this.phase.start &&
                                        phaseFood.time + phaseFood.duration >=
                                            this.phase.start
                                    ) {
                                        if (
                                            encounteredStartIDs.has(foodData.id)
                                        ) {
                                            continue;
                                        }
                                        if (
                                            foodData.uniqueSlot > 0 &&
                                            encounteredStartUniqueSlots.has(
                                                foodData.uniqueSlot
                                            )
                                        ) {
                                            continue;
                                        }
                                        encounteredStartIDs.add(foodData.id);
                                        encounteredStartUniqueSlots.add(
                                            foodData.uniqueSlot
                                        );
                                        phaseFood.duration -=
                                            this.phase.start - phaseFood.time;
                                        phaseFood.time = this.phase.start;
                                        res.start.push(phaseFood);
                                    } else if (
                                        phaseFood.time >= this.phase.start &&
                                        phaseFood.time <= this.phase.end
                                    ) {
                                        phaseFood.time -= this.phase.start;
                                        res.refreshed.push(phaseFood);
                                    }
                                }
                                res.start.sort((x, y) => x.time - y.time);
                                res.refreshed.sort((x, y) => x.time - y.time);
                                this.cache.set(this.phase, res);
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("gameplay-stats-component", {
                        props: ["playerindex", "phaseindex"],
                        template: `    <div>        <table class="table table-sm table-striped table-hover" cellspacing="0" width="100%" :id="tableid">            <thead>                <tr>                    <th class="sub-cell" :class="getHeaderClass('Sub')" @click="sortBy('Sub')">                        Sub                    </th>                    <th class="prof-cell" :class="getHeaderClass('Prof')" @click="sortBy('Prof')">                    </th>                    <th class="text-left" :class="getHeaderClass('Name')" @click="sortBy('Name')">                        Name                    </th>                    <th class="text-left" :class="getHeaderClass('Account')" @click="sortBy('Account')">                        Account                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 0)" @click="sortBy('Data', 0)"                        data-original-title="Time wasted(in seconds) interupting skill casts">                        <img :src="UIIcons.TimeWasted" alt="Wasted"                            class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 2)" @click="sortBy('Data', 2)"                        data-original-title="Time saved(in seconds) interupting skill casts">                        <img :src="UIIcons.TimeSaved" alt="Saved"                            class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 4)" @click="sortBy('Data', 4)"                        data-original-title="Times weapon swapped">                        <img :src="UIIcons.WeaponSwap" alt="Swap"                            class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 7)" @click="sortBy('Data', 7)"                        data-original-title="% of time in combat spent in animation">                        <img :src="UIIcons.Activation" alt="Animation" class="icon">                        /                        <img src="https://wiki.guildwars2.com/images/9/92/Arena_Proprietor.png" alt="Combat"                            class="icon">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 8)" @click="sortBy('Data', 8)"                        data-original-title="% of time in combat spent in animation, excluding auto attack skills">                        (<img :src="UIIcons.Activation" alt="Animation" class="icon">                        - <img src="https://wiki.guildwars2.com/images/a/a1/Hammer_Marker_Yellow.png" alt="Auto attack"                            class="icon">)                        /                        <img src="https://wiki.guildwars2.com/images/9/92/Arena_Proprietor.png" alt="Combat"                            class="icon">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 5)" @click="sortBy('Data', 5)"                        data-original-title="Average Distance to the center of the squad">                        <img src="https://wiki.guildwars2.com/images/e/ef/Commander_arrow_marker.png" alt="Stack Center"                            class="icon icon-hover">                    </th>                    <th class="stat-cell" v-if="hasCommander" :class="getHeaderClass('Data', 6)"                        @click="sortBy('Data', 6)" data-original-title="Average Distance to the commander">                        <img :src="UIIcons.Commander"                            alt="Stack Commander" class="icon icon-hover">                    </th>                </tr>            </thead>            <tbody>                <tr v-for="row in sortData(tableData.rows)" :class="{active: row.player.id === playerindex}">                    <td :class="getBodyClass('Sub')">                        {{row.player.group}}                    </td>                    <td :class="getBodyClass('Prof')" :data-original-title="row.player.profession">                        <img :src="row.player.icon" :alt="row.player.profession" class="icon"><span                            style="display:none">{{row.player.profession}}</span>                    </td>                    <td :class="getBodyClass('Name')" class="text-left">                        {{row.player.name}}                    </td>                    <td :class="getBodyClass('Account')" class="text-left">                        {{row.player.acc}}                    </td>                    <td :class="getBodyClass('Data', 0)"                        :data-original-title="row.commons[1] + ' cancels <br>' + round2(100.0 * row.commons[0] / phase.durationS) + '% of the phase'">                        {{row.commons[0]}}                    </td>                    <td :class="getBodyClass('Data', 2)"                        :data-original-title="row.commons[3] + ' cancels <br>' + round2(100.0 * row.commons[2] / phase.durationS) + '% of the phase'">                        {{row.commons[2]}}                    </td>                    <td :class="getBodyClass('Data', 4)">                        {{row.commons[4]}}                    </td>                    <td :class="getBodyClass('Data', 7)">                        {{row.commons[7]}}%                    </td>                    <td :class="getBodyClass('Data', 8)">                        {{row.commons[8]}}%                    </td>                    <td :class="getBodyClass('Data', 5)">                        {{row.commons[5]}}                    </td>                    <td :class="getBodyClass('Data', 6)" v-if="hasCommander">                        {{row.commons[6]}}                    </td>                </tr>            </tbody>            <tfoot>                <tr v-for="row in tableData.sums">                    <td></td>                    <td></td>                    <td class="text-left">{{row.name}}</td>                    <td></td>                    <td :data-original-title="row.commons[1] + ' cancels'">{{round3(row.commons[0])}}</td>                    <td :data-original-title="row.commons[3] + ' cancels'">{{round3(row.commons[2])}}</td>                    <td>{{row.commons[4]}}</td>                    <td></td>                    <td></td>                    <td>{{round2(row.commons[5] / row.count)}}</td>                    <td v-if="hasCommander">{{round2(row.commons[6] / row.count)}}</td>                </tr>            </tfoot>        </table>    </div>`,
                        mixins: [
                            numberComponent,
                            sortedTableComponent,
                            encounterPhaseComponent,
                        ],
                        data: function () {
                            return {
                                hasCommander: logData.hasCommander,
                                cache: new Map(),
                                sortdata: {
                                    order: "desc",
                                    index: -1,
                                    key: "Prof",
                                },
                            };
                        },
                        methods: {
                            sortBy: function (key, index) {
                                this.sortByBase(this.sortdata, key, index);
                            },
                            getHeaderClass: function (key, index) {
                                return this.getHeaderClassBase(
                                    this.sortdata,
                                    key,
                                    index
                                );
                            },
                            getBodyClass: function (key, index) {
                                var classes = this.getBodyClassBase(
                                    this.sortdata,
                                    key,
                                    index
                                );
                                return classes;
                            },
                            sortData: function (rows) {
                                var order =
                                    this.sortdata.order === "asc" ? 1 : -1;
                                switch (this.sortdata.key) {
                                    case "Sub":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    (x.player.group -
                                                        y.player.group) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Prof":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    this.sortByPlayerProfession(
                                                        x,
                                                        y
                                                    ) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Name":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Account":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                this.sortByPlayerAccount(x, y)
                                        );
                                        break;
                                    case "Data":
                                        var index = this.sortdata.index;
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    (x.commons[index] -
                                                        y.commons[index]) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    default:
                                        return null;
                                        break;
                                }
                                return rows;
                            },
                        },
                        computed: {
                            tableid: function () {
                                return "gameplay-table";
                            },
                            phase: function () {
                                return logData.phases[this.phaseindex];
                            },
                            tableData: function () {
                                const cacheID =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex;
                                if (this.cache.has(cacheID)) {
                                    return this.cache.get(cacheID);
                                }
                                var rows = [];
                                var sums = [];
                                var groups = [];
                                var total = {
                                    name: "Total",
                                    commons: [],
                                    count: 0,
                                };
                                const players = getActiveNonFakePlayersForPhase(
                                    this.encounterPhase
                                );
                                for (
                                    var i = 0;
                                    i < this.phase.gameplayStats.length;
                                    i++
                                ) {
                                    var commons = [];
                                    var player = players[i];
                                    if (!player) {
                                        continue;
                                    }
                                    if (!groups[player.group]) {
                                        groups[player.group] = {
                                            name: "Group " + player.group,
                                            commons: [],
                                            count: 0,
                                        };
                                    }
                                    groups[player.group].count++;
                                    total.count++;
                                    var stats = this.phase.gameplayStats[i];
                                    for (var j = 0; j < stats.length; j++) {
                                        commons[j] = stats[j];
                                        groups[player.group].commons[j] =
                                            (groups[player.group].commons[j] ||
                                                0) + commons[j];
                                        total.commons[j] =
                                            (total.commons[j] || 0) +
                                            commons[j];
                                    }
                                    rows.push({
                                        player: player,
                                        commons: commons,
                                    });
                                }
                                for (var i = 0; i < groups.length; i++) {
                                    if (groups[i]) {
                                        sums.push(groups[i]);
                                    }
                                }
                                sums.push(total);
                                var res = {
                                    rows: rows,
                                    sums: sums,
                                };
                                this.cache.set(cacheID, res);
                                return res;
                            },
                            UIIcons: function () {
                                return UIIcons;
                            },
                        },
                    });
                }
                {
                    Vue.component("offensive-stats-component", {
                        props: ["activetargets", "playerindex", "phaseindex"],
                        template: `    <div>        <div v-if="!targetless" class="d-flex flex-row justify-content-center mt-1 mb-1">            <ul class="nav nav-pills scale85">                <li class="nav-item">                    <a class="nav-link" @click="mode = 1" data-original-title="Against selected target(s)."                       :class="{active: mode}">Target</a>                </li>                <li class="nav-item">                    <a class="nav-link" @click="mode = 0" data-original-title="Against all enemies."                       :class="{active: !mode }">All</a>                </li>            </ul>        </div>        <table class="table table-sm table-striped table-hover" cellspacing="0" width="100%" :id="tableid">            <thead>                <tr>                    <th class="sub-cell" :class="getHeaderClass('Sub')" @click="sortBy('Sub')">                        Sub                    </th>                    <th class="prof-cell" :class="getHeaderClass('Prof')" @click="sortBy('Prof')">                    </th>                    <th class="text-left" :class="getHeaderClass('Name')" @click="sortBy('Name')">                        Name                    </th>                    <th class="text-left" :class="getHeaderClass('Account')" @click="sortBy('Account')">                        Account                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 2)" @click="sortBy('Data', 2, 1)"                        data-original-title="Percent time hits critical">                        <img :src="UIIcons.Crit" alt="Crits"                             class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 4)" @click="sortBy('Data', 4, 11)"                        data-original-title="Percent time hits while flanking">                        <img :src="UIIcons.Flank" alt="Flank"                             class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 21)" @click="sortBy('Data', 21, 20)"                        data-original-title="Percent time power hits while self above 90% hp">                        <img :src="UIIcons.Power" alt="Power"                             class="icon"> > 90%                    </th>                        <th class="stat-cell" :class="getHeaderClass('Data', 23)" @click="sortBy('Data', 23, 22)"                        data-original-title="Percent time condition ticks while self above 90% hp">                        <img :src="UIIcons.ConditionDamage" alt="Condition"                             class="icon"> > 90%                    </th>                        <th class="stat-cell" :class="getHeaderClass('Data', 5)" @click="sortBy('Data', 5, 11)"                        data-original-title="Percent time hits while glancing">                        <img :src="UIIcons.Glance" alt="Glance"                             class="icon icon-hover">                    </th>                        <th class="stat-cell" :class="getHeaderClass('Data', 14)" @click="sortBy('Data', 14, 15)"                        data-original-title="Times the target got hit while moving">                        <img :src="UIIcons.AgainstMoving" alt="Against Moving"                             class="icon icon-hover">                    </th>                      <th class="stat-cell" :class="getHeaderClass('Data', 6)" @click="sortBy('Data', 6)"                        data-original-title="Number of hits while blinded">                        <img :src="UIIcons.Miss" alt="Miss"                             class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 7)" @click="sortBy('Data', 7)"                        data-original-title="Number of hits used to interupt">                        <img :src="UIIcons.Interrupt" alt="Interrupts"                                             class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 27)" @click="sortBy('Data', 27)"                        data-original-title="CC">                        <img :src="UIIcons.CC" alt="CC"                             class="icon icon-hover">                    </th>                     <th class="stat-cell" :class="getHeaderClass('Data', 8)" @click="sortBy('Data', 8)"                        data-original-title="Times the enemy was invulnerable to attacks">                        <img :src="UIIcons.Invul" alt="Invuln"                             class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 9)" @click="sortBy('Data', 9)"                        data-original-title="Times the enemy evaded an attack">                        <img :src="UIIcons.Evade" alt="Evaded"                             class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 10)" @click="sortBy('Data', 10)"                        data-original-title="Times the enemy blocked an attack">                        <img :src="UIIcons.Block" alt="Blocked"                             class="icon icon-hover">                    </th>                         <th class="stat-cell" v-if="wvw" :class="getHeaderClass('Data', 17)" @click="sortBy('Data', 17)"                        data-original-title="Down Contribution">                         <img :src="UIIcons.Damage" alt="Damage"                            class="icon">                        /                        <img :src="UIIcons.DownedEnemy" alt="Down"                            class="icon">                    </th>                              <th class="stat-cell" v-if="wvw" :class="getHeaderClass('Data', 13)" @click="sortBy('Data', 13)"                        data-original-title="Number of times downed target">                        <img :src="UIIcons.DownedEnemy"                            alt="Downed"                             class="icon icon-hover">                    </th>                       <th class="stat-cell" v-if="wvw" :class="getHeaderClass('Data', 25)" @click="sortBy('Data', 25)"                        data-original-title="Damage against downed target">                        <img :src="UIIcons.Damage" alt="Damage"                            class="icon">                            &#8658                        <img :src="UIIcons.DownedEnemy"                            alt="Downed"                             class="icon">                    </th>                               <th class="stat-cell" v-if="wvw" :class="getHeaderClass('Data', 12)" @click="sortBy('Data', 12)"                        data-original-title="Number of times killed target">                        <img :src="UIIcons.Dead"                            alt="Killed"                             class="icon icon-hover">                    </th>                      </tr>            </thead>            <tbody>                <tr v-for="row in sortData(mode ? tableDataTarget.rows : tableData.rows)"                    :class="{active: row.player.id === playerindex}">                    <td :class="getBodyClass('Sub')">                        {{row.player.group}}                    </td>                    <td :class="getBodyClass('Prof')"                        :data-original-title="row.player.profession">                        <img :src="row.player.icon" :alt="row.player.profession" class="icon"><span                            style="display:none">{{row.player.profession}}</span>                    </td>                    <td :class="getBodyClass('Name')" class="text-left">                        {{row.player.name}}                    </td>                    <td :class="getBodyClass('Account')" class="text-left" >                        {{row.player.acc}}                    </td>                    <td :class="getBodyClass('Data', 2)"                        :data-original-title="row.data[2] + ' out of ' + row.data[1] + ' critable hit(s)' +                                    '<br>Total Critical Damage: ' + row.data[3] +                                    '<br>' + round2(100*row.data[3]/ row.data[18]) +'% of total damage' +                                    '<br>' + round2(100*row.data[3]/ row.data[19]) +'% of total direct damage'">                        {{round2(100*row.data[2] / row.data[1])}}%                    </td>                    <td :class="getBodyClass('Data', 4)"                        :data-original-title="row.data[4] + ' out of ' + row.data[11] + ' connected direct hit(s)'">                        {{round2(100*row.data[4]/ row.data[11])}}%                    </td>                    <td :class="getBodyClass('Data', 21)"                        :data-original-title="row.data[21] + ' out of ' + row.data[20] + ' connected power hit(s)'">                        {{round2(100*row.data[21]/ row.data[20])}}%                    </td>                    <td :class="getBodyClass('Data', 23)"                        :data-original-title="row.data[23] + ' out of ' + row.data[22] + ' connected condition tick(s)'">                        {{round2(100*row.data[23]/ row.data[22])}}%                    </td>                    <td :class="getBodyClass('Data', 5)"                        :data-original-title="row.data[5] + ' out of ' + row.data[11] + ' connected direct hit(s)'">                        {{round2(100*row.data[5]/ row.data[11])}}%                    </td>                    <td :class="getBodyClass('Data', 14)"                        :data-original-title="row.data[14] + ' out of ' + row.data[15] + ' connected hit(s)'">                        {{round2(100*row.data[14]/ row.data[15]) + '%' }}                    </td>                    <td :class="getBodyClass('Data', 6)"                        :data-original-title="round2(100*row.data[6]/ row.data[0]) + '% of '+ row.data[0] + ' direct hit(s)'">                        {{row.data[6]}}                    </td>                    <td :class="getBodyClass('Data', 7)">                        {{row.data[7]}}                    </td>                    <td :class="getBodyClass('Data', 27)" :data-original-title="round3(row.data[28]/1000) + ' seconds'">                        {{row.data[27]}}                    </td>                    <td :class="getBodyClass('Data', 8)"                        :data-original-title="round2(100*row.data[8]/ row.data[0]) + '% of '+ row.data[16] + ' hit(s)'">                        {{row.data[8]}}                    </td>                    <td :class="getBodyClass('Data', 9)"                        :data-original-title="round2(100*row.data[9]/ row.data[0]) + '% of '+ row.data[0] + ' direct hit(s)'">                        {{row.data[9]}}                    </td>                    <td :class="getBodyClass('Data', 10)"                        :data-original-title="round2(100*row.data[10]/ row.data[0]) + '% of '+ row.data[0] + ' direct hit(s)'">                        {{row.data[10]}}                    </td>                    <td v-if="wvw" :class="getBodyClass('Data', 17)"                        :data-original-title="round2(100*row.data[17]/ row.data[26]) +'% of total damage'">                        {{row.data[17]}}                    </td>                    <td v-if="wvw" :class="getBodyClass('Data', 13)">                        {{row.data[13]}}                    </td>                    <td v-if="wvw" :class="getBodyClass('Data', 25)"                    :data-original-title="row.data[24] + ' hits<br>' + round2(100*row.data[25]/ row.data[26]) +'% of total damage'">                        {{row.data[25]}}                    </td>                    <td v-if="wvw" :class="getBodyClass('Data', 12)">                        {{row.data[12]}}                    </td>                </tr>            </tbody>            <tfoot>                <tr v-for="row in (mode ? tableDataTarget.sums : tableData.sums)">                    <td></td>                    <td></td>                    <td class="text-left">{{row.name}}</td>                    <td></td>                    <td                        :data-original-title="row.data[2] + ' out of ' + row.data[1] + ' critable hit(s)' +                                    '<br>Total Critical Damage: ' + row.data[3] +                                    '<br>' + round2(100*row.data[3]/ row.data[18]) +'% of total damage' +                                    '<br>' + round2(100*row.data[3]/ row.data[19]) +'% of total direct damage'">                        {{round2(100*row.data[2] / row.data[1])}}%                    </td>                    <td :data-original-title="row.data[4] + ' out of ' + row.data[11] + ' connected direct hit(s)'">                        {{round2(100*row.data[4]/ row.data[11])}}%                    </td>                    <td :data-original-title="row.data[21] + ' out of ' + row.data[20] + ' connected power hit(s)'">                        {{round2(100*row.data[21]/ row.data[20])}}%                    </td>                    <td :data-original-title="row.data[23] + ' out of ' + row.data[22] + ' connected condition tick(s)'">                        {{round2(100*row.data[23]/ row.data[22])}}%                    </td>                    <td :data-original-title="row.data[5] + ' out of ' + row.data[11] + ' connected direct hit(s)'">                        {{round2(100*row.data[5]/ row.data[11])}}%                    </td>                    <td :data-original-title="row.data[14] + ' out of ' + row.data[15] + ' connected hit(s)'">                        {{round2(100*row.data[14]/ row.data[15]) + '%' }}                    </td>                    <td :data-original-title="round2(100*row.data[6]/ row.data[0])+ '% of '+ row.data[0] + ' direct hit(s)'">                        {{row.data[6]}}                    </td>                    <td>                        {{row.data[7]}}                    </td>                    <td :data-original-title="round3(row.data[28] / 1000) + ' seconds'">                        {{row.data[27]}}                    </td>                    <td :data-original-title="round2(100*row.data[8]/ row.data[0])+ '% of '+ row.data[16] + ' hit(s)'">                        {{row.data[8]}}                    </td>                    <td :data-original-title="round2(100*row.data[9]/ row.data[0])+ '% of '+ row.data[0] + ' direct hit(s)'">                        {{row.data[9]}}                    </td>                    <td :data-original-title="round2(100*row.data[10]/ row.data[0]) + '% of '+ row.data[0] + ' direct hit(s)'">                        {{row.data[10]}}                    </td>                    <td v-if="wvw" :data-original-title="round2(100*row.data[17]/ row.data[26]) +'% of total damage'">                        {{row.data[17]}}                    </td>                    <td v-if="wvw">                        {{row.data[13]}}                    </td>                    <td v-if="wvw" :data-original-title="row.data[24] + ' hits<br>' + round2(100*row.data[25]/ row.data[26]) +'% of total damage'">                        {{row.data[25]}}                    </td>                    <td v-if="wvw">                        {{row.data[12]}}                    </td>                </tr>            </tfoot>        </table>    </div>`,
                        mixins: [
                            numberComponent,
                            sortedTableComponent,
                            encounterPhaseComponent,
                        ],
                        data: function () {
                            return {
                                targetless: logData.targetless,
                                wvw: logData.wvw,
                                mode: logData.targetless ? 0 : 1,
                                cache: new Map(),
                                cacheTarget: new Map(),
                                sortdata: {
                                    order: "desc",
                                    index: -1,
                                    divideIndex: -1,
                                    key: "Prof",
                                },
                            };
                        },
                        methods: {
                            sortBy: function (key, index, divideIndex) {
                                this.sortByBase(this.sortdata, key, index);
                                this.sortdata.divideIndex =
                                    divideIndex >= 0 ? divideIndex : -1;
                            },
                            getHeaderClass: function (key, index) {
                                return this.getHeaderClassBase(
                                    this.sortdata,
                                    key,
                                    index
                                );
                            },
                            getBodyClass: function (key, index) {
                                var classes = this.getBodyClassBase(
                                    this.sortdata,
                                    key,
                                    index
                                );
                                return classes;
                            },
                            sortData: function (rows) {
                                var order =
                                    this.sortdata.order === "asc" ? 1 : -1;
                                switch (this.sortdata.key) {
                                    case "Sub":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    (x.player.group -
                                                        y.player.group) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Prof":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    this.sortByPlayerProfession(
                                                        x,
                                                        y
                                                    ) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Name":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Account":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                this.sortByPlayerAccount(x, y)
                                        );
                                        break;
                                    case "Data":
                                        var index = this.sortdata.index;
                                        var divideIndex =
                                            this.sortdata.divideIndex;
                                        if (divideIndex !== -1) {
                                            var round2 = this.round2;
                                            rows.sort(
                                                (x, y) =>
                                                    order *
                                                        (round2(
                                                            (100 *
                                                                x.data[index]) /
                                                                x.data[
                                                                    divideIndex
                                                                ]
                                                        ) -
                                                            round2(
                                                                (100 *
                                                                    y.data[
                                                                        index
                                                                    ]) /
                                                                    y.data[
                                                                        divideIndex
                                                                    ]
                                                            )) ||
                                                    this.sortByPlayerName(x, y)
                                            );
                                        } else {
                                            rows.sort(
                                                (x, y) =>
                                                    order *
                                                        (x.data[index] -
                                                            y.data[index]) ||
                                                    this.sortByPlayerName(x, y)
                                            );
                                        }
                                        break;
                                    default:
                                        return null;
                                        break;
                                }
                                return rows;
                            },
                        },
                        computed: {
                            tableid: function () {
                                return "off-table";
                            },
                            phase: function () {
                                return logData.phases[this.phaseindex];
                            },
                            tableData: function () {
                                const cacheID =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex;
                                if (this.cache.has(cacheID)) {
                                    return this.cache.get(cacheID);
                                }
                                const dataLength =
                                    this.phase.offensiveStats[0].length;
                                var rows = [];
                                var sums = [];
                                var groups = [];
                                var total = {
                                    name: "Total",
                                    data: new Array(dataLength).fill(0),
                                    count: 0,
                                };
                                const players = getActiveNonFakePlayersForPhase(
                                    this.encounterPhase
                                );
                                for (
                                    var i = 0;
                                    i < this.phase.offensiveStats.length;
                                    i++
                                ) {
                                    var data = new Array(dataLength).fill(0);
                                    var player = players[i];
                                    if (!player) {
                                        continue;
                                    }
                                    if (!groups[player.group]) {
                                        groups[player.group] = {
                                            name: "Group " + player.group,
                                            data: new Array(dataLength).fill(0),
                                            count: 0,
                                        };
                                    }
                                    groups[player.group].count++;
                                    total.count++;
                                    var stats = this.phase.offensiveStats[i];
                                    for (var j = 0; j < stats.length; j++) {
                                        data[j] = stats[j];
                                        groups[player.group].data[j] += data[j];
                                        total.data[j] += data[j];
                                    }
                                    rows.push({
                                        player: player,
                                        data: data,
                                    });
                                }
                                for (var i = 0; i < groups.length; i++) {
                                    if (groups[i]) {
                                        sums.push(groups[i]);
                                    }
                                }
                                sums.push(total);
                                var res = {
                                    rows: rows,
                                    sums: sums,
                                };
                                this.cache.set(cacheID, res);
                                return res;
                            },
                            tableDataTarget: function () {
                                var cacheID =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex +
                                    "-";
                                cacheID += getTargetCacheID(this.activetargets);
                                if (this.cacheTarget.has(cacheID)) {
                                    return this.cacheTarget.get(cacheID);
                                }
                                const dataLength =
                                    this.phase.offensiveStats[0].length;
                                var rows = [];
                                var sums = [];
                                var groups = [];
                                var total = {
                                    name: "Total",
                                    data: new Array(dataLength).fill(0),
                                    count: 0,
                                };
                                const players = getActiveNonFakePlayersForPhase(
                                    this.encounterPhase
                                );
                                for (
                                    var i = 0;
                                    i < this.phase.offensiveStats.length;
                                    i++
                                ) {
                                    var data = new Array(dataLength).fill(0);
                                    var player = players[i];
                                    if (!player) {
                                        continue;
                                    }
                                    if (!groups[player.group]) {
                                        groups[player.group] = {
                                            name: "Group " + player.group,
                                            data: new Array(dataLength).fill(0),
                                            count: 0,
                                        };
                                    }
                                    groups[player.group].count++;
                                    total.count++;
                                    var stats = this.phase.offensiveStats[i];
                                    for (var j = 0; j < stats.length; j++) {
                                        if (this.activetargets.length > 0) {
                                            for (
                                                var k = 0;
                                                k < this.activetargets.length;
                                                k++
                                            ) {
                                                var tar =
                                                    this.phase
                                                        .offensiveStatsTargets[
                                                        i
                                                    ][this.activetargets[k]];
                                                data[j] += tar[j];
                                            }
                                        } else {
                                            data[j] = 0;
                                        }
                                        groups[player.group].data[j] += data[j];
                                        total.data[j] += data[j];
                                    }
                                    rows.push({
                                        player: player,
                                        data: data,
                                    });
                                }
                                for (var i = 0; i < groups.length; i++) {
                                    if (groups[i]) {
                                        sums.push(groups[i]);
                                    }
                                }
                                sums.push(total);
                                var res = {
                                    rows: rows,
                                    sums: sums,
                                };
                                this.cacheTarget.set(cacheID, res);
                                return res;
                            },
                            UIIcons: function () {
                                return UIIcons;
                            },
                        },
                    });
                }
                {
                    function getDefaultBuffTabSubComponent(key) {
                        let header = "N/A";
                        if (key === "healingbuff-tables") {
                            header = "HealingStatistics";
                        } else if (key === "buff-tables") {
                            header = "Statistics";
                        }
                        if (!validateStartPath(header + "/Buffs")) {
                            return 0;
                        }
                        const setting = EIUrlParams.get("startPage");
                        const compo = setting.split("/")[2];
                        switch (compo) {
                            case "Uptimes":
                                return 0;
                            case "Volumes":
                                return 1;
                        }
                        return 0;
                    }
                    Vue.component("buff-tab-component", {
                        props: ["phaseindex", "playerindex"],
                        template: `    <div>        <ul class="nav nav-tabs">            <li>                <a class="nav-link" :class="{active: tab === 0}" @click="tab = 0">Uptimes</a>            </li>            <li v-if="hasOffBuffs">                <a class="nav-link" :class="{active: tab === 1}" @click="tab = 1">Volumes</a>            </li>        </ul>        <keep-alive>            <buff-tables-component v-if="tab == 0" :key="'buff-tables'" :type="tab" :phaseindex="phaseindex"                :playerindex="playerindex"></buff-tables-component>            <buff-volume-tables-component v-if="tab == 1" :key="'buff-volume-tables'" :type="tab" :phaseindex="phaseindex"                :playerindex="playerindex"></buff-volume-tables-component>        </keep-alive>    </div>`,
                        data: function () {
                            return {
                                tab: getDefaultBuffTabSubComponent(
                                    this.$vnode.key
                                ),
                            };
                        },
                    });
                }
                {
                    function getDefaultStatsSubComponent() {
                        if (!validateStartPath("Statistics/GeneralStats")) {
                            return 0;
                        }
                        const setting = EIUrlParams.get("startPage");
                        const compo = setting.split("/")[2];
                        switch (compo) {
                            case "DamageStats":
                                return 0;
                            case "GameplayStats":
                                return 1;
                            case "OffensiveStats":
                                return 4;
                            case "DefensiveStats":
                                return 2;
                            case "SupportStats":
                                return 3;
                        }
                        return 0;
                    }
                    Vue.component("stat-tables-component", {
                        props: ["phaseindex", "playerindex", "activetargets"],
                        template: `    <div>        <ul class="nav nav-tabs">            <li>                <a class="nav-link" :class="{active: tab === 0}" @click="tab = 0">Damage Stats</a>            </li>            <li>                <a class="nav-link" :class="{active: tab === 1}" @click="tab = 1">Gameplay Stats</a>            </li>            <li>                <a class="nav-link" :class="{active: tab === 4}" @click="tab = 4">Offensive Stats</a>            </li>            <li>                <a class="nav-link" :class="{active: tab === 2}" @click="tab = 2">Defensive Stats</a>            </li>            <li>                <a class="nav-link" :class="{active: tab === 3}" @click="tab = 3">Support Stats</a>            </li>        </ul>        <keep-alive>            <damage-stats-component v-if="tab === 0" :key="'damage'" :phaseindex="phaseindex"                :playerindex="playerindex" :activetargets="activetargets"></damage-stats-component>            <gameplay-stats-component v-if="tab === 1" :key="'gameplay'"                :phaseindex="phaseindex" :playerindex="playerindex">            </gameplay-stats-component>            <offensive-stats-component v-if="tab === 4" :key="'offensive'"                 :phaseindex="phaseindex" :playerindex="playerindex" :activetargets="activetargets">            </offensive-stats-component>            <defense-stats-component v-if="tab === 2" :key="'defense'" :phaseindex="phaseindex"                :playerindex="playerindex"></defense-stats-component>            <support-stats-component v-if="tab === 3" :key="'support'" :phaseindex="phaseindex"                :playerindex="playerindex"></support-stats-component>        </keep-alive>    </div>`,
                        data: function () {
                            return {
                                tab: getDefaultStatsSubComponent(),
                            };
                        },
                    });
                }
                {
                    Vue.component("mechanics-stats-component", {
                        props: ["phaseindex", "playerindex"],
                        template: `    <div>                  <keep-alive>            <mechanics-table-component v-for="(phase, id) in phases" :key="'mechanics' + id" v-if="id === phaseindex"                :phaseindex="id" :playerindex="playerindex">            </mechanics-table-component>              </keep-alive>    </div>`,
                        data: function () {
                            return {};
                        },
                        computed: {
                            phases: function () {
                                return logData.phases;
                            },
                        },
                    });
                }
                {
                    Vue.component("mechanics-table-component", {
                        props: ["phaseindex", "playerindex"],
                        template: `    <div>        <div v-if="playerColPageCount > 0">            <table-scroll-component :min="0" :max="playerColPageCount" :width="'600px'" :height="'10px'" :transform="transFormString" :pagestructure="playerColStructure"></table-scroll-component>        </div>        <table v-if="playerMechHeader.length > 0" class="table table-sm table-striped table-hover" cellspacing="0" :id="tablePid">            <thead>                <tr>                    <th class="sub-cell" :class="getPlayerHeaderClass('Sub')" @click="sortPlayerBy('Sub')">Sub</th>                    <th class="prof-cell" :class="getPlayerHeaderClass('Prof')" @click="sortPlayerBy('Prof')"></th>                    <th class="text-left" :class="getPlayerHeaderClass('Name')" @click="sortPlayerBy('Name')">Player</th>                    <th class="stat-cell" v-for="(mech, index) in playerMechHeader"                         v-show="isInPlayerColPage(index)"                        :class="getPlayerHeaderClass('Data', index)" @click="sortPlayerBy('Data', index)" :data-original-title="mech.name + ': ' + mech.description">                        {{ mech.shortName}}                    </th>                </tr>            </thead>            <tbody>                <tr v-for="row in sortPlayerData(playerMechRows)" :class="{active: row.player.id === playerindex}">                    <td :class="getPlayerBodyClass('Sub')">{{row.player.group}}</td>                    <td :class="getPlayerBodyClass('Prof')" :data-original-title="row.player.profession">                        <img :src="row.player.icon" :alt="row.player.profession" class="icon">                        <span style="display:none">{{row.player.profession}}</span>                    </td>                    <td :class="getPlayerBodyClass('Name')" class="text-left">{{row.player.name}}</td>                    <td v-for="(mech, index) in row.mechs" :class="getPlayerBodyClass('Data', index)"                         v-show="isInPlayerColPage(index)"                        :data-original-title="mech[1] !== mech[0] ? mech[1] + ' times (multi hits)' : false">                        {{ playerMechHeader[index].isAchievementEligibility ? (mech[0] ? 'Non Eligible' : 'Eligible') : (mech[0] ? mech[0] : '-')}}                    </td>                </tr>            </tbody>        </table>        <div v-if="enemyColPageCount > 0">            <table-scroll-component :min="0" :max="enemyColPageCount" :width="'600px'" :height="'10px'" :transform="transFormString" :pagestructure="enemyColStructure"></table-scroll-component>        </div>        <table v-if="enemyMechHeader.length > 0" class="table table-sm table-striped table-hover" cellspacing="0" :id="tableEid">            <thead>                <tr>                    <th class="text-left" style="width: 250px;":class="getEnemyHeaderClass('Name')" @click="sortEnemyBy('Name')">Enemy</th>                    <th class="stat-cell" v-for="(mech, index) in enemyMechHeader"                         v-show="isInEnemyColPage(index)"                        :class="getEnemyHeaderClass('Data', index)" @click="sortEnemyBy('Data', index)" :data-original-title="mech.name + ': ' + mech.description">                        {{ mech.shortName}}                    </th>                </tr>            </thead>            <tbody>                <tr v-for="row in sortEnemyData(enemyMechRows)">                    <td :class="getEnemyBodyClass('Name')"                         class="text-left">                        {{row.enemy}}                    </td>                    <td v-for="(mech, index) in row.mechs"                         class="stat-cell"                         :class="getEnemyBodyClass('Data', index)"                                         v-show="isInEnemyColPage(index)"                        :data-original-title="mech[1] !== mech[0] ? mech[1] + ' times (multi hits)' : false">                        {{mech[0] ? mech[0] : '-'}}                    </td>                </tr>            </tbody>        </table>        <div v-if="enemyMechHeader.length === 0 && playerMechHeader.length === 0">            <h2>No tracked mechanics for this phase.</h2>        </div>    </div>`,
                        mixins: [
                            encounterPhaseComponent,
                            numberComponent,
                            sortedTableComponent,
                            colSliderComponent(maxMechColumns, [
                                "player",
                                "enemy",
                            ]),
                        ],
                        data: function () {
                            return {
                                sortEdata: {
                                    order: "asc",
                                    index: -1,
                                    key: "Name",
                                    mechIndex: -1,
                                },
                                sortPdata: {
                                    order: "asc",
                                    index: -1,
                                    key: "Sub",
                                    mechIndex: -1,
                                },
                            };
                        },
                        watch: {
                            encounters: {
                                deep: true,
                                handler: function () {
                                    const mechPIndex = this.sortPdata.mechIndex;
                                    if (mechPIndex >= 0) {
                                        const mech =
                                            this.playerMechHeader.filter(
                                                (x) => x._index === mechPIndex
                                            )[0];
                                        if (!mech) {
                                            // Reset sort if mechanic is gone
                                            this.sortPdata.order = "asc";
                                            this.sortPdata.index = -1;
                                            this.sortPdata.key = "Sub";
                                            this.sortPdata.mechIndex = -1;
                                        } else {
                                            // Otherwise sort by its new position
                                            this.sortPdata.index =
                                                this.playerMechHeader.indexOf(
                                                    mech
                                                );
                                        }
                                    }
                                    const mechEIndex = this.sortEdata.mechIndex;
                                    if (mechEIndex >= 0) {
                                        const mech =
                                            this.enemyMechHeader.filter(
                                                (x) => x._index === mechEIndex
                                            )[0];
                                        if (!mech) {
                                            // Reset sort if mechanic is gone
                                            this.sortEdata.order = "asc";
                                            this.sortEdata.index = -1;
                                            this.sortEdata.key = "Name";
                                            this.sortEdata.mechIndex = -1;
                                        } else {
                                            // Otherwise sort by its new position
                                            this.sortEdata.index =
                                                this.enemyMechHeader.indexOf(
                                                    mech
                                                );
                                        }
                                    }
                                },
                            },
                        },
                        methods: {
                            sortPlayerBy: function (key, index) {
                                if (key === "Data" && index >= 0) {
                                    this.sortPdata.mechIndex =
                                        this.playerMechHeader[index]._index;
                                } else {
                                    this.sortPdata.mechIndex = -1;
                                }
                                this.sortByBase(this.sortPdata, key, index);
                            },
                            getPlayerHeaderClass: function (key, index) {
                                return this.getHeaderClassBase(
                                    this.sortPdata,
                                    key,
                                    index
                                );
                            },
                            getPlayerBodyClass: function (key, index) {
                                var classes = this.getBodyClassBase(
                                    this.sortPdata,
                                    key,
                                    index
                                );
                                return classes;
                            },
                            sortPlayerData: function (rows) {
                                var order =
                                    this.sortPdata.order === "asc" ? 1 : -1;
                                switch (this.sortPdata.key) {
                                    case "Sub":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    (x.player.group -
                                                        y.player.group) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Prof":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    this.sortByPlayerProfession(
                                                        x,
                                                        y
                                                    ) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Name":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Data":
                                        var index = this.sortPdata.index;
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    (x.mechs[index][0] -
                                                        y.mechs[index][0]) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    default:
                                        return null;
                                        break;
                                }
                                return rows;
                            },
                            sortEnemyBy: function (key, index) {
                                if (key === "Data" && index >= 0) {
                                    this.sortEdata.mechIndex =
                                        this.enemyMechHeader[index]._index;
                                } else {
                                    this.sortEdata.mechIndex = -1;
                                }
                                this.sortByBase(this.sortEdata, key, index);
                            },
                            getEnemyHeaderClass: function (key, index) {
                                return this.getHeaderClassBase(
                                    this.sortEdata,
                                    key,
                                    index
                                );
                            },
                            getEnemyBodyClass: function (key, index) {
                                var classes = this.getBodyClassBase(
                                    this.sortEdata,
                                    key,
                                    index
                                );
                                return classes;
                            },
                            sortEnemyData: function (rows) {
                                var order =
                                    this.sortEdata.order === "asc" ? 1 : -1;
                                switch (this.sortEdata.key) {
                                    case "Name":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                x.enemy.localeCompare(y.enemy)
                                        );
                                        break;
                                    case "Data":
                                        var index = this.sortEdata.index;
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    (x.mechs[index][0] -
                                                        y.mechs[index][0]) ||
                                                x.enemy.localeCompare(y.enemy)
                                        );
                                        break;
                                    default:
                                        return null;
                                        break;
                                }
                                return rows;
                            },
                        },
                        computed: {
                            transFormString: function () {
                                const translateValue =
                                    mainComponentWidth * 0.34;
                                return `translate(${translateValue}px)`;
                            },
                            playerColPageCount: function () {
                                return (
                                    this.playerMechHeader.length -
                                    this.playerColStructure.perpage
                                );
                            },
                            enemyColPageCount: function () {
                                return (
                                    this.enemyMechHeader.length -
                                    this.enemyColStructure.perpage
                                );
                            },
                            tablePid: function () {
                                return "playermechs-" + this.phaseindex;
                            },
                            tableEid: function () {
                                return "enemymechs-" + this.phaseindex;
                            },
                            phase: function () {
                                return logData.phases[this.phaseindex];
                            },
                            playerMechHeader: function () {
                                const allPlayerMechs = playerMechanics();
                                var res = [];
                                const players = getActiveNonFakePlayersForPhase(
                                    this.encounterPhase
                                );
                                for (
                                    let j = 0;
                                    j < allPlayerMechs.length;
                                    j++
                                ) {
                                    allPlayerMechs[j]._index = j;
                                    for (var i = 0; i < players.length; i++) {
                                        var player = players[i];
                                        if (!player) {
                                            continue;
                                        }
                                        if (
                                            this.phase.mechanicStats[i][j][0] >
                                                0 ||
                                            allPlayerMechs[j]
                                                .isAchievementEligibility
                                        ) {
                                            res.push(allPlayerMechs[j]);
                                            break;
                                        }
                                    }
                                }
                                return res;
                            },
                            playerMechRows: function () {
                                const players = getActiveNonFakePlayersForPhase(
                                    this.encounterPhase
                                );
                                var rows = [];
                                for (var i = 0; i < players.length; i++) {
                                    var player = players[i];
                                    if (!player) {
                                        continue;
                                    }
                                    let mechs = [];
                                    for (
                                        let j = 0;
                                        j < this.playerMechHeader.length;
                                        j++
                                    ) {
                                        let mechIndex =
                                            this.playerMechHeader[j]._index;
                                        mechs.push(
                                            this.phase.mechanicStats[i][
                                                mechIndex
                                            ]
                                        );
                                    }
                                    rows.push({
                                        player: player,
                                        mechs: mechs,
                                    });
                                }
                                return rows;
                            },
                            enemyMechHeader: function () {
                                const allEnemyMechs = enemyMechanics();
                                var res = [];
                                var enemies = logData.enemies;
                                let encounterPhase = this.encounterPhase;
                                for (let j = 0; j < allEnemyMechs.length; j++) {
                                    allEnemyMechs[j]._index = j;
                                    for (var i = 0; i < enemies.length; i++) {
                                        var enemy = enemies[i];
                                        if (
                                            enemy.firstAware >=
                                                encounterPhase.end ||
                                            enemy.lastAware <=
                                                encounterPhase.start
                                        ) {
                                            continue;
                                        }
                                        if (
                                            this.phase.enemyMechanicStats[i][
                                                j
                                            ][0] > 0 ||
                                            allEnemyMechs[j]
                                                .isAchievementEligibility
                                        ) {
                                            res.push(allEnemyMechs[j]);
                                            break;
                                        }
                                    }
                                }
                                return res;
                            },
                            enemyMechRows: function () {
                                var enemies = logData.enemies;
                                var rows = [];
                                let encounterPhase = this.encounterPhase;
                                for (var i = 0; i < enemies.length; i++) {
                                    var enemy = enemies[i];
                                    if (
                                        enemy.firstAware >=
                                            encounterPhase.end ||
                                        enemy.lastAware <= encounterPhase.start
                                    ) {
                                        continue;
                                    }
                                    let mechs = [];
                                    for (
                                        let j = 0;
                                        j < this.enemyMechHeader.length;
                                        j++
                                    ) {
                                        let mechIndex =
                                            this.enemyMechHeader[j]._index;
                                        mechs.push(
                                            this.phase.enemyMechanicStats[i][
                                                mechIndex
                                            ]
                                        );
                                    }
                                    rows.push({
                                        enemy: enemy.name,
                                        mechs: mechs,
                                    });
                                }
                                return rows;
                            },
                        },
                    });
                }
                {
                    Vue.component("phase-component", {
                        props: ["phases"],
                        mixins: [encounterPhaseComponent],
                        template: `    <div>        <ul v-if="showNormalPhases" class="nav nav-pills d-flex flex-row justify-content-center">            <li class="nav-item" v-for="phase in phasesToUse" v-show="!getPhaseData(phase.index).breakbarPhase"                :data-original-title="getPhaseTooltip(phase.index)">                <a class="nav-link" @click="select(phase)" :class="{active: phase.active}">{{getPhaseName(phase.index)}}</a>            </li>        </ul>        <div v-if="hasBreakbarPhases" class="d-flex flex-row justify-content-center align-items-center">            <span class="mr-1">Breakbar Phases: </span>            <div style="max-width: 1200px;" class="d-flex flex-row align-items-center scrollable-x">                <div v-for="data in breakbarPhasesPerTarget"                class="d-flex flex-row flex-nowrap  align-items-center mr-1 ml-1">                <img class="icon-sl mr-2" :src="getTargetData(data.targetId).icon"                    :alt="getTargetData(data.targetId).name" :data-original-title="getTargetData(data.targetId).name"                    >                <ul class="nav nav-pills d-flex flex-row flex-nowrap">                    <li class="nav-item" v-for="(phase, id) in data.phases"                        v-show="getPhaseData(phase.index).breakbarPhase"                        :data-original-title="getBreakbarPhaseTooltip(phase.index)">                        <a class="nav-link" @click="select(phase)"                            :class="{active: phase.active}">{{id + 1}}</a>                    </li>                </ul>            </div>            </div>        </div>    </div>`,
                        computed: {
                            phasesToUse: function () {
                                return getPhasesForSelectedEncounter(
                                    this.phases,
                                    this.encounters
                                );
                            },
                            showNormalPhases: function () {
                                return (
                                    this.normalPhases.length > 1 ||
                                    this.hasBreakbarPhases
                                );
                            },
                            normalPhases: function () {
                                return this.phasesToUse.filter(
                                    (phase) => !phase.breakbarPhase
                                );
                            },
                            hasBreakbarPhases: function () {
                                return this.breakbarPhasesPerTarget.length > 0;
                            },
                            breakbarPhasesPerTarget: function () {
                                var res = [];
                                for (
                                    var targetId = 0;
                                    targetId < logData.targets.length;
                                    targetId++
                                ) {
                                    var brPhases = this.phasesToUse.filter(
                                        (phase) => {
                                            const logPhase =
                                                logData.phases[phase.index];
                                            return (
                                                logPhase.breakbarPhase &&
                                                logPhase.targets.indexOf(
                                                    targetId
                                                ) > -1
                                            );
                                        }
                                    );
                                    var phases = [];
                                    for (
                                        var brPhaseId = 0;
                                        brPhaseId < brPhases.length;
                                        brPhaseId++
                                    ) {
                                        phases.push(brPhases[brPhaseId]);
                                    }
                                    if (phases.length > 0) {
                                        res.push({
                                            targetId: targetId,
                                            phases: phases,
                                        });
                                    }
                                }
                                return res;
                            },
                        },
                        methods: {
                            select: function (phase) {
                                for (var i = 0; i < this.phases.length; i++) {
                                    if (this.phases[i] === phase) {
                                        reactiveLogdata.activeEncounterPhaseData[
                                            this.encounterPhase.encounterID
                                        ].phase = i;
                                        this.phases[i].active = true;
                                    } else {
                                        this.phases[i].active = false;
                                    }
                                }
                            },
                            getPhaseData: function (id) {
                                return logData.phases[id];
                            },
                            getPhaseName: function (id) {
                                const phase = this.getPhaseData(id);
                                return phase === this.encounterPhase
                                    ? phase.nameNoMode
                                    : phase.name;
                            },
                            getTargetData: function (id) {
                                return logData.targets[id];
                            },
                            getPhaseTooltip: function (id) {
                                var phase = this.getPhaseData(id);
                                return (
                                    phase.durationS +
                                    " seconds <br /> Start: " +
                                    phase.start +
                                    "<br /> End: " +
                                    phase.end
                                );
                            },
                            getBreakbarPhaseTooltip: function (id) {
                                var phase = this.getPhaseData(id);
                                var target = this.getTargetData(
                                    phase.targets[0]
                                );
                                var breakbarTaken =
                                    target.details.dmgDistributionsTaken[id]
                                        .contributedBreakbarDamage;
                                return (
                                    this.getPhaseTooltip(id) +
                                    "<br /> Breakbar Damage: " +
                                    breakbarTaken
                                );
                            },
                        },
                    });
                }
                {
                    Vue.component("player-component", {
                        props: ["players", "phaseindex"],
                        mixins: [
                            encounterPhaseComponent,
                            playerHeaderComponent,
                        ],
                        template: `    <div class="d-flex flex-row">        <div class="d-flex flex-column mr-1">            <img class="icon" :src="UIIcons.QuestionMark" :data-original-title="scoreExpl" />            <img class="icon" :src="UIIcons.QuestionMark" :data-original-title="weaponExpl" />        </div>        <div class="d-flex flex-column" style="max-width: 900px;">            <div v-for="group in groups" class="d-flex flex-wrap mb-1">                <div v-for="player in group"                    class="player-cell d-flex flex-column align-items-center justify-content-center"                    :class="{active: player.active}" @click="select(player.id)">                    <div>                        <img :src="player.icon" :alt="player.profession" class="icon"                            :data-original-title="player.profession">                        <img v-if="player.health > 0" :src="UIIcons.VitalityChar"                            alt="Health" class="icon" :data-original-title="'Health: ' + player.health">                        <img v-if="player.condi > 0" :src="UIIcons.ConditionDamageChar"                            alt="Condition Damage" class="icon"                            :data-original-title="scoreV2 ? 'Condition Damage' : 'Condition Damage: ' + player.condi">                        <img v-if="player.conc > 0" :src="UIIcons.BoonDurationChar"                            alt="Concentration" class="icon" :data-original-title="scoreV2 ? 'Concentration' : 'Concentration: ' + player.conc">                        <img v-if="player.heal > 0" :src="UIIcons.HealingPowerChar"                            alt="Healing Power" class="icon" :data-original-title="scoreV2 ? 'Healing Power' : 'Healing Power: ' + player.heal">                        <img v-if="player.tough > 0" :src="UIIcons.ToughnessChar"                            alt="Toughness" class="icon" :data-original-title="scoreV2 ? 'Toughness' : 'Toughness: ' + player.tough">                    </div>                    <div v-for="(weaponSet, weaponSetIndex) in player.weaponSets">                        <div v-show="showWeaponSet(weaponSetIndex, player.weaponSets, encounterPhase)">                            <div v-if="weaponSet.l1Set.length > 0 || weaponSet.l2Set.length > 0">                                <img v-for="wep in weaponSet.l1Set" :src="getIcon(wep)" :data-original-title="wep" class="icon">                                <span v-if="weaponSet.l1Set.length > 0 && weaponSet.l2Set.length > 0">/</span>                                <img v-for="wep in weaponSet.l2Set" :src="getIcon(wep)" :data-original-title="wep" class="icon">                            </div>                            <div v-if="weaponSet.a1Set.length > 0 || weaponSet.a2Set.length > 0">                                <img v-for="wep in weaponSet.a1Set" :src="getIcon(wep)" :data-original-title="wep" class="icon">                                <span v-if="weaponSet.a1Set.length > 0 && weaponSet.a2Set.length > 0">/</span>                                <img v-for="wep in weaponSet.a2Set" :src="getIcon(wep)" :data-original-title="wep" class="icon">                            </div>                        </div>                    </div>                    <div class="d-flex align-items-center justify-content-center">                        <img v-if="runningExtensions && runningExtensions[player.id]"                            :src="UIIcons.GreenFlag" alt="Extensions"                            class="icon" :data-original-title="computeExtensionTooltip(runningExtensions[player.id])">                        <img v-if="player.isCommander"                            :src="UIIcons.Commander" alt="Commander"                            class="icon" :data-original-title="getCommanderTooltip(player)">                        <span class="player-cell-shorten" :data-original-title="player.name + ' - ' + player.acc">                            {{ player.name }}                        </span>                    </div>                </div>            </div>        </div>    </div>`,
                        methods: {
                            select: function (id) {
                                for (var i = 0; i < this.players.length; i++) {
                                    if (id === i) {
                                        reactiveLogdata.activeEncounterPhaseData[
                                            this.encounterPhase.encounterID
                                        ].player = i;
                                        this.players[i].active = true;
                                    } else {
                                        this.players[i].active = false;
                                    }
                                }
                            },
                            computeExtensionTooltip: function (data) {
                                var str = "Player is running: <br>";
                                for (var i = 0; i < data.length; i++) {
                                    str += "- " + data[i] + " Extension";
                                    if (i !== data.length - 1) {
                                        str += "<br>";
                                    }
                                }
                                return str;
                            },
                        },
                        computed: {
                            scoreV2: function () {
                                return logData.evtcBuild > 20210800;
                            },
                            scoreExpl: function () {
                                if (this.scoreV2) {
                                    return `
                        <span style='text-align:left;display: block;'>
                        A player has a stat score if they are above 60% of the maximum stat present in the squad. For example if the maximum healing power stat inside the squad is 1000, anybody with a healing power stat above 600 will be flagged as with healing power.
                        </span>
                    `;
                                }
                                return `
                <span style='text-align:left;display: block;'>
                Scores are relative to the squad. 10 means that that player had the highest stat in the squad. 8 means that that player had between 80% and 89% of the highest scored player's stat.
                </span>
                `;
                            },
                            weaponExpl: function () {
                                if (IsMultiEncounterLog) {
                                    return `
                    <span style='text-align:left;display: block;'>
                    Weapons are estimated based on skills that were cast by the player.
                    <br>
                    If the player has changed weapons during the instance, only the weapons used during the selected encounter will be displayed.
                    <br>
                    If the whole instance is selected, the first encountered weapon set will be shown instead.
                    </span>
                    `;
                                }
                                return `
                <span style='text-align:left;display: block;'>
                Weapons are estimated based on skills that were cast by the player.
                </span>
                `;
                            },
                            groups: function () {
                                var aux = [];
                                const players = getActiveNonFakePlayersForPhase(
                                    this.encounterPhase
                                );
                                for (var i = 0; i < players.length; i++) {
                                    var playerData = players[i];
                                    if (!playerData) {
                                        continue;
                                    }
                                    if (!aux[playerData.group]) {
                                        aux[playerData.group] = [];
                                    }
                                    var toPush = {};
                                    Object.assign(toPush, playerData);
                                    toPush.active = this.players[i].active;
                                    aux[playerData.group].push(toPush);
                                }

                                var noUndefinedGroups = [];
                                for (var i = 0; i < aux.length; i++) {
                                    if (aux[i]) {
                                        noUndefinedGroups.push(aux[i]);
                                    }
                                }
                                return noUndefinedGroups;
                            },
                            runningExtensions: function () {
                                if (logData.usedExtensions) {
                                    var res = [];
                                    const players =
                                        getActiveNonFakePlayersForPhase(
                                            this.encounterPhase
                                        );
                                    for (var i = 0; i < players.length; i++) {
                                        var playerData = players[i];
                                        if (!playerData) {
                                            res.push(null);
                                            continue;
                                        }
                                        var subRes = [];
                                        for (
                                            var j = 0;
                                            j < logData.usedExtensions.length;
                                            j++
                                        ) {
                                            var usedExtension =
                                                logData.usedExtensions[j];
                                            var playersRunning =
                                                logData
                                                    .playersRunningExtensions[
                                                    j
                                                ];
                                            if (
                                                playersRunning.includes(
                                                    playerData.name
                                                )
                                            ) {
                                                subRes.push(
                                                    usedExtension.split(
                                                        " - "
                                                    )[0]
                                                );
                                            }
                                        }
                                        if (subRes.length > 0) {
                                            res.push(subRes);
                                        } else {
                                            res.push(null);
                                        }
                                    }
                                    return res;
                                } else {
                                    return null;
                                }
                            },
                        },
                    });
                }
                {
                    function getDefaultPlayerTabSubComponent() {
                        if (!validateStartPath("Statistics/PlayerSummary")) {
                            return 0;
                        }
                        const setting = EIUrlParams.get("startPage");
                        const compo = setting.split("/")[2];
                        switch (compo) {
                            case "OutgoingDamage":
                                return 0;
                            case "IncomingDamage":
                                return 1;
                            case "Graph":
                                return 2;
                            case "BoonStatus":
                                return 7;
                            case "SimpleRotation":
                                return 3;
                            case "AdvancedRotation":
                                return 4;
                            case "Consumables":
                                return 5;
                            case "DeathRecap":
                                return showDeathRecap() ? 6 : 0;
                        }
                        return 0;
                    }
                    Vue.component("player-stats-component", {
                        props: [
                            "phaseindex",
                            "activetargets",
                            "activeplayer",
                            "light",
                        ],
                        template: `    <div>        <h3 v-for="player in players" :key="player.id" v-show="player.id === activeplayer"            class="text-center mt-2"><img :alt="player.profession" class="icon" :src="player.icon">{{player.name}}</h3>        <ul class="nav nav-tabs" v-show="activeplayer > -1">            <li>                <a class="nav-link" :class="{active: tabmode === 0}" @click="tabmode = 0">                    Outgoing Damage                </a>            </li>            <li>                <a class="nav-link" :class="{active: tabmode === 1}" @click="tabmode = 1">                    Incoming Damage                </a>            </li>            <li>                <a class="nav-link" :class="{active: tabmode === 2}" @click="tabmode = 2">Graph</a>            </li>            <li>                <a class="nav-link" :class="{active: tabmode === 7}" @click="tabmode = 7">                    Boon Status                </a>            </li>            <li>                <a class="nav-link" :class="{active: tabmode === 3}" @click="tabmode = 3">                    Simple                    Rotation                </a>            </li>                    <li>                <a class="nav-link" :class="{active: tabmode === 4}" @click="tabmode = 4">                    Advanced                    Rotation                </a>            </li>            <li>                <a class="nav-link" :class="{active: tabmode === 5}" @click="tabmode = 5">                    Consumables                </a>            </li>            <li>                <a class="nav-link" v-show="hasDeaths" :class="{active: tabmode === 6}" @click="tabmode = 6">                    Death                    Recap                </a>            </li>        </ul>        <keep-alive>            <player-tab-component v-for="player in players" :key="player.id"                v-if="player.id === activeplayer" :playerindex="player.id" :tabmode="tabmode"                :phaseindex="phaseindex" :activetargets="activetargets" :light="light"></player-tab-component>        </keep-alive>        <div v-if="activeplayer === -1">            <h3 class="text-center">No player selected</h3>        </div>    </div>`,
                        data: function () {
                            return {
                                tabmode: getDefaultPlayerTabSubComponent(),
                            };
                        },
                        computed: {
                            players: function () {
                                return logData.players;
                            },
                            hasDeaths: function () {
                                return showDeathRecap();
                            },
                        },
                    });
                }
                {
                    Vue.component("player-tab-component", {
                        props: [
                            "playerindex",
                            "tabmode",
                            "phaseindex",
                            "activetargets",
                            "light",
                        ],
                        template: `    <div>        <keep-alive>            <dmgdist-player-component v-if="tabmode === 0" :key="'dist' + playerindex" :playerindex="playerindex"                :phaseindex="phaseindex" :activetargets="activetargets"></dmgdist-player-component>            <dmgtakendist-player-component v-if="tabmode ===1" :key="'taken' + playerindex"                 :playerindex="playerindex" :phaseindex="phaseindex"></dmgtakendist-player-component>            <player-graph-tab-component v-for="(ph, id) in phases" v-if="tabmode === 2 && id === phaseindex" :key="id + 'graph' + playerindex"                :playerindex="playerindex" :phaseindex="id" :activetargets="activetargets" :light="light">            </player-graph-tab-component>            <player-buff-tab-component v-if="tabmode === 7" :key="'buffs' + playerindex" :playerindex="playerindex"                :phaseindex="phaseindex"></player-buff-tab-component>            <simplerotation-component v-if="tabmode === 3" :key="'rot' + playerindex" :actorindex="playerindex"                :phaseindex="phaseindex" :target="false"></simplerotation-component>                        <advancedrotation-component v-for="(ph, id) in phases" v-if="tabmode === 4 && id === phaseindex" :key="id + 'advrot' + playerindex" :actorindex="playerindex"            :phaseindex="id" :target="false" :light="light"></advancedrotation-component>            <food-component v-if="tabmode === 5" :key="'cons' + playerindex" :playerindex="playerindex"                :phaseindex="phaseindex"></food-component>            <deathrecap-component v-if="tabmode === 6" :key="'recap' + playerindex" :playerindex="playerindex"                :phaseindex="phaseindex"></deathrecap-component>        </keep-alive>    </div>`,
                        computed: {
                            phases: function () {
                                return logData.phases;
                            },
                        },
                    });
                }
                {
                    Vue.component("simplerotation-component", {
                        props: ["actorindex", "phaseindex", "target"],
                        template: `    <div>        <div class="d-flex flex-row justify-content-center mt-1 mb-1">            <ul class="d-flex flex-row justify-content-center nav nav-pills mr-1 scale85">                <li class="nav-item">                    <a class="nav-link" @click="autoattack = !autoattack"                       :class="{active: autoattack}">Show auto attacks</a>                </li>                <li class="nav-item">                    <a class="nav-link" @click="hideInterruptedAA = !hideInterruptedAA"                       :class="{active: hideInterruptedAA}">Hide interrupted auto attacks</a>                </li>                <li class="nav-item">                    <a class="nav-link" @click="hideSmallTime = !hideSmallTime"                       :class="{active: hideSmallTime}">Hide < 10ms</a>                </li>            </ul>            <ul class="d-flex flex-row justify-content-center nav nav-pills ml-1 mr-1 scale85">                <li class="nav-item">                    <a class="nav-link" @click="hideInstantCast = !hideInstantCast"                       :class="{active: hideInstantCast}">Hide all instant cast</a>                </li>                <li class="nav-item">                    <a class="nav-link" @click="hideInstantCastSkill = !hideInstantCastSkill"                       :class="{active: hideInstantCastSkill, disabled: hideInstantCast}">Hide instant cast skills</a>                </li>                <li class="nav-item">                    <a class="nav-link" @click="hideGearProc = !hideGearProc"                       :class="{active: hideGearProc, disabled: hideInstantCast}">Hide gear procs</a>                </li>                <li class="nav-item">                    <a class="nav-link" @click="hideTraitProc = !hideTraitProc"                       :class="{active: hideTraitProc, disabled: hideInstantCast}">Hide trait procs</a>                </li>                <li class="nav-item" v-if="hasInstantCastUnconditional">                    <a class="nav-link" @click="hideUnconditionalProc = !hideUnconditionalProc"                       :class="{active: hideUnconditionalProc, disabled: hideInstantCast}">Hide unconditional procs</a>                </li>            </ul>            <ul class="d-flex flex-row justify-content-center nav nav-pills ml-1 scale85">                <li class="nav-item">                    <a class="nav-link" @click="small = !small"                       :class="{active: small}">Small icons</a>                </li>                <li class="nav-item">                    <a class="nav-link" @click="smallAA = !smallAA"                       :class="{active: smallAA}">Small auto attack icons</a>                </li>            </ul>        </div>        <div class="d-flex flex-row justify-content-center mt-1 mb-1">            <ul class="nav nav-pills mr-1 ml-1 scale85">                <li class="nav-item rot-animfull">                    <a class="nav-link" @click="aftercastBorder = !aftercastBorder"                       :class="{active: aftercastBorder}" data-original-title="Toggle full after cast border">Full After Cast</a>                </li>                <li class="nav-item rot-cancelled">                    <a class="nav-link" @click="interruptedBorder = !interruptedBorder"                       :class="{active: interruptedBorder}" data-original-title="Toggle interrupted cast border">Interrupted</a>                </li>                <li class="nav-item rot-instant">                    <a class="nav-link" @click="instantBorder = !instantBorder"                       :class="{active: instantBorder}" data-original-title="Toggle instant cast border">Instant</a>                </li>                <li class="nav-item rot-unknown">                    <a class="nav-link" @click="unknownBorder = !unknownBorder"                       :class="{active: unknownBorder}" data-original-title="Toggle unknown cast border">Unknown</a>                </li>            </ul>        </div>        <div style="z-index: 1;" class="mb-4 mt-2">            <a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Filter Skills" style="font-size: 1.1em;">                Skills <span class="caret"></span>            </a>            <ul class="dropdown-menu p-2 font-weight-normal scrollabledropdown" style="min-width: 165px;">                <div class="d-flex flex-column justify-content-center align-items-center mb-1"                    style="border-bottom: 2px solid #bbb;">                    <li>                        <button style="width:160px; padding: 0.4rem 0.4rem;" type="button" class="btn btn-primary btn-sm"                                @click="setAllSelectedSkills(true)" @click.stop="stopClickEvent">                            Select all                        </button>                    </li>                    <li class="mb-1">                        <button style="width:160px; padding: 0.4rem 0.4rem;" type="button" class="btn btn-primary btn-sm"                                @click="setAllSelectedSkills(false)" @click.stop="stopClickEvent">                            Deselect all                        </button>                    </li>                </div>                <li v-for="(skill, index) in skillList" :key="index">                                   <div style="width: max-content;">                        <input :id="'simple-rotation-player-' + index  + '-' + phaseindex" type="checkbox"                            v-model="selectedSkills['s' + skill.id]" @click.stop="stopClickEvent" />                        <label :for="'simple-rotation-player-' + index + '-' + phaseindex" @click.stop="stopClickEvent"                            style="font-size: 1.0em; white-space: nowrap;margin-top: 2px;">                            <img class="icon" :src="getSkill(skill.id).icon">                            {{skill.name}}                        </label>                    </div>                </li>            </ul>        </div>        <span class="rot-skill" v-for="cast in rotation" :class="getCastClass(cast)" v-show="showSkill(cast)" @click="toggleHighlight(cast.skill)">            <img class="rot-icon" :class="getIconClass(cast)" :src="cast.skill.icon" :data-original-title="getTooltip(cast)" />        </span>    </div>`,
                        data: function () {
                            const selectedSkills = {};
                            const phaseData = [];
                            let hasInstantCastUnconditional = false;
                            for (
                                let phaseIndex = 0;
                                phaseIndex < logData.phases.length;
                                phaseIndex++
                            ) {
                                const skillList = [];
                                const castCounts = {};
                                const rotation = this.target
                                    ? logData.targets[this.actorindex].details
                                          .rotation[phaseIndex]
                                    : logData.players[this.actorindex].details
                                          .rotation[phaseIndex];
                                for (var i = 0; i < rotation.length; i++) {
                                    const rota = rotation[i];
                                    const skillID = rota[1];
                                    const skill = this.getSkill(skillID);
                                    const isInstant =
                                        rota[3] === RotationStatus.INSTANT;
                                    if (isInstant && skill.unconditionalProc) {
                                        hasInstantCastUnconditional = true;
                                    }
                                    if (!castCounts[skillID]) {
                                        castCounts[skillID] = rotation.filter(
                                            (cast) => cast[1] === skillID
                                        ).length;
                                        if (!skill.isSwap) {
                                            skillList.push({
                                                name: skill.name,
                                                id: skillID,
                                            });
                                            selectedSkills[
                                                "s" + skillID
                                            ] = true;
                                        }
                                    }
                                }
                                skillList.sort((x, y) => {
                                    if (x.name < y.name) {
                                        return -1;
                                    }
                                    if (x.name > y.name) {
                                        return 1;
                                    }
                                    return 0;
                                });
                                phaseData.push({
                                    skillList: skillList,
                                    castCounts: castCounts,
                                });
                            }
                            return {
                                autoattack: true,
                                small: false,
                                smallAA: true,
                                hideInterruptedAA: false,
                                hasInstantCastUnconditional:
                                    hasInstantCastUnconditional,
                                hideInstantCast: false,
                                hideInstantCastSkill: false,
                                hideTraitProc: false,
                                hideUnconditionalProc: true,
                                hideGearProc: false,
                                hideSmallTime: true,
                                aftercastBorder: true,
                                interruptedBorder: true,
                                instantBorder: true,
                                unknownBorder: true,
                                highlightedSkill: null,
                                selectedSkills: selectedSkills,
                                phaseData: phaseData,
                            };
                        },
                        computed: {
                            rotation: function () {
                                var data = this.target
                                    ? logData.targets
                                    : logData.players;
                                var globalCast = 0;
                                var individualCasts = {};
                                return data[this.actorindex].details.rotation[
                                    this.phaseindex
                                ].map((cast) => {
                                    var skillID = cast[1];
                                    if (
                                        typeof individualCasts[skillID] !==
                                        "number"
                                    ) {
                                        individualCasts[skillID] = 0;
                                    }
                                    globalCast++;
                                    individualCasts[skillID]++;
                                    return {
                                        time: cast[0],
                                        skill: this.getSkill(cast[1]),
                                        duration: cast[2],
                                        type: cast[3],
                                        globalCast: globalCast,
                                        individualCast:
                                            individualCasts[skillID],
                                    };
                                });
                            },
                            RotationStatus: function () {
                                return RotationStatus;
                            },
                            skillList: function () {
                                return this.phaseData[this.phaseindex]
                                    .skillList;
                            },
                            castCounts: function () {
                                return this.phaseData[this.phaseindex]
                                    .castCounts;
                            },
                        },
                        methods: {
                            stopClickEvent: function (event) {
                                event.stopPropagation();
                            },
                            getSkill: function (id) {
                                return findSkill(false, id);
                            },
                            isSwap: function (id) {
                                return findSkill(false, id).isSwap;
                            },
                            showSkill: function (cast) {
                                var skill = cast.skill;
                                if (skill.isSwap) {
                                    return true;
                                }
                                if (!this.selectedSkills["s" + skill.id]) {
                                    return false;
                                }
                                var aa = skill.aa;
                                if (aa) {
                                    if (!this.autoattack) {
                                        return false;
                                    }
                                    if (
                                        this.hideInterruptedAA &&
                                        cast.type === RotationStatus.CANCEL
                                    ) {
                                        return false;
                                    }
                                }
                                var isInstant =
                                    cast.type === RotationStatus.INSTANT;
                                if (isInstant) {
                                    if (this.hideInstantCast) {
                                        return false;
                                    } else if (
                                        this.hideGearProc &&
                                        skill.gearProc
                                    ) {
                                        return false;
                                    } else if (
                                        this.hideTraitProc &&
                                        skill.traitProc
                                    ) {
                                        return false;
                                    } else if (
                                        this.hideUnconditionalProc &&
                                        skill.unconditionalProc
                                    ) {
                                        return false;
                                    } else if (
                                        this.hideInstantCastSkill &&
                                        !skill.traitProc &&
                                        !skill.gearProc &&
                                        !skill.unconditionalProc
                                    ) {
                                        return false;
                                    }
                                } else if (this.hideSmallTime) {
                                    return cast.duration > 10;
                                }
                                return true;
                            },
                            getCastClass(cast) {
                                return {
                                    "rot-swap": cast.skill.isSwap,
                                    "mb-1": cast.skill.isSwap,
                                    "rot-small":
                                        this.small ||
                                        (this.smallAA && cast.skill.aa),
                                    "rot-highlight":
                                        typeof this.highlightedSkill ===
                                        "number",
                                    "rot-highlight-active":
                                        cast.skill.id === this.highlightedSkill,
                                };
                            },
                            getIconClass(cast) {
                                return {
                                    "rot-cancelled":
                                        this.interruptedBorder &&
                                        cast.type === RotationStatus.CANCEL,
                                    "rot-animfull":
                                        this.aftercastBorder &&
                                        cast.type === RotationStatus.FULL,
                                    "rot-unknown":
                                        this.unknownBorder &&
                                        cast.type === RotationStatus.UNKNOWN,
                                    "rot-instant":
                                        this.instantBorder &&
                                        cast.type === RotationStatus.INSTANT,
                                };
                            },
                            getTooltip(cast) {
                                var tooltip = `${cast.skill.name} at ${cast.time}s`;
                                if (cast.type !== RotationStatus.INSTANT) {
                                    tooltip += ` for ${cast.duration}ms`;
                                }
                                tooltip += `<br>${cast.skill.name} cast ${
                                    cast.individualCast
                                } of ${this.castCounts[cast.skill.id]}`;
                                tooltip += `<br>Skill cast ${cast.globalCast} of ${this.rotation.length}`;
                                return tooltip;
                            },
                            setAllSelectedSkills(selected) {
                                for (
                                    var i = 0;
                                    i < this.skillList.length;
                                    i++
                                ) {
                                    this.selectedSkills[
                                        "s" + this.skillList[i].id
                                    ] = selected;
                                }
                            },
                            toggleHighlight(skill) {
                                this.highlightedSkill =
                                    this.highlightedSkill !== skill.id
                                        ? skill.id
                                        : null;
                            },
                        },
                    });
                }
                {
                    function getAdvancedRotationLayout(images, color, nbLines) {
                        var layout = {
                            barmode: "stack",
                            legend: {
                                traceorder: "reversed",
                            },
                            hovermode: "closest",
                            hoverdistance: 50,
                            images: images,
                            font: {
                                color: color,
                            },
                            xaxis: {
                                title: "Time(sec)",
                                color: color,
                                gridcolor: color,
                                rangemode: "nonnegative",
                                xrangeslider: {},
                                tickmode: "auto",
                                nticks: 8,
                            },
                            yaxis: {
                                tickmode: "auto",
                                color: color,
                                tickformat: ",d",
                                range: [-nbLines, 1],
                            },
                            paper_bgcolor: "rgba(0,0,0,0)",
                            plot_bgcolor: "rgba(0,0,0,0)",
                            shapes: [],
                            annotations: [],
                            margin: {
                                l: 150,
                            },
                            height: 850,
                            datarevision: new Date().getTime(),
                        };
                        return layout;
                    }

                    function computeAdvancedRotationData(
                        rotationData,
                        images,
                        data,
                        phase,
                        actor,
                        selectedSkills
                    ) {
                        if (rotationData) {
                            var rotaTrace = {
                                x: [],
                                base: [],
                                y: [],
                                name: actor.name,
                                text: [],
                                orientation: "h",
                                mode: "markers",
                                textposition: "none",
                                type: "bar",
                                width: [],
                                hoverinfo: "text",
                                hoverlabel: {
                                    namelength: "-1",
                                },
                                yaxis: "y",
                                marker: {
                                    color: [],
                                    width: "2.5",
                                    line: {
                                        color: [],
                                        width: "1.0",
                                    },
                                },
                                showlegend: false,
                            };
                            var timeOffset = 0;
                            var yOffset = 0;
                            for (var i = 0; i < rotationData.length; i++) {
                                var item = rotationData[i];
                                var x = item[0];
                                var skillId = item[1];
                                var duration = item[2];
                                var endType = item[3];
                                var quick = item[4];
                                var skill = findSkill(false, skillId);
                                var aa = false;
                                var icon;
                                var name = "???";
                                var swap = false;
                                if (skill) {
                                    aa = skill.aa;
                                    icon = skill.icon;
                                    name = skill.name;
                                    swap = skill.isSwap;
                                }
                                if (!swap && !selectedSkills["s" + skillId]) {
                                    continue;
                                }

                                if (
                                    !icon.includes("render") &&
                                    !icon.includes("darthmaim")
                                ) {
                                    icon = null;
                                }

                                var fillColor;
                                var originalDuration = duration;
                                if (endType == 1) {
                                    fillColor = "rgb(0,0,255)";
                                } else if (endType == 2) {
                                    fillColor = "rgb(255,0,0)";
                                } else if (endType == 3) {
                                    fillColor = "rgb(0,255,0)";
                                } else if (endType == 4) {
                                    fillColor = "rgb(0,255,255)";
                                    duration = 50;
                                } else {
                                    fillColor = "rgb(255,255,0)";
                                }

                                var clampedX = Math.max(x, 0);
                                var diffX = clampedX - x;
                                var clampedWidth =
                                    Math.min(
                                        x + duration / 1000.0,
                                        phase.duration / 1000.0
                                    ) -
                                    x -
                                    diffX;
                                clampedX -= timeOffset;
                                if (!aa && icon) {
                                    images.push({
                                        source: icon,
                                        xref: "x",
                                        yref: "y",
                                        x: clampedX,
                                        y: 0.0 - yOffset,
                                        sizex: 0.5,
                                        sizey: 0.5,
                                        xanchor: "middle",
                                        yanchor: "bottom",
                                    });
                                }

                                rotaTrace.x.push(clampedWidth - 0.001);
                                rotaTrace.base.push(clampedX);
                                rotaTrace.y.push(0.6 - yOffset);
                                var text = `${name} at ${x}s`;
                                rotaTrace.text.push(
                                    endType === RotationStatus.INSTANT
                                        ? text
                                        : text + ` for ${originalDuration}ms`
                                );
                                rotaTrace.width.push(aa ? 0.25 : 0.5);
                                rotaTrace.marker.color.push(fillColor);

                                var outlineR =
                                    quick > 0.0
                                        ? quick * quickColor.r +
                                          (1.0 - quick) * normalColor.r
                                        : -quick * slowColor.r +
                                          (1.0 + quick) * normalColor.r;
                                var outlineG =
                                    quick > 0.0
                                        ? quick * quickColor.g +
                                          (1.0 - quick) * normalColor.g
                                        : -quick * slowColor.g +
                                          (1.0 + quick) * normalColor.g;
                                var outlineB =
                                    quick > 0.0
                                        ? quick * quickColor.b +
                                          (1.0 - quick) * normalColor.b
                                        : -quick * slowColor.b +
                                          (1.0 + quick) * normalColor.b;
                                rotaTrace.marker.line.color.push(
                                    "rgb(" +
                                        outlineR +
                                        "," +
                                        outlineG +
                                        "," +
                                        outlineB +
                                        ")"
                                );
                                if (swap) {
                                    yOffset++;
                                    timeOffset = x;
                                }
                            }
                            data.push(rotaTrace);
                            return yOffset;
                        }
                        return 0;
                    }

                    Vue.component("advancedrotation-component", {
                        props: ["phaseindex", "light", "actorindex", "target"],
                        template: `    <div>        <div style="position:absolute; margin-top: 60px;  margin-left: 145px; z-index: 1;">            <a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Filter Skills" style="font-size: 1.1em;">                Skills <span class="caret"></span>            </a>            <ul class="dropdown-menu p-2 font-weight-normal scrollabledropdown" style="min-width: 165px; width:auto;">                <div class="d-flex flex-column justify-content-center align-items-center mb-1"                    style="border-bottom: 2px solid #bbb;">                    <li>                        <button style="width:160px; padding: 0.4rem 0.4rem;" type="button" class="btn btn-primary btn-sm"                            @click="for (var i = 0; i < skillList.length; i++) {selectedSkills['s' + skillList[i].id] = true;}" @click.stop="stopClickEvent">                            Select all                        </button>                    </li>                    <li class="mb-1">                        <button style="width:160px; padding: 0.4rem 0.4rem;" type="button" class="btn btn-primary btn-sm"                            @click="for (var i = 0; i < skillList.length; i++) {selectedSkills['s' + skillList[i].id] = false;}" @click.stop="stopClickEvent">                            Deselect all                        </button>                    </li>                </div>                <li v-for="(skill, index) in skillList" :key="index">                    <div style="width: max-content;">                        <input :id="'advanced-rotation-player-' + index  + '-' + phaseindex" type="checkbox"                            v-model="selectedSkills['s' + skill.id]" @click.stop="stopClickEvent" />                        <label :for="'advanced-rotation-player-' + index + '-' + phaseindex" @click.stop="stopClickEvent"                            style="font-size: 1.0em; white-space: nowrap; margin-top: 2px;">                                                                 <img class="icon"                                     :src="getSkill(skill.id).icon">                            {{skill.name}}                        </label>                      </div>                        </li>            </ul>        </div>        <graph-component :id="graphid" :layout="layout" :data="data" :removerangecontrol="true"></graph-component>        <rotation-legend-component></rotation-legend-component>    </div>`,
                        mixins: [graphComponent],
                        watch: {
                            light: {
                                handler: function () {
                                    var textColor = this.light
                                        ? "#495057"
                                        : "#cccccc";
                                    this.layout.yaxis.gridcolor = textColor;
                                    this.layout.yaxis.color = textColor;
                                    this.layout.xaxis.gridcolor = textColor;
                                    this.layout.xaxis.color = textColor;
                                    this.layout.font.color = textColor;
                                    for (
                                        var i = 0;
                                        i < this.layout.shapes.length;
                                        i++
                                    ) {
                                        this.layout.shapes[i].line.color =
                                            textColor;
                                    }
                                    this.layout.datarevision =
                                        new Date().getTime();
                                },
                            },
                            selectedSkills: {
                                deep: true,
                                handler: function () {
                                    this.computeLayout();
                                },
                            },
                        },
                        data: function () {
                            var selectedSkills = {};
                            var skillList = [];
                            var rotation = this.target
                                ? logData.targets[this.actorindex].details
                                      .rotation[this.phaseindex]
                                : logData.players[this.actorindex].details
                                      .rotation[this.phaseindex];
                            for (var i = 0; i < rotation.length; i++) {
                                var rota = rotation[i];
                                var skillID = rota[1];
                                var skill = this.getSkill(skillID);
                                if (
                                    skill.isSwap ||
                                    selectedSkills["s" + skillID]
                                ) {
                                    continue;
                                }
                                skillList.push({
                                    name: skill.name,
                                    id: skillID,
                                });
                                selectedSkills["s" + skillID] = true;
                            }
                            skillList.sort((x, y) => {
                                if (x.name < y.name) {
                                    return -1;
                                }
                                if (x.name > y.name) {
                                    return 1;
                                }
                                return 0;
                            });
                            return {
                                selectedSkills: selectedSkills,
                                skillList: skillList,
                            };
                        },
                        created: function () {
                            this.computeLayout();
                        },
                        activated: function () {
                            var div = document.getElementById(this.graphid);
                            var _this = this;
                            div.on("plotly_relayout", function (evt) {
                                var layout = _this.layout;
                                var images = layout.images;
                                var x0 = layout.xaxis.range[0];
                                var x1 = layout.xaxis.range[1];
                                var y0 = layout.yaxis.range[0];
                                var y1 = layout.yaxis.range[1];
                                //console.log("re-layout " + x0 + " " + x1);
                                if (
                                    _this.updateVisibilyInQuad(
                                        images,
                                        x0,
                                        x1,
                                        y0,
                                        y1
                                    )
                                ) {
                                    layout.datarevision = new Date().getTime();
                                    //console.log("re-drawing");
                                }
                            });
                        },
                        computed: {
                            phase: function () {
                                return logData.phases[this.phaseindex];
                            },
                            actor: function () {
                                return this.target
                                    ? logData.targets[this.actorindex]
                                    : logData.players[this.actorindex];
                            },
                            graphid: function () {
                                return (
                                    (this.target ? "target" : "player") +
                                    "advancedrotation-" +
                                    this.actorindex +
                                    "-" +
                                    this.phaseindex
                                );
                            },
                            rotation: function () {
                                return this.actor.details.rotation[
                                    this.phaseindex
                                ];
                            },
                        },
                        methods: {
                            computeLayout: function () {
                                var backUpXAxis = null;
                                if (this.layout) {
                                    backUpXAxis = this.layout.xaxis;
                                }
                                this.data = [];
                                var images = [];
                                var nbLines = computeAdvancedRotationData(
                                    this.rotation,
                                    images,
                                    this.data,
                                    this.phase,
                                    this.actor,
                                    this.selectedSkills
                                );
                                this.layout = getAdvancedRotationLayout(
                                    images,
                                    this.light ? "#495057" : "#cccccc",
                                    nbLines
                                );
                                if (backUpXAxis) {
                                    this.layout.xaxis = backUpXAxis;
                                }
                                this.updateVisibily(
                                    this.layout.images,
                                    this.phase.start,
                                    this.phase.end
                                );
                            },
                            stopClickEvent: function (event) {
                                event.stopPropagation();
                            },
                            getSkill: function (id) {
                                return findSkill(false, id);
                            },
                        },
                    });
                }
                {
                    Vue.component("support-stats-component", {
                        props: ["phaseindex", "playerindex"],
                        template: `    <div>        <table class="table table-sm table-striped table-hover" cellspacing="0" width="100%" :id="tableid">            <thead>                <tr>                    <th class="sub-cell" :class="getHeaderClass('Sub')" @click="sortBy('Sub')">                        Sub                    </th>                    <th class="prof-cell" :class="getHeaderClass('Prof')" @click="sortBy('Prof')">                    </th>                    <th class="text-left" :class="getHeaderClass('Name')" @click="sortBy('Name')">                        Name                    </th>                    <th class="text-left" :class="getHeaderClass('Account')" @click="sortBy('Account')">                        Account                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 0)" @click="sortBy('Data', 0)"                        data-original-title="Condition Cleanse on Squad Mates">                        <img :src="UIIcons.Cleanse"                            alt="Condition Cleanse on Others" class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 2)" @click="sortBy('Data', 2)"                        data-original-title="Condition Cleanse on Self">                        <img :src="UIIcons.CleanseSelf" alt="Condition Cleanse on Self"                            class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 4)" @click="sortBy('Data', 4)"                        data-original-title="Boon Strips">                        <img :src="UIIcons.Strip" alt="Boon Strips"                            class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 8)" @click="sortBy('Data', 8)"                        data-original-title="Stun Break">                        <img :src="UIIcons.StunBreak" alt="Stun Break"                            class="icon icon-hover">                    </th>                    <th class="stat-cell" :class="getHeaderClass('Data', 6)" @click="sortBy('Data', 6)"                        data-original-title="Resurrects">                        <img :src="UIIcons.DownedAlly" alt="Resurrects"                            class="icon icon-hover">                    </th>                </tr>            </thead>            <tbody>                <tr v-for="row in sortData(tableData.rows)" :class="{active: row.player.id === playerindex}">                    <td :class="getBodyClass('Sub')">                        {{row.player.group}}                    </td>                    <td :class="getBodyClass('Prof')" :data-original-title="row.player.profession">                        <img :src="row.player.icon" :alt="row.player.profession" class="icon"><span                            style="display:none">{{row.player.profession}}</span>                    </td>                    <td :class="getBodyClass('Name')" class="text-left">                        {{row.player.name}}                    </td>                    <td :class="getBodyClass('Account')" class="text-left">                        {{row.player.acc}}                    </td>                    <td :class="getBodyClass('Data', 0)" :data-original-title="row.sup[1] + ' seconds'">                        {{row.sup[0]}}                    </td>                    <td :class="getBodyClass('Data', 2)" :data-original-title="row.sup[3] + ' seconds'">                        {{row.sup[2]}}                    </td>                    <td :class="getBodyClass('Data', 4)" :data-original-title="row.sup[5] + ' seconds'">                        {{row.sup[4]}}                    </td>                    <td :class="getBodyClass('Data', 8)" :data-original-title="row.sup[9] + ' seconds'">                        {{row.sup[8]}}                    </td>                    <td :class="getBodyClass('Data', 6)" :data-original-title="row.sup[7] + ' seconds'">                        {{row.sup[6]}}                    </td>                </tr>            </tbody>            <tfoot>                <tr v-for="sum in tableData.sums">                    <td></td>                    <td></td>                    <td class="text-left">{{sum.name}}</td>                    <td></td>                    <td :data-original-title="round3(sum.sup[1]) + ' seconds'">{{sum.sup[0]}}</td>                    <td :data-original-title="round3(sum.sup[3])  + ' seconds'">{{sum.sup[2]}}</td>                    <td :data-original-title="round3(sum.sup[5])  + ' seconds'">{{sum.sup[4]}}</td>                    <td :data-original-title="round3(sum.sup[9])  + ' seconds'">{{sum.sup[8]}}</td>                    <td :data-original-title="round3(sum.sup[7])  + ' seconds'">{{sum.sup[6]}}</td>                </tr>            </tfoot>        </table>    </div>`,
                        mixins: [
                            numberComponent,
                            sortedTableComponent,
                            encounterPhaseComponent,
                        ],
                        data: function () {
                            return {
                                cache: new Map(),
                                sortdata: {
                                    order: "desc",
                                    index: -1,
                                    key: "Prof",
                                },
                            };
                        },
                        methods: {
                            sortBy: function (key, index) {
                                this.sortByBase(this.sortdata, key, index);
                            },
                            getHeaderClass: function (key, index) {
                                return this.getHeaderClassBase(
                                    this.sortdata,
                                    key,
                                    index
                                );
                            },
                            getBodyClass: function (key, index) {
                                var classes = this.getBodyClassBase(
                                    this.sortdata,
                                    key,
                                    index
                                );
                                return classes;
                            },
                            sortData: function (rows) {
                                var order =
                                    this.sortdata.order === "asc" ? 1 : -1;
                                switch (this.sortdata.key) {
                                    case "Sub":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    (x.player.group -
                                                        y.player.group) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Prof":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    this.sortByPlayerProfession(
                                                        x,
                                                        y
                                                    ) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Name":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Account":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                this.sortByPlayerAccount(x, y)
                                        );
                                        break;
                                    case "Data":
                                        var index = this.sortdata.index;
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    (x.sup[index] -
                                                        y.sup[index]) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    default:
                                        return null;
                                        break;
                                }
                                return rows;
                            },
                        },
                        computed: {
                            tableid: function () {
                                return "sup-table";
                            },
                            phase: function () {
                                return logData.phases[this.phaseindex];
                            },
                            tableData: function () {
                                const cacheID =
                                    this.encounterPhase.id +
                                    "-" +
                                    this.phaseindex;
                                if (this.cache.has(cacheID)) {
                                    return this.cache.get(cacheID);
                                }
                                const dataLength =
                                    this.phase.supportStats[0].length;
                                var rows = [];
                                var sums = [];
                                var total = new Array(dataLength).fill(0);
                                var groups = [];
                                const players = getActiveNonFakePlayersForPhase(
                                    this.encounterPhase
                                );
                                for (
                                    var i = 0;
                                    i < this.phase.supportStats.length;
                                    i++
                                ) {
                                    var sup = this.phase.supportStats[i];
                                    var player = players[i];
                                    if (!player) {
                                        continue;
                                    }
                                    rows.push({
                                        player: player,
                                        sup: sup,
                                    });
                                    if (!groups[player.group]) {
                                        groups[player.group] = new Array(
                                            dataLength
                                        ).fill(0);
                                    }
                                    for (var j = 0; j < sup.length; j++) {
                                        total[j] += sup[j];
                                        groups[player.group][j] += sup[j];
                                    }
                                }
                                for (var i = 0; i < groups.length; i++) {
                                    if (groups[i]) {
                                        sums.push({
                                            name: "Group " + i,
                                            sup: groups[i],
                                        });
                                    }
                                }
                                sums.push({
                                    name: "Total",
                                    sup: total,
                                });
                                var res = {
                                    rows: rows,
                                    sums: sums,
                                };
                                this.cache.set(cacheID, res);
                                return res;
                            },
                            UIIcons: function () {
                                return UIIcons;
                            },
                        },
                    });
                }
                {
                    Vue.component("target-component", {
                        props: ["targets", "phaseindex"],
                        template: `    <div class="d-flex flex-row justify-content-center flex-wrap" :style="{'width': totalWidth}">        <div class="d-flex flex-row justify-content-center align-items-center flex-wrap" style="max-width: 408px;">            <div v-for="target in mainTargets">                <img class="icon-lg mr-2 ml-2 target-cell"                     :src="getTargetData(target.id).icon"                     :alt="getTargetData(target.id).name"                    :data-original-title="getTargetData(target.id).name"                     :class="{active: target.data.active}"                    @click="target.data.active = !target.data.active">                <target-data-component :targetid="target.id"></target-data-component>            </div>        </div>        <div v-show="secondaryTargets.length > 0" class="ml-4 d-flex flex-column justify-content-center align-items-center" style="max-width: 362px;">                       <div class="d-flex flex-row justify-content-center align-items-center flex-wrap">                <div v-for="target in secondaryTargets">                    <img class=" icon-ll mr-2 ml-2 target-cell"                         :src="getTargetData(target.id).icon"                         :alt="getTargetData(target.id).name"                        :data-original-title="getTargetData(target.id).name"                         :class="{active: target.data.active}"                        @click="target.data.active = !target.data.active">                    <target-data-component :targetid="target.id"></target-data-component>                </div>            </div>            <div v-show="secondaryTargets.length > 1">                <ul class="scale85 nav nav-pills">                    <li class="nav-item">                        <a class="nav-link" @click="selectAllSecondaries(true)">                            Select All                        </a>                    </li>                    <li class="nav-item">                        <a class="nav-link" @click="selectAllSecondaries(false)">                            Deselect All                        </a>                    </li>                </ul>            </div>        </div>    </div>`,
                        computed: {
                            totalWidth: function () {
                                let totalWidth =
                                    Math.min(this.mainTargets.length, 5) * 80;
                                if (this.secondaryTargets.length > 0) {
                                    // margin between main and secondary
                                    totalWidth += 40;
                                    if (this.secondaryTargets.length == 2) {
                                        // Select all/deselect all are bigger than 2 icons
                                        totalWidth += 210;
                                    } else {
                                        totalWidth +=
                                            Math.min(
                                                this.secondaryTargets.length,
                                                5
                                            ) * 72;
                                    }
                                }
                                return `${totalWidth}px`;
                            },
                            phase: function () {
                                return logData.phases[this.phaseindex];
                            },
                            mainTargets: function () {
                                let result = [];
                                for (let i = 0; i < this.targets.length; i++) {
                                    let target =
                                        this.targets[i][this.phaseindex];
                                    if (!target.secondary && this.show(i)) {
                                        result.push({ id: i, data: target });
                                    }
                                }
                                return result;
                            },
                            secondaryTargets: function () {
                                let result = [];
                                for (let i = 0; i < this.targets.length; i++) {
                                    let target =
                                        this.targets[i][this.phaseindex];
                                    if (target.secondary && this.show(i)) {
                                        result.push({ id: i, data: target });
                                    }
                                }
                                return result;
                            },
                        },
                        methods: {
                            show: function (index) {
                                return this.phase.targets.indexOf(index) !== -1;
                            },
                            selectAllSecondaries: function (onOff) {
                                for (
                                    let i = 0;
                                    i < this.secondaryTargets.length;
                                    i++
                                ) {
                                    this.secondaryTargets[i].data.active =
                                        onOff;
                                }
                            },
                            getTargetData: function (id) {
                                return logData.targets[id];
                            },
                        },
                    });
                }
                {
                    function getDefaultTargetTabSubComponent() {
                        if (!validateStartPath("Statistics/TargetsSummary")) {
                            return [-1, 0];
                        }
                        const setting = EIUrlParams.get("startPage");
                        const selectedTarget = setting.split("/")[2];
                        if (!selectedTarget) {
                            return [-1, 0];
                        }
                        const compo = setting.split("/")[3];
                        let component = 0;
                        switch (compo) {
                            case "OutgoingDamage":
                                component = 0;
                                break;
                            case "IncomingDamage":
                                component = 1;
                                break;
                            case "Graph":
                                component = 2;
                                break;
                            case "GraphPerPlayer":
                                component = 5;
                                break;
                            case "BuffStatus":
                                component = 4;
                                break;
                            case "SimpleRotation":
                                component = 3;
                                break;
                        }
                        return [parseInt(selectedTarget), component];
                    }
                    Vue.component("target-stats-component", {
                        props: [
                            "playerindex",
                            "phaseindex",
                            "light",
                            "simplephase",
                        ],
                        template: `    <div>        <ul v-if="phaseTargets.length > 1" class=" nav nav-tabs">            <li v-for="target in phaseTargets">                <a class="nav-link" :class="{active: simplephase.focus === target.id}"                    @click="simplephase.focus = target.id">                    {{target.name}}                </a>            </li>        </ul>        <div v-for="target in phaseTargets" v-show="simplephase.focus === target.id">            <div class="d-flex flex-row justify-content-center align-items-center">                <div class="d-flex flex-column justify-content-center align-items-center">                    <img :alt="target.name" class="icon-lg mt-2" :src="target.icon">                    <target-data-component :targetid="target.id"></target-data-component>                </div>                <h3 class="text-center mt-2">{{target.name}}</h3>            </div>        </div>        <ul class="nav nav-tabs" v-show="phaseTargets.length > 0">            <li>                <a class="nav-link" :class="{active: mode === 0}" @click="mode = 0">                    Outgoing Damage                </a>            </li>            <li>                <a class="nav-link" :class="{active: mode === 1}" @click="mode = 1">                    Incoming Damage                </a>            </li>            <li>                <a class="nav-link" :class="{active: mode === 2}" @click="mode = 2">Graph</a>            </li>            <li>                <a class="nav-link" :class="{active: mode === 5}" @click="mode = 5">Graph Per Player</a>            </li>            <li>                <a class="nav-link" :class="{active: mode === 3}" @click="mode = 3">Simple Rotation</a>            </li>            <li>                <a class="nav-link" :class="{active: mode === 4}" @click="mode = 4">Buff Status</a>            </li>        </ul>        <keep-alive>            <target-tab-component v-for="target in targets" :key="target.id" v-if="simplephase.focus === target.id"                :targetindex="target.id" :phaseindex="phaseindex" :playerindex="playerindex" :mode="mode"                :light="light"></target-tab-component>        </keep-alive>    </div>`,
                        data: function () {
                            const modes = getDefaultTargetTabSubComponent();
                            return {
                                mode: modes[1],
                                initTarget: modes[0],
                            };
                        },
                        computed: {
                            phase: function () {
                                return logData.phases[this.phaseindex];
                            },
                            targets: function () {
                                return logData.targets;
                            },
                            phaseTargets: function () {
                                var res = [];
                                for (
                                    var i = 0;
                                    i < this.phase.targets.length;
                                    i++
                                ) {
                                    var tar =
                                        logData.targets[this.phase.targets[i]];
                                    res.push(tar);
                                }
                                if (this.initTarget >= 0) {
                                    if (res[this.initTarget]) {
                                        this.simplephase.focus =
                                            res[this.initTarget].id;
                                    }
                                    this.initTarget = -1;
                                }
                                if (this.simplephase.focus === -1) {
                                    this.simplephase.focus = res[0]
                                        ? res[0].id
                                        : -1;
                                }
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("target-tab-component", {
                        props: [
                            "phaseindex",
                            "playerindex",
                            "targetindex",
                            "mode",
                            "light",
                        ],
                        template: `    <div>        <keep-alive>            <dmgdist-target-component v-if="mode === 0" :key="'dist' + targetindex" :phaseindex="phaseindex"                :targetindex="targetindex"></dmgdist-target-component>            <dmgtakendist-target-component v-if="mode === 1" :targetindex="targetindex" :key="'taken' + targetindex"                :phaseindex="phaseindex"></dmgtakendist-target-component>            <target-graph-tab-component v-for="(ph, id) in phases" v-if="mode === 2 && id === phaseindex" :key="id"                :targetindex="targetindex" :phaseindex="id" :light="light"></target-graph-tab-component>            <targetperplayer-graphs-tab-component v-for="(ph, id) in phases" v-if="mode === 5 && id === phaseindex" :key="id + 'perplayer'"                 :targetindex="targetindex" :phaseindex="id" :playerindex="playerindex" :light="light">            </targetperplayer-graphs-tab-component>            <simplerotation-component v-if="mode === 3" :key="'rot' + targetindex" :actorindex="targetindex"                :phaseindex="phaseindex" :target="true"></simplerotation-component>            <target-buff-tab-component v-if="mode === 4" :key="'buffs' + targetindex" :targetindex="targetindex"                :phaseindex="phaseindex" :playerindex="playerindex"></target-buff-tab-component>        </keep-alive>    </div>`,
                        computed: {
                            phases: function () {
                                return logData.phases;
                            },
                        },
                    });
                }
                {
                    Vue.component("dps-graph-component", {
                        props: [
                            "activetargets",
                            "mode",
                            "phaseindex",
                            "playerindex",
                            "light",
                        ],
                        template: `    <div>              <dps-graph-mode-selector-component :data="graphdata"            :phaseduration="this.phase.end - this.phase.start" :phasehassubphases="!!this.phase.subPhases" :ignorebreakbar="false" :column="false">        </dps-graph-mode-selector-component>        <h3 class="text-center mt-1 mb-1">{{graphname}}</h3>        <graph-component :id="graphid" :layout="layout" :data="computeData"></graph-component>    </div>`,
                        mixins: [
                            graphComponent,
                            damageGraphComponent,
                            encounterPhaseComponent,
                        ],
                        created: function () {
                            this.computeLayout();
                        },
                        watch: {
                            playerindex: {
                                handler: function () {
                                    const players = getActivePlayersForPhase(
                                        this.encounterPhase
                                    ).filter((x) => !!x);
                                    for (let i = 0; i < players.length; i++) {
                                        this.data[i].line.width =
                                            players[i].id === this.playerindex
                                                ? 5
                                                : 2;
                                    }
                                    this.layout.datarevision =
                                        new Date().getTime();
                                },
                                deep: true,
                            },
                            light: {
                                handler: function () {
                                    var textColor = this.light
                                        ? "#495057"
                                        : "#cccccc";
                                    this.layout.yaxis.gridcolor = textColor;
                                    this.layout.yaxis.color = textColor;
                                    this.layout.xaxis.gridcolor = textColor;
                                    this.layout.xaxis.color = textColor;
                                    this.layout.font.color = textColor;
                                    for (
                                        var i = 0;
                                        i < this.layout.shapes.length;
                                        i++
                                    ) {
                                        this.layout.shapes[i].line.color =
                                            textColor;
                                    }
                                    this.layout.datarevision =
                                        new Date().getTime();
                                },
                            },
                            encounters: {
                                deep: true,
                                handler: function () {
                                    this.computeLayout();
                                },
                            },
                        },
                        computed: {
                            graphid: function () {
                                return "dpsgraph-" + this.phaseindex;
                            },
                            damageGraphName: function () {
                                switch (this.graphdata.damagemode) {
                                    case DamageType.All:
                                        return "damage";
                                    case DamageType.Power:
                                        return "powerDamage";
                                    case DamageType.Condition:
                                        return "conditionDamage";
                                    case DamageType.Breakbar:
                                        return "breakbarDamage";
                                    default:
                                        throw new Error(
                                            "unknown enum in damage graph name"
                                        );
                                }
                            },
                            graphname: function () {
                                var name = getDamageGraphName(
                                    this.graphdata.damagemode,
                                    this.graphdata.graphmode
                                );
                                switch (this.graphdata.dpsmode) {
                                    case 0:
                                        name = "Full " + name;
                                        break;
                                    case -1:
                                        name = "Phase " + name;
                                        break;
                                    default:
                                        name =
                                            this.graphdata.dpsmode +
                                            "s " +
                                            name;
                                        break;
                                }
                                name =
                                    (this.mode === 0
                                        ? "Total "
                                        : this.mode === 1
                                        ? "Target "
                                        : this.mode === 2
                                        ? "Cleave "
                                        : "Taken ") + name;
                                return name;
                            },
                            computeData: function () {
                                this.layout.datarevision = new Date().getTime();
                                this.layout.yaxis.title = graphTypeEnumToString(
                                    this.graphdata.graphmode
                                );
                                var points = this.computeDPSRelatedData();
                                var res = this.data;
                                for (var i = 0; i < points.length; i++) {
                                    res[i].y = points[i];
                                }
                                return res;
                            },
                        },
                        methods: {
                            computeLayout: function () {
                                var textColor = this.light
                                    ? "#495057"
                                    : "#cccccc";
                                this.layout = {
                                    yaxis: {
                                        title: "DPS",
                                        fixedrange: true,
                                        rangemode: "tozero",
                                        gridcolor: textColor,
                                        tickformat: ",d",
                                        color: textColor,
                                    },
                                    xaxis: {
                                        title: "Time(sec)",
                                        color: textColor,
                                        gridcolor: textColor,
                                        rangemode: "nonnegative",
                                        tickmode: "auto",
                                        nticks: 8,
                                        xrangeslider: {},
                                    },
                                    hovermode: "x",
                                    hoverdistance: 150,
                                    font: {
                                        color: textColor,
                                    },
                                    paper_bgcolor: "rgba(0,0,0,0)",
                                    plot_bgcolor: "rgba(0,0,0,0)",
                                    displayModeBar: false,
                                    shapes: [],
                                    annotations: [],
                                    autosize: true,
                                    height: 850,
                                    datarevision: new Date().getTime(),
                                };
                                computePhaseMarkups(
                                    this.layout.shapes,
                                    this.layout.annotations,
                                    this.phase,
                                    textColor
                                );
                                // constant part of data
                                // dps
                                this.data = [];
                                var data = this.data;
                                const players = getActivePlayersForPhase(
                                    this.encounterPhase
                                );
                                for (var i = 0; i < players.length; i++) {
                                    var pText = [];
                                    const player = players[i];
                                    if (!player) {
                                        continue;
                                    }
                                    for (
                                        var j = 0;
                                        j < this.phase.times.length;
                                        j++
                                    ) {
                                        pText.push(player.name);
                                    }
                                    data.push({
                                        x: this.phase.times,
                                        y: [],
                                        mode: "lines",
                                        line: {
                                            shape: "spline",
                                            color: player.colTarget,
                                            width:
                                                i === this.playerindex ? 5 : 2,
                                        },
                                        text: pText,
                                        hoverinfo: "y+text+x",
                                        name: player.name,
                                    });
                                }
                                data.push({
                                    x: this.phase.times,
                                    mode: "lines",
                                    line: {
                                        shape: "spline",
                                    },
                                    hoverinfo: "name+y+x",
                                    visible: "legendonly",
                                    name: "All Players",
                                });
                                // targets health
                                computeTargetHealthData(
                                    this.graph,
                                    logData.targets,
                                    this.phase,
                                    this.data,
                                    null
                                );
                                // targets barrier
                                computeTargetBarrierData(
                                    this.graph,
                                    logData.targets,
                                    this.phase,
                                    this.data,
                                    null
                                );
                                // targets breakbar
                                computeTargetBreakbarData(
                                    this.graph,
                                    logData.targets,
                                    this.phase,
                                    this.data,
                                    null
                                );
                                // mechanics
                                addMechanicsToGraph(
                                    data,
                                    this.phase,
                                    this.phaseindex
                                );
                            },
                            computeDPS: function (lim, phasebreaks, cacheID) {
                                var maxDPS = {
                                    total: 0,
                                    cleave: 0,
                                    target: 0,
                                    taken: 0,
                                };
                                var allDPS = {
                                    total: [],
                                    cleave: [],
                                    target: [],
                                    taken: [],
                                };
                                var playerDPS = [];
                                var damageArrayToUse = this.damageGraphName;
                                const players = getActivePlayersForPhase(
                                    this.encounterPhase
                                );
                                for (var i = 0; i < players.length; i++) {
                                    const player = players[i];
                                    if (!player) {
                                        continue;
                                    }
                                    var data = computePlayerDPS(
                                        player,
                                        this.graph.players[i][damageArrayToUse],
                                        lim,
                                        phasebreaks,
                                        this.activetargets,
                                        cacheID,
                                        this.phase.times,
                                        this.graphdata.graphmode,
                                        this.graphdata.damagemode
                                    );
                                    playerDPS.push(data.dps);
                                    maxDPS.total = Math.max(
                                        maxDPS.total,
                                        data.maxDPS.total
                                    );
                                    maxDPS.cleave = Math.max(
                                        maxDPS.cleave,
                                        data.maxDPS.cleave
                                    );
                                    maxDPS.target = Math.max(
                                        maxDPS.target,
                                        data.maxDPS.target
                                    );
                                    maxDPS.taken = Math.max(
                                        maxDPS.taken,
                                        data.maxDPS.taken
                                    );
                                    for (
                                        var j = 0;
                                        j < data.dps.total.length;
                                        j++
                                    ) {
                                        allDPS.total[j] =
                                            (allDPS.total[j] || 0) +
                                            data.dps.total[j];
                                        allDPS.cleave[j] =
                                            (allDPS.cleave[j] || 0) +
                                            data.dps.cleave[j];
                                        allDPS.target[j] =
                                            (allDPS.target[j] || 0) +
                                            data.dps.target[j];
                                        allDPS.taken[j] =
                                            (allDPS.taken[j] || 0) +
                                            data.dps.taken[j];
                                    }
                                }

                                return {
                                    allDPS: allDPS,
                                    playerDPS: playerDPS,
                                    maxDPS: maxDPS,
                                };
                            },
                            computeDPSData: function () {
                                const cacheID = getDPSGraphCacheID(
                                    this.graphdata.dpsmode,
                                    this.graphdata.damagemode,
                                    this.graphdata.graphmode,
                                    this.activetargets,
                                    this.phaseindex,
                                    null
                                );
                                const internalCacheID =
                                    this.encounterPhase.id + "-" + cacheID;
                                if (this.dpsCache.has(internalCacheID)) {
                                    return this.dpsCache.get(internalCacheID);
                                }
                                var res;
                                if (this.graphdata.dpsmode >= 0) {
                                    res = this.computeDPS(
                                        this.graphdata.dpsmode,
                                        null,
                                        cacheID
                                    );
                                } else {
                                    res = this.computeDPS(
                                        0,
                                        this.computePhaseBreaks,
                                        cacheID
                                    );
                                }
                                this.dpsCache.set(internalCacheID, res);
                                return res;
                            },
                            computeDPSRelatedData: function () {
                                const cacheID =
                                    this.encounterPhase.id +
                                    "-" +
                                    getDPSGraphCacheID(
                                        this.graphdata.dpsmode,
                                        this.graphdata.damagemode,
                                        this.graphdata.graphmode,
                                        this.activetargets,
                                        this.phaseindex,
                                        this.mode
                                    );
                                if (this.dataCache.has(cacheID)) {
                                    return this.dataCache.get(cacheID);
                                }
                                var res = [];
                                var dpsData = this.computeDPSData();
                                var offset = 0;
                                var attributeToUse = null;
                                switch (this.mode) {
                                    case 0:
                                        attributeToUse = "total";
                                        break;
                                    case 1:
                                        attributeToUse = "target";
                                        break;
                                    case 2:
                                        attributeToUse = "cleave";
                                        break;
                                    case 3:
                                        attributeToUse = "taken";
                                        break;
                                }
                                for (i = 0; i < dpsData.playerDPS.length; i++) {
                                    var pDPS = dpsData.playerDPS[i];
                                    res.push(pDPS[attributeToUse]);
                                }
                                res.push(dpsData.allDPS[attributeToUse]);
                                var maxDPS = dpsData.maxDPS[attributeToUse];
                                var hps = [];
                                for (
                                    var i = 0;
                                    i < this.graph.targets.length;
                                    i++
                                ) {
                                    var health =
                                        this.graph.targets[i].healthStates;
                                    addPointsToGraph(res, health, maxDPS);
                                }
                                for (
                                    var i = 0;
                                    i < this.graph.targets.length;
                                    i++
                                ) {
                                    var barrier =
                                        this.graph.targets[i].barrierStates;
                                    addPointsToGraph(res, barrier, maxDPS);
                                }
                                for (
                                    var i = 0;
                                    i < this.graph.targets.length;
                                    i++
                                ) {
                                    var breakbar =
                                        this.graph.targets[i]
                                            .breakbarPercentStates;
                                    addPointsToGraph(res, breakbar, maxDPS);
                                }
                                updateMechanicsYValues(
                                    res,
                                    this.phase,
                                    this.phaseindex,
                                    this.graph,
                                    getActivePlayersForPhase(
                                        this.encounterPhase
                                    ),
                                    maxDPS
                                );
                                this.dataCache.set(cacheID, res);
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("dps-graph-mode-selector-component", {
                        props: [
                            "data",
                            "phaseduration",
                            "phasehassubphases",
                            "ignorebreakbar",
                            "column",
                        ],
                        template: `    <div class="d-flex flex-row justify-content-center mt-1 mb-1">             <ul class="nav nav-pills d-flex flex-wrap justify-content-center mr-3 scale85" :class="{'flex-row': !column, 'flex-column': column}">            <li class="nav-item d-flex flex-row justify-content-center align-items-center">                <a class="nav-link" @click="data.dpsmode = 0" :class="{active: data.dpsmode === 0}">Full</a>            </li>            <li v-if="phaseduration > 4" class="nav-item d-flex flex-row justify-content-center align-items-center">                <a class="nav-link" @click="data.dpsmode = 4" :class="{active: data.dpsmode === 4}">4s</a>            </li>            <li v-if="phaseduration > 10" class="nav-item d-flex flex-row justify-content-center align-items-center">                <a class="nav-link" @click="data.dpsmode = 10" :class="{active: data.dpsmode === 10}">10s</a>            </li>            <li v-if="phaseduration > 20" class="nav-item d-flex flex-row justify-content-center align-items-center">                <a class="nav-link" @click="data.dpsmode = 20" :class="{active: data.dpsmode === 20}">20s</a>            </li>            <li v-if="phaseduration > 30" class="nav-item d-flex flex-row justify-content-center align-items-center">                <a class="nav-link" @click="data.dpsmode = 30" :class="{active: data.dpsmode === 30}">30s</a>            </li>            <li v-if="phasehassubphases" class="nav-item d-flex flex-row justify-content-center align-items-center">                <a class="nav-link" @click="data.dpsmode = -1" :class="{active: data.dpsmode === -1}">Phase</a>            </li>            <li class="nav-item d-flex flex-row justify-content-center align-items-center">                <custom-numberform-component :minValue="0" :maxValue="Math.floor(phaseduration / 2) * 2" :id="'customDPS'"                                                   :placeholderValue="0"></custom-numberform-component>            </li>                </ul>            <ul class="nav nav-pills d-flex flex-wrap justify-content-center ml-3 scale85" :class="{'flex-row': !column, 'flex-column': column}">            <li class="nav-item d-flex flex-row justify-content-center align-items-center" data-original-title="Power + Condition">                <a class="nav-link" @click="data.damagemode = damageModeEnum.All" :class="{active: data.damagemode === damageModeEnum.All}">                    <img :src="UIIcons.Damage" alt="All"                    class="icon"></a>            </li>                <li class="nav-item d-flex flex-row justify-content-center align-items-center" data-original-title="Power">                <a class="nav-link" @click="data.damagemode = damageModeEnum.Power" :class="{active: data.damagemode === damageModeEnum.Power}">                    <img :src="UIIcons.Power" alt="Power"                    class="icon"></a>            </li>                                 <li class="nav-item d-flex flex-row justify-content-center align-items-center" data-original-title="Condition">                <a class="nav-link" @click="data.damagemode = damageModeEnum.Condition" :class="{active: data.damagemode === damageModeEnum.Condition}">                    <img :src="UIIcons.ConditionDamage" alt="Condition"                    class="icon"></a>            </li>            <li class="nav-item d-flex flex-row justify-content-center align-items-center" v-if="hasBreakbarDamage" data-original-title="Breakbar">                <a class="nav-link" @click="data.damagemode = damageModeEnum.Breakbar" :class="{active: data.damagemode === damageModeEnum.Breakbar}">                     <img :src="UIIcons.Breakbar" alt="Breakbar"                    class="icon"></a>            </li>        </ul>        <ul class="nav nav-pills d-flex flex-wrap justify-content-center ml-3 scale85" :class="{'flex-row': !column, 'flex-column': column}">            <li class="nav-item d-flex flex-row justify-content-center align-items-center">                <a class="nav-link" @click="data.graphmode = graphModeEnum.DPS" :class="{active: data.graphmode === graphModeEnum.DPS}">PS</a>            </li>                <li class="nav-item d-flex flex-row justify-content-center align-items-center" data-original-title="Centered">                <a class="nav-link" @click="data.graphmode = graphModeEnum.CenteredDPS" :class="{active: data.graphmode === graphModeEnum.CenteredDPS}">Ctrd.PS</a>            </li>                                 <li class="nav-item d-flex flex-row justify-content-center align-items-center">                <a class="nav-link" @click="data.graphmode = graphModeEnum.Damage" :class="{active: data.graphmode === graphModeEnum.Damage}">Cumulative</a>            </li>        </ul>    </div>`,
                        mounted() {
                            var _this = this;
                            $("#customDPS").on("input ", function () {
                                _this.data.dpsmode =
                                    Math.ceil(
                                        Number.parseFloat($(this).val()) / 2
                                    ) * 2;
                            });
                            $("#customDPS").on("click ", function () {
                                _this.data.dpsmode =
                                    Math.ceil(
                                        Number.parseFloat($(this).val()) / 2
                                    ) * 2;
                            });
                        },
                        computed: {
                            graphModeEnum: function () {
                                return GraphType;
                            },
                            damageModeEnum: function () {
                                return DamageType;
                            },
                            hasBreakbarDamage: function () {
                                return (
                                    !this.ignorebreakbar &&
                                    logData.hasBreakbarDamage
                                );
                            },
                            UIIcons: function () {
                                return UIIcons;
                            },
                        },
                    });
                }
                {
                    function getDefaultGraphSubComponent() {
                        if (!validateStartPath("Statistics/Graph")) {
                            return logData.targetless ? 0 : 1;
                        }
                        const setting = EIUrlParams.get("startPage");
                        const compo = setting.split("/")[2];
                        switch (compo) {
                            case "Total":
                                return 0;
                            case "Target":
                                return logData.targetless ? 0 : 1;
                            case "Cleave":
                                return logData.targetless ? 0 : 2;
                            case "Taken":
                                return 3;
                        }
                        return logData.targetless ? 0 : 1;
                    }
                    Vue.component("graph-stats-component", {
                        props: [
                            "activetargets",
                            "phaseindex",
                            "playerindex",
                            "light",
                        ],
                        template: `    <div>        <div>            <ul class="nav nav-tabs">                <li>                    <a class="nav-link" :class="{active: mode === 0}" @click="mode = 0">Total</a>                </li>                <li v-if="!targetless">                    <a class="nav-link" :class="{active: mode === 1}" @click="mode = 1">Target</a>                </li>                <li v-if="!targetless">                    <a class="nav-link" :class="{active: mode === 2}" @click="mode = 2">Cleave</a>                </li>                <li>                    <a class="nav-link" :class="{active: mode === 3}" @click="mode = 3">Taken</a>                </li>            </ul>        </div>        <keep-alive>            <dps-graph-component v-for="(phase, id) in phases" :key="id" v-if="id === phaseindex"                :activetargets="activetargets" :mode="mode" :phaseindex="id" :playerindex="playerindex" :light="light">            </dps-graph-component>        </keep-alive>    </div>`,
                        data: function () {
                            return {
                                targetless: logData.targetless,
                                mode: getDefaultGraphSubComponent(),
                            };
                        },
                        computed: {
                            phases: function () {
                                return logData.phases;
                            },
                        },
                    });
                }
                {
                    function getDefaultPlayerBuffTabSubComponent() {
                        if (
                            !validateStartPath(
                                "Statistics/PlayerSummary/BoonStatus"
                            ) &&
                            !validateStartPath(
                                "HealingStatistics/PlayerSummary/BoonStatus"
                            )
                        ) {
                            return 0;
                        }
                        const setting = EIUrlParams.get("startPage");
                        const compo = setting.split("/")[3];
                        switch (compo) {
                            case "Uptimes":
                                return 0;
                            case "Volumes":
                                return 1;
                        }
                        return 0;
                    }
                    Vue.component("player-buff-tab-component", {
                        props: ["phaseindex", "playerindex"],
                        template: `    <div>        <ul class="nav nav-tabs">            <li>                <a class="nav-link" :class="{active: tab === 0}" @click="tab = 0">Uptimes</a>            </li>            <li v-if="hasOffBuffs">                <a class="nav-link" :class="{active: tab === 1}" @click="tab = 1">Volumes</a>            </li>        </ul>        <keep-alive>            <buff-stats-player-component v-if="tab == 0" :key="'player-buff-tables'":phaseindex="phaseindex"                :playerindex="playerindex"></buff-stats-player-component>            <buff-volume-stats-player-component v-if="tab == 1" :key="'player-buff-volume-tables'" :phaseindex="phaseindex"                :playerindex="playerindex"></buff-volume-stats-player-component>        </keep-alive>    </div>`,
                        data: function () {
                            return {
                                tab: getDefaultPlayerBuffTabSubComponent(),
                            };
                        },
                    });
                }
                {
                    Vue.component("player-graph-tab-component", {
                        props: [
                            "playerindex",
                            "phaseindex",
                            "activetargets",
                            "light",
                        ],
                        template: `    <div>        <dps-graph-mode-selector-component :data="graphdata" :phaseduration="this.phase.end - this.phase.start"            :phasehassubphases="!!this.phase.subPhases" :ignorebreakbar="false" :column="false">        </dps-graph-mode-selector-component>        <h3 class="text-center mt-1 mb-1">{{graphname}}</h3>        <graph-component :id="graphid" :layout="layout" :data="computeData"></graph-component>        <rotation-legend-component></rotation-legend-component>    </div>`,
                        mixins: [
                            graphComponent,
                            damageGraphComponent,
                            encounterPhaseComponent,
                        ],
                        data: function () {
                            return {
                                playerOffset: 0,
                                graphOffset: 0,
                            };
                        },
                        watch: {
                            light: {
                                handler: function () {
                                    var textColor = this.light
                                        ? "#495057"
                                        : "#cccccc";
                                    this.layout.yaxis.gridcolor = textColor;
                                    this.layout.yaxis.color = textColor;
                                    this.layout.yaxis2.gridcolor = textColor;
                                    this.layout.yaxis2.color = textColor;
                                    this.layout.yaxis3.gridcolor = textColor;
                                    this.layout.yaxis3.color = textColor;
                                    this.layout.yaxis4.gridcolor = textColor;
                                    this.layout.yaxis4.color = textColor;
                                    this.layout.yaxis5.gridcolor = textColor;
                                    this.layout.yaxis5.color = textColor;
                                    this.layout.xaxis.gridcolor = textColor;
                                    this.layout.xaxis.color = textColor;
                                    this.layout.font.color = textColor;
                                    for (
                                        var i = 0;
                                        i < this.layout.shapes.length;
                                        i++
                                    ) {
                                        this.layout.shapes[i].line.color =
                                            textColor;
                                    }
                                    this.layout.datarevision =
                                        new Date().getTime();
                                },
                            },
                            encounters: {
                                deep: true,
                                handler: function () {
                                    this.computeLayout();
                                },
                            },
                        },
                        created: function () {
                            this.computeLayout();
                        },
                        activated: function () {
                            var div = document.getElementById(this.graphid);
                            var layout = this.layout;
                            var images = layout.images;
                            var _this = this;
                            div.on("plotly_relayout", function (evt) {
                                var x0 = layout.xaxis.range[0];
                                var x1 = layout.xaxis.range[1];
                                //console.log("re-layout " + x0 + " " + x1);
                                if (_this.updateVisibily(images, x0, x1)) {
                                    layout.datarevision = new Date().getTime();
                                    //console.log("re-drawing");
                                }
                            });
                        },
                        computed: {
                            healthGraph: function () {
                                return this.graph.players[this.playerindex]
                                    .healthStates;
                            },
                            barrierGraph: function () {
                                return this.graph.players[this.playerindex]
                                    .barrierStates;
                            },
                            graphid: function () {
                                return (
                                    "playergraph-" +
                                    this.playerindex +
                                    "-" +
                                    this.phaseindex
                                );
                            },
                            player: function () {
                                return logData.players[this.playerindex];
                            },
                            damageGraphName: function () {
                                switch (this.graphdata.damagemode) {
                                    case DamageType.All:
                                        return "damage";
                                    case DamageType.Power:
                                        return "powerDamage";
                                    case DamageType.Condition:
                                        return "conditionDamage";
                                    case DamageType.Breakbar:
                                        return "breakbarDamage";
                                    default:
                                        throw new Error(
                                            "unknown enum in damage graph name"
                                        );
                                }
                            },
                            graphname: function () {
                                var name = getDamageGraphName(
                                    this.graphdata.damagemode,
                                    this.graphdata.graphmode
                                );
                                switch (this.graphdata.dpsmode) {
                                    case 0:
                                        name = "Full " + name;
                                        break;
                                    case -1:
                                        name = "Phase " + name;
                                        break;
                                    default:
                                        name =
                                            this.graphdata.dpsmode +
                                            "s " +
                                            name;
                                        break;
                                }
                                return name;
                            },
                            computeData: function () {
                                this.layout.datarevision = new Date().getTime();
                                //this.layout.yaxis3.title = graphTypeEnumToString(this.graphdata.graphmode);
                                var res = this.data;
                                var data = this.computeDPSRelatedData();
                                this.data[this.playerOffset].y = data[3];
                                if (!logData.targetless) {
                                    this.data[this.playerOffset + 1].y =
                                        data[2];
                                    this.data[this.playerOffset + 2].y =
                                        data[1];
                                    this.data[this.playerOffset + 3].y =
                                        data[0];
                                } else {
                                    this.data[this.playerOffset + 1].y =
                                        data[0];
                                }
                                var offset = 4;
                                for (
                                    var i = this.graphOffset;
                                    i < this.playerOffset;
                                    i++
                                ) {
                                    this.data[i].y = data[offset++];
                                }
                                return res;
                            },
                        },
                        methods: {
                            computeLayout() {
                                var images = [];
                                this.data = [];
                                this.playerOffset += computeRotationData(
                                    this.player.details.rotation[
                                        this.phaseindex
                                    ],
                                    images,
                                    this.data,
                                    this.phase,
                                    this.player,
                                    1
                                );
                                var oldOffset = this.playerOffset;
                                this.playerOffset += computeBuffData(
                                    this.player.details.boonGraph[
                                        this.phaseindex
                                    ],
                                    this.data
                                );
                                var hasBuffs = oldOffset !== this.playerOffset;
                                this.graphOffset = this.playerOffset;
                                this.playerOffset += computeTargetBreakbarData(
                                    this.graph,
                                    logData.targets,
                                    this.phase,
                                    this.data,
                                    "y3"
                                );
                                this.playerOffset += computeTargetBarrierData(
                                    this.graph,
                                    logData.targets,
                                    this.phase,
                                    this.data,
                                    "y3"
                                );
                                this.playerOffset += computeTargetHealthData(
                                    this.graph,
                                    logData.targets,
                                    this.phase,
                                    this.data,
                                    "y3"
                                );
                                this.playerOffset += computePlayerBarrierData(
                                    this.barrierGraph,
                                    this.player,
                                    this.data,
                                    "y3"
                                );
                                this.playerOffset += computePlayerHealthData(
                                    this.healthGraph,
                                    this.player,
                                    this.data,
                                    "y3"
                                );
                                this.data.push({
                                    x: this.phase.times,
                                    y: [],
                                    mode: "lines",
                                    line: {
                                        shape: "spline",
                                        color: this.player.colTotal,
                                    },
                                    yaxis: "y5",
                                    hoverinfo: "name+y+x",
                                    name: "Taken",
                                });
                                if (!logData.targetless) {
                                    this.data.push({
                                        x: this.phase.times,
                                        y: [],
                                        mode: "lines",
                                        line: {
                                            shape: "spline",
                                            color: this.player.colCleave,
                                        },
                                        yaxis: "y3",
                                        hoverinfo: "name+y+x",
                                        name: "Cleave",
                                    });
                                    this.data.push({
                                        x: this.phase.times,
                                        y: [],
                                        mode: "lines",
                                        line: {
                                            shape: "spline",
                                            color: this.player.colTarget,
                                        },
                                        yaxis: "y3",
                                        hoverinfo: "name+y+x",
                                        name: "Target",
                                    });
                                }
                                this.data.push({
                                    x: this.phase.times,
                                    y: [],
                                    mode: "lines",
                                    line: {
                                        shape: "spline",
                                        color: this.player.colTotal,
                                    },
                                    yaxis: "y3",
                                    hoverinfo: "name+y+x",
                                    name: "Total",
                                });
                                this.layout = getActorGraphLayout(
                                    images,
                                    this.light ? "#495057" : "#cccccc",
                                    hasBuffs,
                                    false
                                );
                                computePhaseMarkups(
                                    this.layout.shapes,
                                    this.layout.annotations,
                                    this.phase,
                                    this.light ? "#495057" : "#cccccc"
                                );
                                this.updateVisibily(
                                    this.layout.images,
                                    this.phase.start,
                                    this.phase.end
                                );
                            },
                            computeDPSData: function () {
                                const cacheID = getDPSGraphCacheID(
                                    this.graphdata.dpsmode,
                                    this.graphdata.damagemode,
                                    this.graphdata.graphmode,
                                    this.activetargets,
                                    this.phaseindex,
                                    null
                                );
                                const internalCacheID =
                                    this.encounterPhase.id + "-" + cacheID;
                                if (this.dpsCache.has(internalCacheID)) {
                                    return this.dpsCache.get(internalCacheID);
                                }
                                var data;
                                var graphData =
                                    this.graph.players[this.playerindex];
                                var damageArrayToUse = this.damageGraphName;
                                if (this.graphdata.dpsmode >= 0) {
                                    data = computePlayerDPS(
                                        this.player,
                                        graphData[damageArrayToUse],
                                        this.graphdata.dpsmode,
                                        null,
                                        this.activetargets,
                                        cacheID,
                                        this.phase.times,
                                        this.graphdata.graphmode,
                                        this.graphdata.damagemode
                                    );
                                } else {
                                    data = computePlayerDPS(
                                        this.player,
                                        graphData[damageArrayToUse],
                                        0,
                                        this.computePhaseBreaks,
                                        this.activetargets,
                                        cacheID,
                                        this.phase.times,
                                        this.graphdata.graphmode,
                                        this.graphdata.damagemode
                                    );
                                }
                                var res = {
                                    maxDPS: data.maxDPS.total,
                                    playerDPS: data.dps,
                                };
                                this.dpsCache.set(internalCacheID, res);
                                return res;
                            },
                            computeDPSRelatedData: function () {
                                var cacheID =
                                    this.encounterPhase.id +
                                    "-" +
                                    getDPSGraphCacheID(
                                        this.graphdata.dpsmode,
                                        this.graphdata.damagemode,
                                        this.graphdata.graphmode,
                                        this.activetargets,
                                        this.phaseindex,
                                        null
                                    );
                                if (this.dataCache.has(cacheID)) {
                                    return this.dataCache.get(cacheID);
                                }
                                var dpsData = this.computeDPSData();
                                var res = [];
                                res.push(dpsData.playerDPS.total);
                                res.push(dpsData.playerDPS.target);
                                res.push(dpsData.playerDPS.cleave);
                                res.push(dpsData.playerDPS.taken);
                                for (
                                    var i = 0;
                                    i < this.graph.targets.length;
                                    i++
                                ) {
                                    addPointsToGraph(
                                        res,
                                        this.graph.targets[i]
                                            .breakbarPercentStates,
                                        dpsData.maxDPS
                                    );
                                }
                                for (
                                    var i = 0;
                                    i < this.graph.targets.length;
                                    i++
                                ) {
                                    addPointsToGraph(
                                        res,
                                        this.graph.targets[i].barrierStates,
                                        dpsData.maxDPS
                                    );
                                }
                                for (
                                    var i = 0;
                                    i < this.graph.targets.length;
                                    i++
                                ) {
                                    addPointsToGraph(
                                        res,
                                        this.graph.targets[i].healthStates,
                                        dpsData.maxDPS
                                    );
                                }
                                addPointsToGraph(
                                    res,
                                    this.barrierGraph,
                                    dpsData.maxDPS
                                );
                                addPointsToGraph(
                                    res,
                                    this.healthGraph,
                                    dpsData.maxDPS
                                );
                                this.dataCache.set(cacheID, res);
                                return res;
                            },
                        },
                    });
                }
                {
                    function getActorsRotationLayout(
                        images,
                        color,
                        players,
                        phase
                    ) {
                        var layout = {
                            barmode: "stack",
                            legend: {
                                traceorder: "reversed",
                            },
                            hovermode: "x",
                            hoverdistance: 50,
                            images: images,
                            font: {
                                color: color,
                            },
                            xaxis: {
                                title: "Time(sec)",
                                color: color,
                                gridcolor: color,
                                rangemode: "nonnegative",
                                xrangeslider: {},
                                tickmode: "auto",
                                nticks: 8,
                            },
                            paper_bgcolor: "rgba(0,0,0,0)",
                            plot_bgcolor: "rgba(0,0,0,0)",
                            shapes: [],
                            annotations: [],
                            margin: {
                                l: 150,
                            },
                            height: players.length * 65 + 180, // 180 is the section above the plot
                            datarevision: new Date().getTime(),
                        };
                        var delta = 1.0 / players.length;
                        for (var i = 0; i < players.length; i++) {
                            var player = players[i];
                            var name;
                            if (i === 0) {
                                name = "yaxis";
                            } else {
                                name = "yaxis" + (i + 1);
                            }
                            layout[name] = {
                                domain: [i * delta, (i + 1) * delta],
                                fixedrange: true,
                                showgrid: false,
                                showticklabels: false,
                                color: color,
                                range: [0, 2],
                            };
                        }
                        return layout;
                    }

                    Vue.component("player-rotations-component", {
                        props: ["phaseindex", "light", "playerindex"],
                        template: `    <div style="width: 100%;">        <div style="position:absolute; margin-top: 60px; z-index: 1;">            <a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Filter Players" style="font-size: 1.1em;">                Players <span class="caret"></span>            </a>            <ul class="dropdown-menu p-2 font-weight-normal scrollabledropdown" style="min-width: 165px;">                <div class="d-flex flex-column justify-content-center align-items-center mb-1"                    style="border-bottom: 2px solid #bbb;">                    <li>                        <button style="width:160px; padding: 0.4rem 0.4rem;" type="button" class="btn btn-primary btn-sm"                            @click="for (var i = 0; i < selectedPlayers.length; i++) {selectedPlayers[i].selected = true;}" @click.stop="stopClickEvent">                            Select all                        </button>                    </li>                    <li class="mb-1">                        <button style="width:160px; padding: 0.4rem 0.4rem;" type="button" class="btn btn-primary btn-sm"                            @click="for (var i = 0; i < selectedPlayers.length; i++) {selectedPlayers[i].selected = false;}" @click.stop="stopClickEvent">                            Deselect all                        </button>                    </li>                </div>                <li v-for="(player, index) in _players" :key="index">                    <div style="width: max-content;">                        <input :id="'rotations-player-' + index  + '-' + phaseindex" type="checkbox"                            v-model="selectedPlayers[index].selected" @click.stop="stopClickEvent" />                        <label :for="'rotations-player-' + index + '-' + phaseindex" @click.stop="stopClickEvent"                            style="font-size: 1.0em; white-space: nowrap; margin-top: 2px;">                                     <img class="icon" :src="player.icon">                            {{player.name}}                        </label>                    </div>                </li>            </ul>        </div>        <graph-component :id="graphid" :layout="layout" :data="data"></graph-component>        <rotation-legend-component></rotation-legend-component>    </div>`,
                        mixins: [graphComponent, encounterPhaseComponent],
                        data: function () {
                            var selectedPlayers = [];
                            for (var i = 0; i < logData.players.length; i++) {
                                selectedPlayers.push({ selected: true });
                            }
                            return {
                                annotationsOffset: 0,
                                selectedPlayers: selectedPlayers,
                            };
                        },
                        watch: {
                            light: {
                                handler: function () {
                                    var textColor = this.light
                                        ? "#495057"
                                        : "#cccccc";
                                    var players = this.players;
                                    for (var i = 0; i < players.length; i++) {
                                        var player = players[i];
                                        var name;
                                        if (i === 0) {
                                            name = "yaxis";
                                        } else {
                                            name = "yaxis" + (i + 1);
                                        }
                                        this.layout[name].gridcolor = textColor;
                                        this.layout[name].color = textColor;
                                        this.layout.annotations[
                                            this.annotationsOffset + i
                                        ].bgcolor =
                                            player.id === this.playerindex
                                                ? this.light
                                                    ? "rgba(120, 240, 0, 0.5)"
                                                    : "rgba(50, 120, 0, 0.5)"
                                                : "rgba(0,0,0,0)";
                                    }
                                    this.layout.xaxis.gridcolor = textColor;
                                    this.layout.xaxis.color = textColor;
                                    this.layout.font.color = textColor;
                                    for (
                                        var i = 0;
                                        i < this.layout.shapes.length;
                                        i++
                                    ) {
                                        this.layout.shapes[i].line.color =
                                            textColor;
                                    }
                                    this.layout.datarevision =
                                        new Date().getTime();
                                },
                            },
                            playerindex: {
                                handler: function () {
                                    var players = this.players;
                                    for (var i = 0; i < players.length; i++) {
                                        var player = players[i];
                                        this.layout.annotations[
                                            this.annotationsOffset + i
                                        ].bgcolor =
                                            player.id === this.playerindex
                                                ? this.light
                                                    ? "rgba(120, 240, 0, 0.5)"
                                                    : "rgba(50, 120, 0, 0.5)"
                                                : "rgba(0,0,0,0)";
                                    }
                                    this.layout.datarevision =
                                        new Date().getTime();
                                },
                            },
                            selectedPlayers: {
                                deep: true,
                                handler: function () {
                                    this.computeLayout();
                                },
                            },
                            encounters: {
                                deep: true,
                                handler: function () {
                                    this.computeLayout();
                                },
                            },
                        },
                        created: function () {
                            this.computeLayout();
                        },
                        activated: function () {
                            var div = document.getElementById(this.graphid);
                            var _this = this;
                            div.on("plotly_relayout", function (evt) {
                                var layout = _this.layout;
                                var images = layout.images;
                                var x0 = layout.xaxis.range[0];
                                var x1 = layout.xaxis.range[1];
                                //console.log("re-layout " + x0 + " " + x1);
                                if (_this.updateVisibily(images, x0, x1)) {
                                    layout.datarevision = new Date().getTime();
                                    //console.log("re-drawing");
                                }
                            });
                        },
                        methods: {
                            stopClickEvent: function (event) {
                                event.stopPropagation();
                            },
                            computeLayout: function () {
                                var backUpXAxis = null;
                                if (this.layout) {
                                    backUpXAxis = this.layout.xaxis;
                                }
                                this.data = [];
                                var images = [];
                                for (var i = 0; i < this.players.length; i++) {
                                    var player = this.players[i];
                                    computeRotationData(
                                        player.details.rotation[
                                            this.phaseindex
                                        ],
                                        images,
                                        this.data,
                                        this.phase,
                                        player,
                                        i
                                    );
                                }
                                this.layout = getActorsRotationLayout(
                                    images,
                                    this.light ? "#495057" : "#cccccc",
                                    this.players,
                                    this.phase
                                );
                                if (backUpXAxis) {
                                    this.layout.xaxis = backUpXAxis;
                                }
                                this.updateVisibily(
                                    images,
                                    this.phase.start,
                                    this.phase.end
                                );
                                computePhaseMarkups(
                                    this.layout.shapes,
                                    this.layout.annotations,
                                    this.phase,
                                    this.light ? "#495057" : "#cccccc"
                                );
                                this.annotationsOffset =
                                    this.layout.annotations.length;
                                for (var i = 0; i < this.players.length; i++) {
                                    var player = this.players[i];
                                    this.layout.annotations.push({
                                        xref: "paper",
                                        yref: i === 0 ? "y" : "y" + (i + 1),
                                        x: 0,
                                        y: 1,
                                        xanchor: "right",
                                        yanchor: "middle",
                                        align: "left",
                                        text: player.name,
                                        showarrow: false,
                                        width: 145,
                                        height: 62,
                                        bgcolor:
                                            player.id === this.playerindex
                                                ? this.light
                                                    ? "rgba(120, 240, 0, 0.5)"
                                                    : "rgba(50, 120, 0, 0.5)"
                                                : "rgba(0,0,0,0)",
                                    });
                                }
                            },
                        },
                        computed: {
                            phase: function () {
                                return logData.phases[this.phaseindex];
                            },
                            players: function () {
                                var res = [];
                                const players = getActivePlayersForPhase(
                                    this.encounterPhase
                                );
                                for (var i = 0; i < players.length; i++) {
                                    if (
                                        players[i] &&
                                        this.selectedPlayers[i].selected
                                    ) {
                                        res.push(players[i]);
                                    }
                                }
                                return res;
                            },
                            _players: function () {
                                const players = getActivePlayersForPhase(
                                    this.encounterPhase
                                );
                                return players.filter((x) => !!x);
                            },
                            graphid: function () {
                                return (
                                    "playersrotation-" + "-" + this.phaseindex
                                );
                            },
                        },
                    });
                }
                {
                    Vue.component("player-rotations-tab-component", {
                        props: ["phaseindex", "light", "playerindex"],
                        template: `    <div class="d-flex flex-column align-items-center justify-content-center">        <h3 class="text-center mt-1 mb-1">Players' Rotation</h3>        <keep-alive>            <player-rotations-component v-for='(phase, index) in phases' :key="'rotations' + index"                v-if="index === phaseindex" :phaseindex="phaseindex" :light="light" :playerindex="playerindex">                </player-rotation-component>        </keep-alive>    </div>`,
                        computed: {
                            phases: function () {
                                return logData.phases;
                            },
                        },
                    });
                }
                {
                    Vue.component("rotation-legend-component", {
                        template: `    <div class="card">        <div class="card-body container">            <p><u>Fill</u></p>            <span style="padding: 2px; background-color:#0000FF; border-style:solid; border-width: 1px; border-color:#000000; color:#FFFFFF">                Hit                without aftercast            </span>            <span style="padding: 2px; background-color:#00FF00; border-style:solid; border-width: 1px; border-color:#000000; color:#000000">                Hit                with full aftercast            </span>            <span style="padding: 2px; background-color:#FF0000; border-style:solid; border-width: 1px; border-color:#000000; color:#FFFFFF">                Attack                canceled before completing            </span>            <span style="padding: 2px; background-color:#00FFFF; border-style:solid; border-width: 1px; border-color:#000000; color:#000000" data-original-title="50 ms on graph so that it appears">                Instant cast            </span>            <span style="padding: 2px; background-color:#FFFF00; border-style:solid; border-width: 1px; border-color:#000000; color:#000000">                Unknown                state            </span>            <p class="mt-2"><u>Outline</u></p>            <div>                The outline will be a linear gradient between slowed animation and normal animation when slowed, animation with quickness and normal animation when accelerated.            </div>            <span style="padding: 2px; background-color:#999999; border-style:solid; border-width: 2px; border-color:rgb(220,125,30); color:#000000">                Slowed                animation length            </span>            <span style="padding: 2px; background-color:#999999; border-style:solid; border-width: 2px; border-color:rgb(125,125,125); color:#000000">                Normal                animation length            </span>            <span style="padding: 2px; background-color:#999999; border-style:solid; border-width: 2px; border-color:rgb(220,20,220); color:#000000">                Animation                with quickness            </span>        </div>    </div>`,
                    });
                }
                {
                    function getDefaultTargetBuffTabSubComponent() {
                        if (
                            !validateStartPath(
                                "Statistics/TargetsSummary/BoonStatus"
                            )
                        ) {
                            return 0;
                        }
                        const setting = EIUrlParams.get("startPage");
                        const compo = setting.split("/")[3];
                        switch (compo) {
                            case "Uptimes":
                                return 0;
                            case "Volumes":
                                return 1;
                        }
                        return 0;
                    }
                    Vue.component("target-buff-tab-component", {
                        props: ["phaseindex", "playerindex", "targetindex"],
                        template: `    <div>        <ul class="nav nav-tabs">            <li>                <a class="nav-link" :class="{active: tab === 0}" @click="tab = 0">Uptimes</a>            </li>            <li v-if="hasOffBuffs">                <a class="nav-link" :class="{active: tab === 1}" @click="tab = 1">Volumes</a>            </li>        </ul>        <keep-alive>            <buff-stats-target-component v-if="tab == 0" :key="'target-buff-tables'":targetindex="targetindex"            :phaseindex="phaseindex" :playerindex="playerindex"></buff-stats-target-component>            <buff-volume-stats-target-component v-if="tab == 1" :key="'target-buff-volume-tables'" :targetindex="targetindex"            :phaseindex="phaseindex" :playerindex="playerindex"></buff-volume-stats-target-component>        </keep-alive>    </div>`,
                        data: function () {
                            return {
                                tab: getDefaultTargetBuffTabSubComponent(),
                            };
                        },
                    });
                }
                {
                    Vue.component("target-graph-tab-component", {
                        props: ["targetindex", "phaseindex", "light"],
                        template: `    <div>        <dps-graph-mode-selector-component :data="graphdata" :phaseduration="this.phase.end - this.phase.start"            :phasehassubphases="!!this.phase.subPhases" :ignorebreakbar="true" :column="false">        </dps-graph-mode-selector-component>        <h3 class="text-center mt-1 mb-1">{{graphname}}</h3>        <graph-component :id="graphid" :layout="layout" :data="computeData"></graph-component>        <rotation-legend-component></rotation-legend-component>    </div>`,
                        mixins: [
                            graphComponent,
                            damageGraphComponent,
                            targetTabGraphComponent,
                        ],
                        computed: {
                            graphid: function () {
                                return (
                                    "targetgraph-" +
                                    this.phaseTargetIndex +
                                    "-" +
                                    this.phaseindex
                                );
                            },
                            boonGraph: function () {
                                return this.target.details.boonGraph[
                                    this.phaseindex
                                ];
                            },
                        },
                    });
                }
                {
                    Vue.component("targetperplayer-graph-tab-component", {
                        props: [
                            "targetindex",
                            "phaseindex",
                            "light",
                            "playerindex",
                        ],
                        template: `    <div>        <dps-graph-mode-selector-component :data="graphdata" :phaseduration="this.phase.end - this.phase.start"            :phasehassubphases="!!this.phase.subPhases" :ignorebreakbar="true" :column="false">        </dps-graph-mode-selector-component>        <h3 class="text-center mt-1 mb-1">{{graphname}}</h3>        <h3 class="text-center mt-1 mb-1">Buffs applied by {{player.name}}</h3>        <graph-component :id="graphid" :layout="layout" :data="computeData"></graph-component>        <rotation-legend-component></rotation-legend-component>    </div>`,
                        mixins: [
                            graphComponent,
                            damageGraphComponent,
                            targetTabGraphComponent,
                        ],
                        computed: {
                            graphid: function () {
                                return (
                                    "targetgraphperplayer-" +
                                    this.phaseTargetIndex +
                                    "-" +
                                    this.phaseindex +
                                    "-" +
                                    this.playerindex
                                );
                            },
                            boonGraph: function () {
                                return this.target.details.boonGraphPerSource[
                                    this.phaseindex
                                ][this.playerindex];
                            },
                            player: function () {
                                return logData.players[this.playerindex];
                            },
                        },
                    });
                }
                {
                    Vue.component("target-data-component", {
                        props: ["targetid"],
                        template: `    <div class="d-flex flex-row justify-content-center align-items-center mb-2">        <img v-if="target.health > 0" :src="UIIcons.VitalityChar" alt="Health"            class="icon" :data-original-title="'Health: ' + target.health">        <img v-if="target.tough > 0" :src="UIIcons.ToughnessChar" alt="Toughness"            class="icon" hbHeight :data-original-title="'Toughness: ' + target.tough">        <img v-if="target.hbWidth > 0" :src="UIIcons.HitboxWidth" alt="Hitbox Width"            class="icon" :data-original-title="'Hitbox Width: ' + target.hbWidth">        <img v-if="target.hbHeight > 0" :src="UIIcons.HitboxHeight" alt="Hitbox Half-Height"            class="icon" :data-original-title="'Hitbox Half-Height: ' + 0.5 * target.hbHeight">    </div>`,
                        computed: {
                            target: function () {
                                return logData.targets[this.targetid];
                            },
                            UIIcons: function () {
                                return UIIcons;
                            },
                        },
                    });
                }
                {
                    function getDefaultMainSubComponent() {
                        if (!validateStartPath("Statistics")) {
                            return 0;
                        }
                        const setting = EIUrlParams.get("startPage");
                        const compo = setting.split("/")[1];
                        switch (compo) {
                            case "GeneralStats":
                                return 0;
                            case "Buffs":
                                return 1;
                            case "DamageModifiers":
                                return hasDamageMods() ? 2 : 0;
                            case "Mechanics":
                                return hasMechanics() ? 3 : 0;
                            case "Graph":
                                return 4;
                            case "Rotations":
                                return hasRotations() ? 7 : 0;
                            case "TargetsSummary":
                                return hasTargets() ? 5 : 0;
                            case "PlayerSummary":
                                return 6;
                        }
                        return 0;
                    }
                    Vue.component("main-view-component", {
                        props: ["light"],
                        template: `    <div>        <div class="d-flex flex-row justify-content-center mt-1" id="phase-nav">            <phase-component :phases="reactiveLogdata.phases"></phase-component>        </div>        <div class="d-flex flex-row justify-content-center mb-2 mt-2" id="actors">            <div v-if="hasTargets" v-show="tab !== 5" :class="{'d-flex': tab !== 5}"                class="flex-row justify-content-center align-items-center flex-wrap mr-5">                <target-component :targets="reactiveLogdata.targets" :phaseindex="activePhase"></target-component>            </div>            <div class="ml-5">                <player-component :players="reactiveLogdata.players" :phaseindex="activePhase"></player-component>            </div>        </div>             <ul class="nav nav-tabs">            <li>                <a class="nav-link" :class="{active: tab === 0}" @click="tab = 0">General Stats</a>            </li>            <li>                <a class="nav-link" :class="{active: tab === 1}" @click="tab = 1">Buffs</a>            </li>            <li v-if="hasDamageMods">                <a class="nav-link" :class="{active: tab === 2}" @click="tab = 2">Damage Modifiers</a>            </li>            <li v-if="hasMechanics">                <a class="nav-link" :class="{active: tab === 3}" @click="tab = 3">Mechanics</a>            </li>            <li>                <a class="nav-link" :class="{active: tab === 4}" @click="tab = 4">Graph</a>            </li>            <li v-if="hasRotations">                <a class="nav-link" :class="{active: tab === 7}" @click="tab = 7">Rotations</a>            </li>            <li v-if="hasTargets">                <a class="nav-link" :class="{active: tab === 5}" @click="tab = 5">Targets Summary</a>            </li>            <li>                <a class="nav-link" :class="{active: tab === 6}" @click="tab = 6">Player Summary</a>            </li>        </ul>        <keep-alive>            <stat-tables-component v-if="tab === 0" :key="'stat-tables'"                :phaseindex="activePhase" :playerindex="activePlayer"                 :activetargets="activePhaseTargets"></stat-tables-component>            <buff-tab-component v-if="tab === 1" :key="'buff-tables'"                :phaseindex="activePhase" :playerindex="activePlayer"></buff-tab-component>            <dmgmodifier-stats-container-component v-if="tab === 2" :key="'modifier'"                :phaseindex="activePhase" :playerindex="activePlayer" :activetargets="activePhaseTargets">            </dmgmodifier-stats-container-component>            <mechanics-stats-component v-if="tab === 3" :key="'mechanics'"                :phaseindex="activePhase" :playerindex="activePlayer"></mechanics-stats-component>            <graph-stats-component v-if="tab === 4" :key="'graph'"                :activetargets="activePhaseTargets" :phaseindex="activePhase" :playerindex="activePlayer"                :light="light"></graph-stats-component>            <player-rotations-tab-component v-if="tab === 7" :key="'rotations'" :phaseindex="activePhase"             :light="light" :playerindex="activePlayer">            </player-rotations-tab-component>            <target-stats-component v-if="tab === 5" :key="'targets'" :playerindex="activePlayer"                :simplephase="reactiveLogdata.phases[activePhase]" :phaseindex="activePhase" :light="light">            </target-stats-component>            <player-stats-component v-if="tab === 6" :key="'players'"                :activeplayer="activePlayer" :phaseindex="activePhase" :activetargets="activePhaseTargets"                :light="light"></player-stats-component>        </keep-alive>    </div>`,
                        data: function () {
                            return {
                                tab: getDefaultMainSubComponent(),
                                reactiveLogdata: reactiveLogdata,
                            };
                        },
                        computed: {
                            activePhase: function () {
                                var phases = this.reactiveLogdata.phases;
                                for (var i = 0; i < phases.length; i++) {
                                    if (phases[i].active) {
                                        return i;
                                    }
                                }
                            },
                            phase: function () {
                                return logData.phases[this.activePhase];
                            },
                            activePlayer: function () {
                                var players = this.reactiveLogdata.players;
                                for (var i = 0; i < players.length; i++) {
                                    if (players[i].active) {
                                        return i;
                                    }
                                }
                                return -1;
                            },
                            name: function () {
                                const phase = this.phase;
                                return phase.name + " Summary";
                            },
                            activePhaseTargets: function () {
                                var res = [];
                                var activePhase =
                                    logData.phases[this.activePhase];
                                for (
                                    var i = 0;
                                    i < activePhase.targets.length;
                                    i++
                                ) {
                                    var targetIndex = activePhase.targets[i];
                                    var target =
                                        this.reactiveLogdata.targets[
                                            targetIndex
                                        ][this.activePhase];
                                    if (target.active) {
                                        res.push(i);
                                    }
                                }
                                return res;
                            },
                            hasDamageMods: function () {
                                return hasDamageMods();
                            },
                            hasMechanics: function () {
                                return hasMechanics();
                            },
                            hasTargets: function () {
                                return hasTargets();
                            },
                            hasRotations: function () {
                                return hasRotations();
                            },
                            players: function () {
                                return logData.players;
                            },
                        },
                    });
                }
            }

            function getDefaultMainComponent() {
                const setting = EIUrlParams.get("startPage");
                if (!setting) {
                    return 0;
                }
                const mainCompo = setting.split("/")[0];
                switch (mainCompo) {
                    case "Statistics":
                        return 0;
                    case "CombatReplay":
                        return !!crData ? 1 : 0;
                    case "HealingStatistics":
                        return !!healingStatsExtension ? 2 : 0;
                }
                return 0;
            }

            const DEBUG = EIUrlParams.get("debug") === "true";

            function getDefaultPhase() {
                const setting = EIUrlParams.get("phase");
                if (!setting) {
                    return 0;
                }
                return parseInt(setting);
            }

            function getDefaultEncounter() {
                const setting = EIUrlParams.get("encounter");
                if (!setting || !IsMultiEncounterLog) {
                    return 0;
                }
                return parseInt(setting);
            }

            function mainLoad() {
                if (!apiRenderServiceOkay) {
                    for (let key in WeaponIcons) {
                        WeaponIcons[key] = _buildFallBackURL(WeaponIcons[key]);
                    }
                    for (let key in UIIcons) {
                        UIIcons[key] = _buildFallBackURL(UIIcons[key]);
                    }
                }
                // make some additional variables reactive
                for (let i = 0; i < logData.phases.length; i++) {
                    const phase = logData.phases[i];
                    phase.durationS = phase.duration / 1000.0;
                    const times = [];
                    const dur = phase.end - phase.start;
                    const floorDur = Math.floor(dur);
                    phase.needsLastPoint = dur > floorDur + 1e-3;
                    for (let j = 0; j <= floorDur; j++) {
                        times.push(j);
                    }
                    if (phase.needsLastPoint) {
                        times.push(phase.end - phase.start);
                    }
                    phase.id = i;
                    phase.encounterID = -1;
                    phase.times = times;
                    reactiveLogdata.phases.push({
                        active: false,
                        index: i,
                        focus: -1,
                    });
                    if (
                        phase.type === PhaseTypes.INSTANCE ||
                        phase.type === PhaseTypes.ENCOUNTER
                    ) {
                        phase.encounterID = reactiveLogdata.encounters.length;
                        reactiveLogdata.encounters.push({
                            active: false,
                            index: i,
                        });
                        reactiveLogdata.activeEncounterPhaseData.push({
                            phase: i,
                            player: -1,
                        });
                    }
                }
                IsMultiEncounterLog = reactiveLogdata.encounters.length > 1;
                const activeEncounterIndex = getDefaultEncounter();
                for (let i = 0; i < reactiveLogdata.encounters.length; i++) {
                    reactiveLogdata.encounters[i].active =
                        i === activeEncounterIndex;
                }
                let encounterPhases = getPhasesForSelectedEncounter(
                    reactiveLogdata.phases,
                    reactiveLogdata.encounters
                ).filter((x) => {
                    const logPhase = logData.phases[x.index];
                    return !logPhase.breakbarPhase;
                });
                const activePhaseIndex = getDefaultPhase();
                for (let i = 0; i < encounterPhases.length; i++) {
                    encounterPhases[i].active = i === activePhaseIndex;
                    if (encounterPhases[i].active) {
                        reactiveLogdata.activeEncounterPhaseData[
                            activeEncounterIndex
                        ].phase = encounterPhases[i].index;
                    }
                }
                for (let i = 0; i < logData.targets.length; i++) {
                    const target = logData.targets[i];
                    const activeArray = [];
                    reactiveLogdata.targets.push(activeArray);
                    for (let j = 0; j < logData.phases.length; j++) {
                        const phase = logData.phases[j];
                        const phaseTarget = phase.targets.indexOf(i);
                        const priority = phase.targetPriorities[phaseTarget];
                        activeArray.push({
                            active:
                                typeof priority !== "undefined" && priority < 2,
                            secondary:
                                typeof priority === "undefined" || priority > 0,
                            index: i,
                        });
                    }
                    target.id = i;
                    target.dpsGraphCache = new Map();
                }
                let activeFound = false;
                for (let i = 0; i < logData.players.length; i++) {
                    const playerData = logData.players[i];
                    const active = !activeFound && !!playerData.isPoV;
                    reactiveLogdata.players.push({
                        active: active,
                        index: i,
                        targetActive: !playerData.isFake,
                    });
                    if (active) {
                        activeFound = true;
                        for (
                            let j = 0;
                            j < reactiveLogdata.encounters.length;
                            j++
                        ) {
                            reactiveLogdata.activeEncounterPhaseData[j].player =
                                i;
                        }
                    }
                    playerData.dpsGraphCache = new Map();
                    playerData.id = i;
                }
                if (!activeFound) {
                    reactiveLogdata.players[0].active = true;
                }
                compileTemplates();
                if (!!crData) {
                    compileCRTemplates();
                }
                if (!!healingStatsExtension) {
                    compileHealingExtTemplates();
                }
                new Vue({
                    el: "#content",
                    data: {
                        light:
                            typeof window.theme !== "undefined"
                                ? window.theme === "yeti"
                                : logData.lightTheme,
                        mode: getDefaultMainComponent(),
                        cr: !!crData,
                        healingExtShow:
                            !!healingStatsExtension ||
                            logData.evtcBuild >= 20210701,
                        healingExt: !!healingStatsExtension,
                        reactiveLogdata: reactiveLogdata,
                    },
                    methods: {
                        switchTheme: function (state) {
                            if (state === this.light) {
                                return;
                            }
                            const style = this.light ? "yeti" : "slate";
                            this.light = state;
                            const newStyle = this.light ? "yeti" : "slate";
                            document.body.classList.remove("theme-" + style);
                            document.body.classList.add("theme-" + newStyle);
                            if (storeTheme) storeTheme(newStyle);
                            const theme = document.getElementById("theme");
                            theme.href = themes[newStyle];
                        },
                        getLogData: function () {
                            return logData;
                        },
                    },
                    computed: {
                        errorMessages: function () {
                            return logData.logErrors;
                        },
                        uploadLinks: function () {
                            const res = [
                                {
                                    key: "DPS Reports Link (EI)",
                                    url: "",
                                },
                                {
                                    key: "Raidar Link",
                                    url: "",
                                },
                            ];
                            let hasAny = false;
                            for (
                                let i = 0;
                                i < logData.uploadLinks.length;
                                i++
                            ) {
                                const link = logData.uploadLinks[i];
                                if (link.length > 0) {
                                    hasAny = true;
                                    res[i].url = link;
                                }
                            }
                            return hasAny ? res : null;
                        },
                        usedExtensions: function () {
                            if (!logData.usedExtensions) {
                                return null;
                            }
                            return logData.usedExtensions;
                        },
                        UIIcons: function () {
                            return UIIcons;
                        },
                    },
                    mounted() {
                        const element = document.getElementById("loading");
                        element.parentNode.removeChild(element);
                    },
                });
                $("body").tooltip({
                    selector: "[data-original-title]",
                    html: true,
                    boundary: "window",
                });
            }

            window.onload = function () {
                Vue.config.devtools = true;
                // trick from
                const imgOfficialAPI = document.createElement("img");
                imgOfficialAPI.style.display = "none";
                document.body.appendChild(imgOfficialAPI);
                imgOfficialAPI.onload = function () {
                    console.info("Info: GW2 Render service available");
                    mainLoad();
                    document.body.removeChild(imgOfficialAPI);
                };
                imgOfficialAPI.onerror = function () {
                    apiRenderServiceOkay = false;
                    document.body.removeChild(imgOfficialAPI);
                    const imgDarthmaim = document.createElement("img");
                    imgDarthmaim.style.display = "none";
                    imgDarthmaim.onload = function () {
                        console.warn(
                            "Warning: GW2 Render service unavailable, switching to https://icons-gw2.darthmaim-cdn.com"
                        );
                        useDarthmaim = true;
                        mainLoad();
                        document.body.removeChild(imgDarthmaim);
                    };
                    imgDarthmaim.onerror = function () {
                        console.warn(
                            "Warning: GW2 Render service unavailable, switching to https://assets.gw2dat.com"
                        );
                        useDarthmaim = false;
                        mainLoad();
                        document.body.removeChild(imgDarthmaim);
                    };
                    imgDarthmaim.src =
                        "https://icons-gw2.darthmaim-cdn.com/2FA9DF9D6BC17839BBEA14723F1C53D645DDB5E1/102852.png";
                };
                imgOfficialAPI.src =
                    "https://render.guildwars2.com/file/2FA9DF9D6BC17839BBEA14723F1C53D645DDB5E1/102852.png";
            };
        </script>
        <script>
            /*jshint esversion: 6 */
            /* jshint node: true */
            /*jslint browser: true */
            /* global logData*/
            // const images
            "use strict";

            function compileCRTemplates() {
                {
                    Vue.component("combat-replay-damage-data-component", {
                        template: `    <div class="d-flex flex-column justify-content-center">        <dps-graph-mode-selector-component :data="graphdata"            :phaseduration="this.phase.end - this.phase.start" :phasehassubphases="false" :ignorebreakbar="false" :style="{'width': selectorWidth + 'px'}" :column="selectorWidth < 280">        </dps-graph-mode-selector-component>        <combat-replay-damage-stats-component :time="time" :playerid="selectedplayerid" :graphdata="graphdata">        </combat-replay-damage-stats-component>    </div>`,
                        props: ["time", "selectedplayerid"],
                        data: function () {
                            return {
                                graphdata: {
                                    dpsmode: 0,
                                    graphmode: logData.wvw
                                        ? GraphType.Damage
                                        : GraphType.DPS,
                                    damagemode: DamageType.All,
                                },
                            };
                        },
                        computed: {
                            phase: function () {
                                return logData.phases[0];
                            },
                            targets: function () {
                                return logData.targetless
                                    ? []
                                    : this.phase.targets;
                            },
                            selectorWidth: function () {
                                return 620;
                            },
                        },
                    });
                }
                {
                    Vue.component("combat-replay-status-data-component", {
                        template: `    <div class="d-flex flex-column justify-content-center">        <ul class="nav nav-pills d-flex flex-row justify-content-center mb-1">            <li class="nav-item">                <a class="nav-link" :class="{active: mode === 0}" @click="mode = 0">Players</a>            </li>            <li v-if="!targetless" class="nav-item">                <a class="nav-link" :class="{active: mode === 1}" @click="mode = 1">Targets</a>            </li>            <li class="nav-item">                <a class="nav-link" :class="{active: mode === 2}" @click="mode = 2">Mechanics</a>            </li>        </ul>        <div class="squad-details">            <keep-alive>                <combat-replay-players-stats-component v-if="mode === 0" :key="'players-cr-details'" :time="time" :selectedplayerid="selectedactorid"></combat-replay-players-stats-component>                <combat-replay-targets-stats-component v-if="mode === 1" :key="'targets-cr-details'" :time="time" :selectedtargetid="selectedactorid"></combat-replay-targets-stats-component>                <combat-replay-mechanics-list-component v-if="mode === 2" :key="'mechanics-cr-details'" :selectedplayerid="selectedactorid"></combat-replay-mechanics-list-component>            </keep-alive>        </div>    </div>`,
                        props: ["time", "selectedactorid"],
                        data: function () {
                            return {
                                targetless: logData.targetless,
                                mode: 0,
                            };
                        },
                    });
                }
                {
                    Vue.component("combat-replay-damage-stats-component", {
                        mixins: [
                            encounterPhaseComponent,
                            timeRefreshComponent,
                            numberComponent,
                            sortedTableComponent,
                            colSliderComponent(2),
                            rowSliderComponent(10),
                        ],
                        props: ["playerid", "graphdata"],
                        template: `    <div>        <div class="d-flex flex-row justify-content-center">            <div v-if="rowPageCount > 0" style="width:25px;">                <table-scroll-component :min="0" :max="rowPageCount" :width="'230px'" :height="'10px'" :transform="colPageCount > 0 ? 'translate(-100px, 210px) rotate(90deg)' : 'translate(-100px, 185px) rotate(90deg)' " :pagestructure="rowStructure"></table-scroll-component>            </div>            <div>                <div v-if="colPageCount > 0">                    <table-scroll-component :min="0" :max="colPageCount" :width="'200px'" :height="'10px'" :transform="'translate(350px, 5px)'" :pagestructure="colStructure"></table-scroll-component>                </div>                <table class="table table-sm table-striped table-hover" cellspacing="0" width="100%" :id="tableid">                    <thead>                        <tr>                            <th class="prof-cell" :class="getHeaderClass('Prof')" @click="sortBy('Prof')"></th>                            <th class="name-cr-cell text-left" :class="getHeaderClass('Name')" @click="sortBy('Name')">                                Name                            </th>                            <th class="damage-cr-cell-small" :class="getHeaderClass('All')" @click="sortBy('All')">                                All                            </th>                            <th class="damage-cr-cell-small" :class="getHeaderClass('Taken')" @click="sortBy('Taken')">                                Taken                            </th>                            <th v-if="!targetless" v-for="(col, colIndex) in tableData.cols" v-show="isInColPage(colIndex)"                                class="damage-cr-cell" :class="getHeaderClass('Target', colIndex)" @click="sortBy('Target', colIndex)">                                <span class="cr-ellipsis" :data-original-title="col.name">                                    {{col.name}}                                </span>                            </th>                        </tr>                    </thead>                    <tbody>                        <tr v-for="(row, rowIndex) in sortData(tableData.rows)"                             :class="{active: row.player.uniqueID === playerid}"                             v-show="isInRowPage(rowIndex)" @click="select(row.player)"                            @mousedown="startSelect"                            style="cursor: pointer;">                            <td :class="getBodyClass('Prof')" :title="row.player.profession">                                <img :src="row.player.icon" :alt="row.player.profession" class="icon">                                <span style="display:none">                                    {{row.player.profession}}                                </span>                            </td>                            <td class="text-left" :class="getBodyClass('Name')">                                <span class="cr-ellipsis" :title="row.player.name + ' - ' + row.player.acc">                                    {{row.player.name}}                                </span>                            </td>                            <td :class="getBodyClass('All')">                                {{tableRound(row.dps[row.dps.length - 1])}}                            </td>                            <td :class="getBodyClass('Taken')">                                {{tableRound(row.dps[row.dps.length - 2])}}                            </td>                            <td v-if="!targetless" v-for="(col, colIndex) in tableData.cols" v-show="isInColPage(colIndex)"                                :class="getBodyClass('Target', colIndex)">                                {{tableRound(row.dps[colIndex])}}                            </td>                        </tr>                    </tbody>                    <tfoot>                        <tr v-for="sum in tableData.sums">                            <td></td>                            <td>                                {{sum.name}}                            </td>                            <td>                                {{tableRound(sum.dps[sum.dps.length - 1])}}                            </td>                            <td>                                {{tableRound(sum.dps[sum.dps.length - 2])}}                            </td>                            <td v-if="!targetless" v-for="(col, colIndex) in tableData.cols" v-show="isInColPage(colIndex)">                                {{tableRound(sum.dps[colIndex])}}                            </td>                        </tr>                    </tfoot>                </table>            </div>        </div>    </div>`,
                        data: function () {
                            return {
                                targetless: logData.targetless,
                                sortdata: {
                                    order: "desc",
                                    index: -1,
                                    key: "All",
                                },
                                mouseDownStart: 0,
                            };
                        },
                        watch: {
                            encounters: {
                                handler: function () {
                                    this.sortBy("All", -1);
                                    this.sortdata.order = "desc";
                                },
                                deep: true,
                            },
                        },
                        methods: {
                            tableRound: function (value) {
                                return this.graphdata.damagemode ==
                                    GraphType.Breakbar
                                    ? this.round1(value)
                                    : this.round(value);
                            },
                            sortBy: function (key, index) {
                                this.sortByBase(this.sortdata, key, index);
                            },
                            getHeaderClass: function (key, index) {
                                return this.getHeaderClassBase(
                                    this.sortdata,
                                    key,
                                    index
                                );
                            },
                            getBodyClass: function (key, index) {
                                const classes = this.getBodyClassBase(
                                    this.sortdata,
                                    key,
                                    index
                                );
                                return classes;
                            },
                            sortData: function (rows) {
                                const order =
                                    this.sortdata.order === "asc" ? 1 : -1;
                                switch (this.sortdata.key) {
                                    case "Prof":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    this.sortByPlayerProfession(
                                                        x,
                                                        y
                                                    ) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Name":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "All":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    (x.dps[x.dps.length - 1] -
                                                        y.dps[
                                                            y.dps.length - 1
                                                        ]) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    case "Taken":
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                (x.dps[x.dps.length - 2] -
                                                    y.dps[y.dps.length - 2])
                                        ) || this.sortByPlayerName(x, y);
                                        break;
                                    case "Target":
                                        const index = this.sortdata.index;
                                        rows.sort(
                                            (x, y) =>
                                                order *
                                                    (x.dps[index] -
                                                        y.dps[index]) ||
                                                this.sortByPlayerName(x, y)
                                        );
                                        break;
                                    default:
                                        return null;
                                        break;
                                }
                                return rows;
                            },
                            startSelect() {
                                this.mouseDownStart = Date.now();
                            },
                            select(player) {
                                const mouseUp = Date.now();
                                if (mouseUp - this.mouseDownStart < 150) {
                                    animator.selectActor(player.uniqueID);
                                }
                            },
                        },
                        computed: {
                            colPageCount: function () {
                                return (
                                    this.tableData.cols.length -
                                    this.colStructure.perpage
                                );
                            },
                            rowPageCount: function () {
                                return (
                                    this.tableData.rows.length -
                                    this.rowStructure.perpage
                                );
                            },
                            tableid: function () {
                                return "combat-replay-dps-table";
                            },
                            targets: function () {
                                let targets = [];
                                for (
                                    let i = 0;
                                    i < this.encounterPhase.targets.length;
                                    i++
                                ) {
                                    if (
                                        this.encounterPhase.targetPriorities[
                                            i
                                        ] < 2
                                    ) {
                                        targets.push(i);
                                    }
                                }
                                return targets;
                            },
                            graph: function () {
                                return graphData.phases[this.encounterPhase.id]
                                    .players;
                            },
                            graphModeEnum: function () {
                                return GraphType;
                            },
                            hasBreakbarDamage: function () {
                                return logData.hasBreakbarDamage;
                            },
                            damageGraphName: function () {
                                switch (this.graphdata.damagemode) {
                                    case DamageType.All:
                                        return "damage";
                                    case DamageType.Power:
                                        return "powerDamage";
                                    case DamageType.Condition:
                                        return "conditionDamage";
                                    case DamageType.Breakbar:
                                        return "breakbarDamage";
                                    default:
                                        throw new Error(
                                            "unknown enum in damage graph name"
                                        );
                                }
                            },
                            tableData: function () {
                                const rows = [];
                                const cols = [];
                                const sums = [];
                                const total = [];
                                const tS =
                                    this.timeToUse / 1000.0 -
                                    this.encounterPhase.start;
                                const curTime = Math.floor(tS);
                                let nextTime = curTime + 1;
                                const dur = Math.floor(
                                    this.encounterPhase.end -
                                        this.encounterPhase.start
                                );
                                if (
                                    nextTime == dur + 1 &&
                                    this.encounterPhase.needsLastPoint
                                ) {
                                    nextTime =
                                        this.encounterPhase.end -
                                        this.encounterPhase.start;
                                }
                                const allTargets = [];
                                for (let j = 0; j < this.targets.length; j++) {
                                    const target =
                                        logData.targets[this.targets[j]];
                                    allTargets.push(j);
                                    cols.push(target);
                                }
                                const damageArrayToUse = this.damageGraphName;
                                const encounterPlayers =
                                    getActivePlayersForPhase(
                                        this.encounterPhase
                                    );
                                const players = getActivePlayers(
                                    this.timeToUse * 0.001
                                );
                                for (let i = 0; i < this.graph.length; i++) {
                                    const player = players[i];
                                    if (!player || !encounterPlayers[i]) {
                                        continue;
                                    }
                                    const graphData = this.graph[i];
                                    const dps = [];
                                    function doCell(data, index) {
                                        const cur = data[curTime];
                                        const next = data[curTime + 1];
                                        if (typeof next !== "undefined") {
                                            dps[index] =
                                                cur +
                                                ((tS - curTime) *
                                                    (next - cur)) /
                                                    (nextTime - curTime);
                                        } else {
                                            dps[index] = cur;
                                        }
                                    }
                                    // targets
                                    for (
                                        let j = 0;
                                        j < this.targets.length;
                                        j++
                                    ) {
                                        const activeTargets = [j];
                                        const cacheID = getDPSGraphCacheID(
                                            this.graphdata.dpsmode,
                                            this.graphdata.damagemode,
                                            this.graphdata.graphmode,
                                            activeTargets,
                                            this.encounterPhase.id,
                                            null
                                        );
                                        const targetData = computePlayerDPS(
                                            player,
                                            graphData[damageArrayToUse],
                                            this.graphdata.dpsmode,
                                            null,
                                            activeTargets,
                                            cacheID,
                                            this.encounterPhase.times,
                                            this.graphdata.graphmode,
                                            this.graphdata.damagemode
                                        ).dps.target;
                                        doCell(targetData, j);
                                    }
                                    const cacheID = getDPSGraphCacheID(
                                        this.graphdata.dpsmode,
                                        this.graphdata.damagemode,
                                        this.graphdata.graphmode,
                                        allTargets,
                                        this.encounterPhase.id,
                                        null
                                    );
                                    const allData = computePlayerDPS(
                                        player,
                                        graphData[damageArrayToUse],
                                        this.graphdata.dpsmode,
                                        null,
                                        allTargets,
                                        cacheID,
                                        this.encounterPhase.times,
                                        this.graphdata.graphmode,
                                        this.graphdata.damagemode
                                    ).dps;
                                    doCell(allData.taken, this.targets.length);
                                    doCell(
                                        allData.total,
                                        this.targets.length + 1
                                    );
                                    for (let j = 0; j < dps.length; j++) {
                                        total[j] = (total[j] || 0) + dps[j];
                                    }
                                    rows.push({
                                        player: player,
                                        dps: dps,
                                    });
                                }
                                sums.push({
                                    name: "Total",
                                    dps: total,
                                });
                                const res = {
                                    cols: cols,
                                    rows: rows,
                                    sums: sums,
                                };
                                return res;
                            },
                        },
                    });
                }
                {
                    var buffDisplayHeight = 18;
                    Vue.component("combat-replay-buff-display", {
                        props: ["buffarray"],
                        template: `
        <div v-if="buffarray.length > 0" class="d-flex buff-display" :style="{'height': height}">
            <div v-for="buffData in buffarray" class="buff-container">
                <img :src="buffData.buff.icon" :title="buffData.buff.name + ' - ' + buffData.buff.id" :alt="buffData.buff.name + ' - ' + buffData.buff.id" class="icon-s" />
                <div v-if="buffData.state > 1" class="buff-number">{{buffData.state}}</div>
            </div>
        </div>
        `,
                        computed: {
                            height: function () {
                                return buffDisplayHeight + "px";
                            },
                        },
                    });
                    Vue.component("combat-replay-actor-buffs-stats-component", {
                        mixins: [timeRefreshComponent],
                        props: ["actorindex", "enemy", "buffstoshow"],
                        template: `    <div class="d-flex flex-column justify-content-end" :style="{'height': height}">        <div v-if="isPresent('Encounter Specifics')">            <combat-replay-buff-display :buffarray="data.encounterSpecifics"></combat-replay-buff-display>        </div>        <div v-if="isPresent('Others')">            <combat-replay-buff-display :buffarray="data.others"></combat-replay-buff-display>        </div>        <div v-if="isPresent('Conditions')">            <combat-replay-buff-display :buffarray="data.conditions"></combat-replay-buff-display>        </div>              <div v-if="isPresent('Shared')">            <combat-replay-buff-display :buffarray="data.shared"></combat-replay-buff-display>        </div>          <div v-if="isPresent('Boons')">            <combat-replay-buff-display :buffarray="data.boons"></combat-replay-buff-display>        </div>        <div v-if="isPresent('Consumables')" >            <combat-replay-buff-display :buffarray="data.consumables"></combat-replay-buff-display>        </div>    </div>`,
                        methods: {
                            isPresent: function (type) {
                                return this.buffsToShowSet.has(type);
                            },
                        },
                        computed: {
                            height: function () {
                                var count = 0;
                                for (
                                    var i = 0;
                                    i < this.buffstoshow.length;
                                    i++
                                ) {
                                    count += this.isPresent(this.buffstoshow[i])
                                        ? 1
                                        : 0;
                                }
                                return buffDisplayHeight * count + "px";
                            },
                            buffsToShowSet: function () {
                                return new Set(this.buffstoshow);
                            },
                            presentBuffTypes: function () {
                                var res = new Set();
                                for (var i = 0; i < this.buffData.length; i++) {
                                    var data = this.buffData[i];
                                    var id = data.id;
                                    var buff = findSkill(true, id);
                                    if (buff.consumable) {
                                        res.add("Consumables");
                                    } else if (buff.encounterSpecific) {
                                        res.add("Encounter Specifics");
                                    } else if (this.boons.has(id)) {
                                        res.add("Boons");
                                    } else if (this.offs.has(id)) {
                                        res.add("Shared");
                                    } else if (this.defs.has(id)) {
                                        res.add("Shared");
                                    } else if (this.sups.has(id)) {
                                        res.add("Shared");
                                    } else if (this.conditions.has(id)) {
                                        res.add("Conditions");
                                    } else {
                                        res.add("Others");
                                    }
                                }
                                return res;
                            },
                            boons: function () {
                                var hash = new Set();
                                for (var i = 0; i < logData.boons.length; i++) {
                                    hash.add(logData.boons[i]);
                                }
                                return hash;
                            },
                            offs: function () {
                                var hash = new Set();
                                for (
                                    var i = 0;
                                    i < logData.offBuffs.length;
                                    i++
                                ) {
                                    hash.add(logData.offBuffs[i]);
                                }
                                return hash;
                            },
                            defs: function () {
                                var hash = new Set();
                                for (
                                    var i = 0;
                                    i < logData.defBuffs.length;
                                    i++
                                ) {
                                    hash.add(logData.defBuffs[i]);
                                }
                                return hash;
                            },
                            sups: function () {
                                var hash = new Set();
                                for (
                                    var i = 0;
                                    i < logData.supBuffs.length;
                                    i++
                                ) {
                                    hash.add(logData.supBuffs[i]);
                                }
                                return hash;
                            },
                            conditions: function () {
                                var hash = new Set();
                                for (
                                    var i = 0;
                                    i < logData.conditions.length;
                                    i++
                                ) {
                                    hash.add(logData.conditions[i]);
                                }
                                return hash;
                            },
                            actor: function () {
                                return this.enemy
                                    ? logData.targets[this.actorindex]
                                    : logData.players[this.actorindex];
                            },
                            buffData: function () {
                                return this.actor.details.boonGraph[0];
                            },
                            data: function () {
                                var res = {
                                    shared: [],
                                    boons: [],
                                    conditions: [],
                                    encounterSpecifics: [],
                                    others: [],
                                    consumables: [],
                                };
                                for (var i = 0; i < this.buffData.length; i++) {
                                    var data = this.buffData[i];
                                    var id = data.id;
                                    var arrayToFill = [];
                                    var buff = findSkill(true, id);
                                    if (buff.consumable) {
                                        arrayToFill = res.consumables;
                                        if (
                                            !this.buffsToShowSet.has(
                                                "Consumables"
                                            )
                                        ) {
                                            continue;
                                        }
                                    } else if (buff.encounterSpecific) {
                                        arrayToFill = res.encounterSpecifics;
                                        if (
                                            !this.buffsToShowSet.has(
                                                "Encounter Specifics"
                                            )
                                        ) {
                                            continue;
                                        }
                                    } else if (this.boons.has(id)) {
                                        arrayToFill = res.boons;
                                        if (!this.buffsToShowSet.has("Boons")) {
                                            continue;
                                        }
                                    } else if (this.offs.has(id)) {
                                        arrayToFill = res.shared;
                                        if (
                                            !this.buffsToShowSet.has("Shared")
                                        ) {
                                            continue;
                                        }
                                    } else if (this.defs.has(id)) {
                                        arrayToFill = res.shared;
                                        if (
                                            !this.buffsToShowSet.has("Shared")
                                        ) {
                                            continue;
                                        }
                                    } else if (this.sups.has(id)) {
                                        arrayToFill = res.shared;
                                        if (
                                            !this.buffsToShowSet.has("Shared")
                                        ) {
                                            continue;
                                        }
                                    } else if (this.conditions.has(id)) {
                                        arrayToFill = res.conditions;
                                        if (
                                            !this.buffsToShowSet.has(
                                                "Conditions"
                                            )
                                        ) {
                                            continue;
                                        }
                                    } else {
                                        arrayToFill = res.others;
                                        if (
                                            !this.buffsToShowSet.has("Others")
                                        ) {
                                            continue;
                                        }
                                    }
                                    var t = this.timeToUse / 1000;
                                    var val = findState(
                                        data.states,
                                        t,
                                        0,
                                        data.states.length - 1
                                    );
                                    if (val > 0) {
                                        arrayToFill.push({
                                            state: val,
                                            buff: buff,
                                        });
                                    }
                                }
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("combat-replay-player-stats-component", {
                        props: [
                            "playerindex",
                            "time",
                            "buffs",
                            "rotation",
                            "buffstoshow",
                        ],
                        template: `    <div>        <combat-replay-actor-buffs-stats-component v-if="buffs && buffstoshow.length > 0" :time="time" :actorindex="playerindex" :enemy="false" :buffstoshow="buffstoshow"></combat-replay-actor-buffs-stats-component>        <div class="d-flex mb-1 mt-1 align-items-center player-status-rotation">            <combat-replay-player-status-component :time="time" :playerindex="playerindex"></combat-replay-player-status-component>            <combat-replay-actor-rotation-component v-if="rotation" :time="time" :actorindex="playerindex" :enemy="false"></combat-replay-actor-rotation-component>        </div>    </div>`,
                    });
                }
                {
                    Vue.component("combat-replay-player-status-component", {
                        props: ["playerindex", "time"],
                        template: `    <div class="player-status" :style="{'background': getHPGradient(time, status)}" @click="select" :data-original-title="player.name + ' - ' + player.acc">        <h6 class="actor-shorten-cr text-center">                 <img v-for="(marker, index) in activeMarkers()" :src="marker.imageUrl" height="16" width="16">            <img :src="player.icon" :alt="player.profession" height="16" width="16">            {{player.name}}        </h6>             <p v-if="hasHealth" class="text-right cr-hp-display cr-hp-display-player">            {{(Math.round(100*getHPPercent(time))/100).toFixed(2)}} %        </p>        <p v-if="hasBarrier" class="text-right cr-barrier-display cr-barrier-display-player">            {{(Math.round(100*getBarrierPercent(time))/100).toFixed(2)}} %        </p>              <div v-if="hasBarrier" class="cr-barrier cr-barrier-player" :style="{'background': getBarrierGradient(time)}">        </div>    </div>`,
                        methods: {
                            getHPPercent: function (time) {
                                if (!this.hasHealth) {
                                    return 100;
                                }
                                return findState(
                                    this.healths,
                                    time / 1000.0,
                                    0,
                                    this.healths.length - 1
                                );
                            },
                            getBarrierPercent: function (time) {
                                if (!this.hasBarrier) {
                                    return 0;
                                }
                                return findState(
                                    this.barriers,
                                    time / 1000.0,
                                    0,
                                    this.barriers.length - 1
                                );
                            },
                            getHPGradient: function (time, status) {
                                var color =
                                    status === 0
                                        ? "black"
                                        : status === 1
                                        ? "red"
                                        : status === 2
                                        ? "grey"
                                        : "green";
                                return computeGradient(
                                    color,
                                    this.getHPPercent(time),
                                    "black"
                                );
                            },
                            getBarrierGradient: function (time) {
                                return computeGradient(
                                    "rgba(0,0,0,0)",
                                    100 - this.getBarrierPercent(time),
                                    "rgba(228,148,97, 0.5)"
                                );
                            },
                            activeMarkers: function () {
                                return animator.getActiveActorMarkers(
                                    this.player.uniqueID
                                );
                            },
                            select() {
                                animator.selectActor(this.player.uniqueID);
                            },
                        },
                        computed: {
                            phase: function () {
                                return logData.phases[0];
                            },
                            player: function () {
                                return logData.players[this.playerindex];
                            },
                            healths: function () {
                                return graphData.phases[0].players[
                                    this.playerindex
                                ].healthStates;
                            },
                            barriers: function () {
                                return graphData.phases[0].players[
                                    this.playerindex
                                ].barrierStates;
                            },
                            status: function () {
                                var crPData = animator.getActorData(
                                    this.player.uniqueID
                                );
                                var icon = crPData.getIcon(this.time);
                                return icon === deadIcon
                                    ? 0
                                    : icon === downAllyIcon ||
                                      icon === downEnemyIcon
                                    ? 1
                                    : icon === dcIcon
                                    ? 2
                                    : 3;
                            },
                            hasHealth: function () {
                                return !!this.healths;
                            },
                            hasBarrier: function () {
                                return !!this.barriers;
                            },
                        },
                    });
                }
                {
                    Vue.component("combat-replay-actor-rotation-component", {
                        mixins: [timeRefreshComponent],
                        props: ["actorindex", "enemy"],
                        template: `    <div class="d-flex align-items-center actor-rotation">        <div v-if="rotation.current">            <img class="icon-ll" :class="getIconClass(rotation.current)" :src="rotation.current.skill.icon" :title="getTooltip(rotation.current)"/>        </div>        <div v-else class="empty-icon-ll">        </div>        <div v-for="next in rotation.nexts">            <img class="icon-l" :class="getIconClass(next)" :src="next.skill.icon" :title="getTooltip(next)"/>        </div>    </div>`,
                        methods: {
                            getSkillDuration: function (item) {
                                return Math.max(item[2], 1) * 1e-3;
                            },
                            findRotationIndex: function (
                                rotation,
                                timeS,
                                start,
                                end
                            ) {
                                if (end === 0) {
                                    return 0;
                                }
                                if (timeS < rotation[start][0]) {
                                    return start;
                                } else if (
                                    timeS >
                                    rotation[end][0] +
                                        this.getSkillDuration(rotation[end])
                                ) {
                                    return end;
                                }
                                var id = Math.floor((end + start) / 2);
                                if (id === start || id === end) {
                                    var item = rotation[start];
                                    var x = item[0];
                                    var duration = this.getSkillDuration(item);
                                    if (timeS >= x && x + duration >= timeS) {
                                        return start;
                                    }
                                    return end;
                                }
                                var item = rotation[id];
                                var x = item[0];
                                var duration = this.getSkillDuration(item);
                                if (timeS < x) {
                                    return this.findRotationIndex(
                                        rotation,
                                        timeS,
                                        start,
                                        id
                                    );
                                } else if (timeS > x + duration) {
                                    return this.findRotationIndex(
                                        rotation,
                                        timeS,
                                        id,
                                        end
                                    );
                                } else {
                                    return id;
                                }
                            },
                            getIconClass(cast) {
                                return {
                                    "rot-cancelled":
                                        cast.type === RotationStatus.CANCEL,
                                    "rot-unknown":
                                        cast.type === RotationStatus.UNKNOWN,
                                    "rot-animfull":
                                        cast.type === RotationStatus.FULL,
                                    "rot-instant":
                                        cast.type === RotationStatus.INSTANT,
                                };
                            },
                            getTooltip(cast) {
                                var tooltip = `${cast.skill.name} at ${cast.time}s`;
                                if (cast.type === RotationStatus.INSTANT) {
                                    return tooltip;
                                } else {
                                    return tooltip + ` for ${cast.duration}ms`;
                                }
                            },
                        },
                        computed: {
                            actor: function () {
                                return this.enemy
                                    ? logData.targets[this.actorindex]
                                    : logData.players[this.actorindex];
                            },
                            actorRotation: function () {
                                return this.actor.details.rotation[0];
                            },
                            actorNoInstantRotation: function () {
                                var actorNoInstantRotation = [];
                                var actorNoInstantRotationIndex = [];
                                for (
                                    var i = 0;
                                    i < this.actorRotation.length;
                                    i++
                                ) {
                                    var rot = this.actorRotation[i];
                                    if (rot[3] !== RotationStatus.INSTANT) {
                                        actorNoInstantRotation.push(rot);
                                        actorNoInstantRotationIndex.push(i);
                                    }
                                }
                                return [
                                    actorNoInstantRotation,
                                    actorNoInstantRotationIndex,
                                ];
                            },
                            rotation: function () {
                                var res = {
                                    current: null,
                                    nexts: [],
                                };
                                if (this.actorRotation.length === 0) {
                                    return res;
                                }
                                var time = this.timeToUse / 1000.0;
                                var id = this.findRotationIndex(
                                    this.actorRotation,
                                    time,
                                    0,
                                    this.actorRotation.length - 1
                                );
                                var item = this.actorRotation[id];
                                var x = item[0];
                                var duration = this.getSkillDuration(item);
                                var drawItem = false;
                                var [
                                    actorNoInstantRotation,
                                    actorNoInstantRotationIndex,
                                ] = this.actorNoInstantRotation;
                                if (x <= time && time <= x + duration) {
                                    drawItem = true;
                                } else if (
                                    item[3] === RotationStatus.INSTANT &&
                                    actorNoInstantRotation.length
                                ) {
                                    var idNoInstant = this.findRotationIndex(
                                        actorNoInstantRotation,
                                        time,
                                        0,
                                        actorNoInstantRotation.length - 1
                                    );
                                    id = Math.min(
                                        id,
                                        actorNoInstantRotationIndex[idNoInstant]
                                    );
                                    if (id !== idNoInstant) {
                                        item = this.actorRotation[id];
                                        x = item[0];
                                        duration = this.getSkillDuration(item);
                                        if (x <= time && time <= x + duration) {
                                            drawItem = true;
                                        }
                                    }
                                }
                                if (drawItem) {
                                    res.current = {
                                        time: item[0],
                                        skill: findSkill(false, item[1]),
                                        duration: item[2],
                                        type: item[3],
                                    };
                                    id++;
                                }
                                for (
                                    var j = id;
                                    j < this.actorRotation.length;
                                    j++
                                ) {
                                    var next = this.actorRotation[j];
                                    if (next[0] >= time) {
                                        res.nexts.push({
                                            time: next[0],
                                            skill: findSkill(false, next[1]),
                                            duration: next[2],
                                            type: next[3],
                                        });
                                    }
                                    if (res.nexts.length == 4) {
                                        break;
                                    }
                                }
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("combat-replay-target-stats-component", {
                        props: ["targetindex", "time", "buffstoshow"],
                        template: `    <div>        <combat-replay-actor-buffs-stats-component v-if="buffstoshow.length > 0" :time="time" :actorindex="targetindex" :enemy="true" :buffstoshow="buffstoshow"/>        <div class="d-flex mb-1 mt-1">            <combat-replay-target-status-component :time="time" :targetindex="targetindex"/>            <combat-replay-actor-rotation-component :time="time" :actorindex="targetindex" :enemy="true"/>        </div>        <div v-if="hasBreakbarPercent" class="cr-breakbar-phase-display mb-1">            <ul class="nav nav-pills d-flex flex-row flex-wrap justify-content-center">                <li class="nav-item" v-for="(phase, id) in breakbarPhases"                    @click="updatePhaseTime(phase.start * 1000, phase.end * 1000, phase.name)"                    :data-original-title="getTooltip(phase)">                    <a class="nav-link">{{id + 1}} </a>                </li>            </ul>        </div>    </div>`,
                        methods: {
                            updatePhaseTime: function (min, max, name) {
                                animator.updateTime(min);
                                sliderDelimiter.min = min;
                                sliderDelimiter.max = max;
                                sliderDelimiter.name = name;
                            },
                            getTooltip: function (phase) {
                                var target = logData.targets[this.targetindex];
                                var phaseId = logData.phases.indexOf(phase);
                                var breakbarTaken =
                                    target.details.dmgDistributionsTaken[
                                        phaseId
                                    ].contributedBreakbarDamage;
                                return (
                                    phase.durationS +
                                    " seconds <br /> Start: " +
                                    phase.start +
                                    "<br /> End: " +
                                    phase.end +
                                    "<br /> Breakbar Damage: " +
                                    breakbarTaken
                                );
                            },
                        },
                        computed: {
                            breakbarPhases: function () {
                                if (!this.hasBreakbarPercent) {
                                    return [];
                                }
                                return logData.phases.filter(
                                    (phase) =>
                                        phase.breakbarPhase &&
                                        phase.targets.indexOf(
                                            this.targetindex
                                        ) > -1
                                );
                            },
                            hasBreakbarPercent: function () {
                                return !!this.breakbarPercent;
                            },
                            breakbarPercent: function () {
                                return graphData.phases[0]
                                    .targetsBreakbarPercentStatesForCR[
                                    this.targetindex
                                ];
                            },
                        },
                    });
                }
                {
                    Vue.component("combat-replay-target-status-component", {
                        props: ["targetindex", "time"],
                        template: `    <div class="d-flex flex-column justify-content-center align-items-center">        <div class="target-status" :style="{'background': getHPGradient(time, status)}" @click="select" :title="target.name + ' - ' + target.health + ' health'">            <h6 class="actor-shorten-cr text-center">                <img v-for="(marker, index) in activeMarkers()" :src="marker.imageUrl" height="16" width="16">                <img :src="target.icon" height="18" width="18"/>                {{target.name}}            </h6>            <p class="text-right cr-hp-display">                {{(Math.round(100*getHPPercent(time))/100).toFixed(2)}} %            </p>            <p v-if="hasBarrier" class="text-right cr-barrier-display cr-barrier-display-target">                {{(Math.round(100*getBarrierPercent(time))/100).toFixed(2)}} %            </p>            <div v-if="hasBarrier" class="cr-barrier" :style="{'background': getBarrierGradient(time, status)}"></div>        </div>        <div v-if="hasBreakbarPercent" class="cr-breakbar-display">            <div class="cr-breakbar-bar" :style="{'background': getBreakbarGradient(time)}">                <p class="text-center" style="margin: 0;">                    {{(Math.round(100*getBreakbarPercent(time))/100).toFixed(2)}} %                </p>            </div>        </div>    </div>`,
                        methods: {
                            select() {
                                animator.selectActor(this.target.uniqueID);
                            },
                            activeMarkers: function () {
                                return animator.getActiveActorMarkers(
                                    this.target.uniqueID
                                );
                            },
                            getBreakbarPercent: function (time) {
                                if (!this.hasBreakbarPercent) {
                                    return 100.0;
                                }
                                return findState(
                                    this.breakbarPercent,
                                    time / 1000.0,
                                    0,
                                    this.breakbarPercent.length - 1
                                );
                            },
                            getHPPercent: function (time) {
                                return findState(
                                    this.healths,
                                    time / 1000.0,
                                    0,
                                    this.healths.length - 1
                                );
                            },
                            getBarrierPercent: function (time) {
                                if (!this.hasBarrier) {
                                    return 0;
                                }
                                return findState(
                                    this.barriers,
                                    time / 1000.0,
                                    0,
                                    this.barriers.length - 1
                                );
                            },
                            getHPGradient: function (time, status) {
                                var color =
                                    status === 0
                                        ? "black"
                                        : status === 1
                                        ? "red"
                                        : status === 2
                                        ? "grey"
                                        : "green";
                                return computeGradient(
                                    color,
                                    this.getHPPercent(time),
                                    "black"
                                );
                            },
                            getBreakbarGradient: function (time) {
                                var color = animator
                                    .getActorData(this.target.uniqueID)
                                    .isBreakbarActive()
                                    ? "#20B2AA"
                                    : "#888888";
                                return computeGradient(
                                    color,
                                    this.getBreakbarPercent(time),
                                    "black"
                                );
                            },
                            getBarrierGradient: function (time, status) {
                                return computeGradient(
                                    "rgba(0,0,0,0)",
                                    100 - this.getBarrierPercent(time),
                                    "rgba(228,148,97, 0.5)"
                                );
                            },
                        },
                        computed: {
                            phase: function () {
                                return logData.phases[0];
                            },
                            status: function () {
                                var crTData = animator.getActorData(
                                    this.target.uniqueID
                                );
                                var icon = crTData.getIcon(this.time);
                                return icon === deadIcon
                                    ? 0
                                    : icon === downAllyIcon ||
                                      icon === downEnemyIcon
                                    ? 1
                                    : icon === dcIcon
                                    ? 2
                                    : 3;
                            },
                            healths: function () {
                                return graphData.phases[0]
                                    .targetsHealthStatesForCR[this.targetindex];
                            },
                            breakbarPercent: function () {
                                return graphData.phases[0]
                                    .targetsBreakbarPercentStatesForCR[
                                    this.targetindex
                                ];
                            },
                            barriers: function () {
                                return graphData.phases[0]
                                    .targetsBarrierStatesForCR[
                                    this.targetindex
                                ];
                            },
                            hasBreakbarPercent: function () {
                                return !!this.breakbarPercent;
                            },
                            hasBarrier: function () {
                                return !!this.barriers;
                            },
                            target: function () {
                                return logData.targets[this.targetindex];
                            },
                        },
                    });
                }
                {
                    Vue.component("combat-replay-targets-stats-component", {
                        props: ["time", "selectedtargetid"],
                        template: `    <div>        <ul class="nav nav-pills d-flex flex-row justify-content-center mb-1 scale65">            <li v-for="(buffType, index) in possibleBuffs" class="ml-1 mr-1">                <input :id="'crtar-possibleBuffs-' + index" type="checkbox" :value="buffType" v-model="buffsToShow" />                <label :for="'crtar-possibleBuffs-' + index">{{buffType}}</label>            </li>        </ul>        <div class="mt-1 combat-actor-status-container scrollable-y">            <div class="d-flex flex-column justify-content-center align-items-center">                <div v-for="targetData in targets" v-if="render(targetData)" class="target-data ml-1 mr-1" :class="{active: selectedtargetid === targetData.target.uniqueID}">                    <combat-replay-target-stats-component :time="time" :targetindex="targetData.target.id" :buffstoshow="buffsToShow"/>                </div>            </div>        </div>    </div>`,
                        data: function () {
                            return {
                                buffsToShow: [
                                    "Others",
                                    "Boons",
                                    "Encounter Specifics",
                                    "Conditions",
                                ],
                            };
                        },
                        methods: {
                            render: function (targetData) {
                                var crTarget = targetData.crTarget;
                                return (
                                    crTarget.canDraw() &&
                                    ((crTarget.start === -1 &&
                                        crTarget.end === -1) ||
                                        (crTarget.start <= this.time &&
                                            crTarget.end >= this.time))
                                );
                            },
                        },
                        computed: {
                            possibleBuffs: function () {
                                return [
                                    "Boons",
                                    "Conditions",
                                    "Encounter Specifics",
                                    "Shared",
                                    "Others",
                                ];
                            },
                            targets: function () {
                                var res = [];
                                for (
                                    var i = 0;
                                    i < logData.targets.length;
                                    i++
                                ) {
                                    var target = logData.targets[i];
                                    var crTarget = animator.getActorData(
                                        target.uniqueID
                                    );
                                    if (crTarget) {
                                        res.push({
                                            target: target,
                                            crTarget: crTarget,
                                        });
                                    }
                                }
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("combat-replay-players-stats-component", {
                        props: ["time", "selectedplayerid"],
                        mixins: [encounterPhaseComponent],
                        template: `    <div class="d-flex flex-row flex-wrap justify-content-center align-items-start mb-2">        <ul class="nav nav-pills d-flex flex-row justify-content-center mb-1 scale85">            <li class="nav-item">                <a class="nav-link" :class="{active: buffs}" @click="buffs = !buffs">                    Show Buffs                </a>            </li>            <li class="nav-item">                <a class="nav-link" :class="{active: rotation}" @click="rotation = !rotation">Show Rotation</a>            </li>        </ul>                            <ul class="nav nav-pills d-flex flex-row justify-content-center mb-1 scale65">            <li v-for="(buffType, index) in possibleBuffs" class="ml-1 mr-1">                <input :id="'crpl-possibleBuffs-' + index" type="checkbox" :value="buffType" v-model="buffsToShow" />                <label :for="'crpl-possibleBuffs-' + index">{{buffType}}</label>            </li>        </ul>        <div class="d-flex flex-column combat-actor-status-container scrollable-y" :style="!singleGroup ? {'transform': 'translate(-24px,0);'} : null">            <div v-for="(group,id) in groups" v-if="group" class="d-flex flex-row align-items-center ml-2 mt-1">                <h5 v-if="!singleGroup" style="width:42px" class="text-center mt-2">Gr.{{id}}</h5>                <div class="d-flex flex-row flex-wrap align-items-center ml-1 mr-1" style="width:340px;border: 2px solid #888;">                    <div v-for="playerData in group" class="player-data ml-1" :class="{active: selectedplayerid === playerData.player.uniqueID}">                        <combat-replay-player-stats-component :time="time" :buffs="buffs" :rotation="rotation" :playerindex="playerData.player.id" :buffstoshow="buffsToShow"></combat-replay-player-stats-component>                    </div>                </div>            </div>        </div>    </div>`,
                        data: function () {
                            return {
                                buffs: false,
                                rotation: true,
                                buffsToShow: [
                                    "Others",
                                    "Shared",
                                    "Consumables",
                                    "Boons",
                                ],
                            };
                        },
                        computed: {
                            singleGroup: function () {
                                return logData.singleGroup;
                            },
                            possibleBuffs: function () {
                                return [
                                    "Boons",
                                    "Conditions",
                                    "Encounter Specifics",
                                    "Shared",
                                    "Consumables",
                                    "Others",
                                ];
                            },
                            groups: function () {
                                var res = [];
                                var i = 0;
                                const encounterPlayers =
                                    getActiveNonFakePlayersForPhase(
                                        this.encounterPhase
                                    );
                                const players = getActiveNonFakePlayers(
                                    this.time * 0.001
                                );
                                for (i = 0; i < players.length; i++) {
                                    var playerData = players[i];
                                    if (!playerData || !encounterPlayers[i]) {
                                        continue;
                                    }
                                    var crPlayer = animator.getActorData(
                                        playerData.uniqueID
                                    );
                                    if (!crPlayer) {
                                        continue;
                                    }
                                    if (!res[playerData.group]) {
                                        res[playerData.group] = [];
                                    }
                                    res[playerData.group].push({
                                        player: playerData,
                                        crPlayer: crPlayer,
                                    });
                                }
                                return res;
                            },
                        },
                    });
                }
                {
                    Vue.component("combat-replay-ui-component", {
                        props: ["mode", "light"],
                        template: `    <div class="d-flex mt-2 justify-content-center">        <div class="d-flex flex-column align-items-center mr-2" style="margin-left: auto; width:620px;">            <combat-replay-damage-data-component :time="animationStatus.time" :selectedplayerid="animationStatus.selectedActorID">            </combat-replay-damage-data-component>            <combat-replay-extra-decorations-component :light="light"></combat-replay-extra-decorations-component>        </div>        <combat-replay-animation-control-component :light="light" :range="animationStatus.range":animated="animationStatus.animated">                </combat-replay-animation-control-component>        <div class="d-flex flex-column align-items-center ml-2" style="margin-right: auto;width:500px;">            <combat-replay-status-data-component :time="animationStatus.time" :selectedactorid="animationStatus.selectedActorID">            </combat-replay-status-data-component>        </div>    </div>`,
                        data: function () {
                            return {
                                animationStatus: reactiveAnimationData,
                                selectionMode: 0,
                                targetless: logData.targetless,
                            };
                        },
                        created() {
                            animator = new Animator(crData);
                        },
                        activated() {
                            if (
                                this.animationStatus.animated &&
                                animator != null
                            ) {
                                animator.startAnimate(false);
                            }
                        },
                        deactivated() {
                            if (
                                this.animationStatus.animated &&
                                animator != null
                            ) {
                                animator.stopAnimate(false);
                            }
                        },
                    });
                }
                {
                    Vue.component("combat-replay-extra-decorations-component", {
                        props: ["light"],
                        template: `    <div class="d-flex flex-column justify-content-center align-items-center" style="max-width: 500px;">                   <h4>General Settings</h4>        <div class="d-flex flex-row justify-content-center flex-wrap">            <div class="form-check mb-2 mr-2" :data-original-title="'Viewpoint will follow selected actor, as long as selected actor is drawn'">                <input type="checkbox" class="form-check-input" id="followCheck"                     :checked="getAnimator().displaySettings.followSelected" v-on:change="getAnimator().toggleFollowSelected()">                <label class="form-check-label" for="followCheck">Follow Selected</label>            </div>            <div class="form-check mb-2 mr-2" :data-original-title="'Selected player in green, group in blue'">                <input type="checkbox" class="form-check-input" id="subgroupCheck"                     :checked="getAnimator().displaySettings.highlightSelectedGroup" v-on:change="getAnimator().toggleHighlightSelectedGroup()">                <label class="form-check-label" for="subgroupCheck">Highlight Selected Group</label>            </div>            <div v-if="showSecondaryNPCs" class="form-check mb-2 mr-2" :data-original-title="'Display not important NPCs in the arena'">                <input type="checkbox" class="form-check-input" id="trashCheck"                     :checked="getAnimator().displaySettings.displayTrashMobs" v-on:change="getAnimator().toggleTrashMobs()">                <label class="form-check-label" for="trashCheck">Secondary NPCs</label>            </div>             <div v-if="showMechanics" class="form-check mb-2 mr-2" :data-original-title="'Encounter mechanics'">                <input type="checkbox" class="form-check-input" id="mechanicsCheck"                     :checked="getAnimator().displaySettings.displayMechanics" v-on:change="getAnimator().toggleMechanics()">                <label class="form-check-label" for="mechanicsCheck">Mechanics</label>            </div>            <div v-if="showSquadMarkers" class="form-check mb-2 mr-2" :data-original-title="'Squad markers, on the ground and on players'">                <input type="checkbox" class="form-check-input" id="markersCheck"                     :checked="getAnimator().displaySettings.displaySquadMarkers" v-on:change="getAnimator().toggleSquadMarkers()">                <label class="form-check-label" for="markersCheck">Markers</label>            </div>            <div v-if="showSkills" class="form-check mb-2 mr-2" :data-original-title="'Player skills'">                <input type="checkbox" class="form-check-input" id="skillsCheck"                     :checked="getAnimator().displaySettings.displaySkillMechanics" v-on:change="getAnimator().toggleSkills()">                <label class="form-check-label" for="skillsCheck">Skills</label>            </div>            <div class="form-check mb-2 mr-2" :data-original-title="'Use the in game hitbox size'">                <input type="checkbox" class="form-check-input" id="actorHitboxCheck"                     :checked="getAnimator().displaySettings.useActorHitboxWidth" v-on:change="getAnimator().toggleUseActorHitboxWidth()">                <label class="form-check-label" for="actorHitboxCheck">Use Hitbox Size</label>            </div>             <div class="form-check mb-2 mr-2" :data-original-title="'Display all minions'">                <input type="checkbox" class="form-check-input" id="allMinionsCheck"                     :checked="getAnimator().displaySettings.displayAllMinions" v-on:change="getAnimator().toggleDisplayAllMinions()">                <label class="form-check-label" for="allMinionsCheck">All Minions</label>            </div>                 <div class="form-check mb-2 mr-2" :data-original-title="'Display current selection minions'">                <input type="checkbox" class="form-check-input" id="selectedMinionsCheck"                     :checked="getAnimator().displaySettings.displaySelectedMinions" v-on:change="getAnimator().toggleDisplaySelectedMinions()">                <label class="form-check-label" for="selectedMinionsCheck">Selected's Minions</label>            </div>        </div>        <div v-if="showSkills" class="d-flex flex-column justify-content-center align-items-center" style="max-width: 500px;">            <h4>Global Skill Settings</h4>            <div class="d-flex flex-row justify-content-center flex-wrap">                <div class="form-check mb-2 mr-2" v-for="skillCategory in skillCategories">                    <input type="checkbox" class="form-check-input" :id="skillCategory.key"                         :checked="(getAnimator().displaySettings.skillMechanicsMask & skillCategory.mask) > 0" v-on:change="getAnimator().toggleSkillCategoryMask(skillCategory.mask)">                    <label class="form-check-label" :for="skillCategory.key">{{skillCategory.key}}</label>                </div>            </div>        </div>        <div class="d-flex flex-row justify-content-center">            <div class="mr-3">                <h4>Range Selectors</h4>                <div class="form-check mt-1 mb-2">                    <input type="checkbox" class="form-check-input" id="circle1Check"                         :checked=" getAnimator().rangeControl[0].enabled" v-on:change="getAnimator().toggleRange(0)">                    <label class="form-check-label" for="circle1Check">Circle 1</label>                </div>                <div class="d-flex flex-row justify-content-between align-items-center">                    <span>Radius: </span>                    <custom-numberform-component style="width: 100px;" :minValue="1" :id="'circle1Text'"                                                        :placeholderValue="getAnimator().rangeControl[0].radius"></custom-numberform-component>                </div>                <div class="form-check mt-1 mb-2">                    <input type="checkbox" class="form-check-input" id="circle2Check"                         :checked=" getAnimator().rangeControl[1].enabled" v-on:change="getAnimator().toggleRange(1)">                    <label class="form-check-label" for="circle2Check">Circle 2</label>                </div>                <div class="d-flex flex-row justify-content-between align-items-center">                    <span>Radius: </span>                    <custom-numberform-component style="width: 100px;" :minValue="1" :id="'circle2Text'"                                                        :placeholderValue="getAnimator().rangeControl[1].radius"></custom-numberform-component>                </div>                <div class="form-check mt-1 mb-2">                    <input type="checkbox" class="form-check-input" id="circle3Check"                         :checked=" getAnimator().rangeControl[2].enabled" v-on:change="getAnimator().toggleRange(2)">                    <label class="form-check-label" for="circle3Check">Circle 3</label>                </div>                <div class="d-flex flex-row justify-content-between align-items-center">                    <span>Radius: </span>                    <custom-numberform-component style="width: 100px;" :minValue="1" :id="'circle3Text'"                                                        :placeholderValue="getAnimator().rangeControl[2].radius"></custom-numberform-component>                </div>            </div>            <div class="ml-3">                <h4 data-original-title="Has an effect only when facing arrow are present">Cone Indicator</h4>                <div class="form-check mt-1 mb-2">                    <input type="checkbox" class="form-check-input" id="coneCheck"                         :checked=" getAnimator().coneControl.enabled" v-on:change="getAnimator().toggleConeDisplay()">                    <label class="form-check-label" for="coneCheck">Display Cone</label>                </div>                <div class="d-flex flex-row justify-content-between align-items-center mb-1">                    <span>Radius: </span>                    <custom-numberform-component style="width: 100px;" :minValue="1" :id="'coneRadiusText'"                                                        :placeholderValue="getAnimator().coneControl.radius"></custom-numberform-component>                </div>                <div class="d-flex flex-row justify-content-between align-items-center mt-1">                    <span>Opening: </span>                    <custom-numberform-component style="width: 100px;" :minValue="1" :maxValue="360" :id="'coneAngleText'"                                                        :placeholderValue="getAnimator().coneControl.openingAngle"></custom-numberform-component>                </div>            </div>        </div>    </div>`,
                        data: function () {
                            return {
                                showSkills:
                                    animator.skillMechanicActorData.any(),
                                showMechanics:
                                    animator.overheadActorData.any() ||
                                    animator.mechanicActorData.any(),
                                showSquadMarkers:
                                    animator.squadMarkerData.any() ||
                                    animator.overheadSquadMarkerData.any(),
                                showSecondaryNPCs: animator.trashMobData.any(),
                            };
                        },
                        methods: {
                            getAnimator: function () {
                                return animator;
                            },
                        },
                        computed: {
                            skillCategories: function () {
                                var res = [];
                                for (var key in SkillDecorationCategory) {
                                    res.push({
                                        key: key,
                                        mask: SkillDecorationCategory[key],
                                    });
                                }
                                return res;
                            },
                        },
                        mounted() {
                            $("#circle1Text").on("input ", function () {
                                animator.setRangeRadius(
                                    0,
                                    Number.parseFloat($(this).val())
                                );
                            });
                            $("#circle2Text").on("input ", function () {
                                animator.setRangeRadius(
                                    1,
                                    Number.parseFloat($(this).val())
                                );
                            });
                            $("#circle3Text").on("input ", function () {
                                animator.setRangeRadius(
                                    2,
                                    Number.parseFloat($(this).val())
                                );
                            });
                            $("#coneRadiusText").on("input ", function () {
                                animator.setConeRadius(
                                    Number.parseFloat($(this).val())
                                );
                            });
                            $("#coneAngleText").on("input ", function () {
                                animator.setConeAngle(
                                    Number.parseFloat($(this).val())
                                );
                            });
                        },
                    });
                }
                {
                    Vue.component("combat-replay-animation-control-component", {
                        props: ["light", "animated", "range"],
                        template: `    <div class="d-flex flex-column justify-content-center align-items-center" style="width: 750px;">        <div v-if="showNormalPhases" class="mb-1">            <ul class="nav nav-pills d-flex flex-row justify-content-center" style="max-width: 700px;">                <li class="nav-item" v-for="(phase, id) in phases"                    v-show="!phase.breakbarPhase"                    :data-original-title="phase.durationS + ' seconds <br /> Start: ' + phase.start + '<br /> End: ' + phase.end">                    <a class="nav-link" @click="updatePhaseTime(phase)">{{getPhaseName(phase)}}</a>                </li>            </ul>        </div>        <div class="d-flex flex-column justify-content-center flex-wrap mt-1"            :style="{'width': Math.max(canvasSize.x, canvasSize.y) + 'px'}">            <div class="d-flex flex-column justify-content-center align-items-center"                :style="{'width': '100%', 'min-width': canvasSize.x + 'px', 'height': canvasSize.y + 'px', 'position': 'relative'}">                <canvas :width="canvasSize.x + 'px'" :height="canvasSize.y + 'px'" :id="htmlElementIDs.mainCanvasID"                    class="replay"></canvas>                <canvas :width="canvasSize.x + 'px'" :height="canvasSize.y + 'px'" :id="htmlElementIDs.bgCanvasID"                    class="replay"></canvas>                <canvas :width="canvasSize.x + 'px'" :height="canvasSize.y + 'px'" :id="htmlElementIDs.pickCanvasID"                    class="replay"></canvas>            </div>            <div class="animation-control">                <div class="d-flex justify-content-center mb-1">                    <div @click="toggleAnimate();" class="btn btn-small"                        :class="{'btn-dark': !light, 'btn-light': light}" style="width: 50px;">{{animated ? "Pause" :                        "Play"}}</div>                    <div @click="restartAnimate();" class="btn btn-small"                        :class="{'btn-dark': !light, 'btn-light': light}">                        Restart                    </div>                    <div @click="toggleBackwards();" class="btn btn-small"                        :class="{'active': backwards, 'btn-dark': !light, 'btn-light': light}">Backwards</div>                    <div @click="resetViewpoint();" class="btn btn-small"                        :class="{'btn-dark': !light, 'btn-light': light}">Reset Viewpoint</div>                </div>                <div class="d-flex justify-content-center slidercontainer mt-1">                    <input style="min-width: 400px;" @input="updateTime($event.target.value)" type="range" :min="minTime"                        :max="maxTime" value="0" class="slider" :id="htmlElementIDs.timeRangeID"                        :style="{'background': getSliderGradient()}">                    <p style="position: absolute; color: black; pointer-events:none;">                        {{sliderDelimiter.name}}                    </p>                    <input style="width: 70px; text-align: right;" class="ml-3 mr-1" type="text"                        :id="htmlElementIDs.timeRangeDisplayID" value="0"                        @input="updateInputTime($event.target.value);">                </div>                <div class="d-flex justify-content-center">                    <label v-for="speed in speeds" @click="setSpeed(speed)"                        :class="{'active': speed === selectedSpeed, 'btn-dark': !light, 'btn-light': light}"                        class="btn btn-ssmall">                        {{speed}}x                    </label>                </div>                <p class="text-justify text-center">You can click on the canvas to select agents</p>            </div>        </div>    </div>`,
                        mixins: [encounterPhaseComponent],
                        data: function () {
                            return {
                                selectedSpeed: 1,
                                backwards: false,
                                sliderDelimiter: sliderDelimiter,
                            };
                        },
                        watch: {
                            encounters: {
                                handler: function () {
                                    // make sure DOM is attached
                                    if (animator.mainCanvas) {
                                        const encounterPhase =
                                            this.encounterPhase;
                                        this.updateAnimatorTimes(
                                            encounterPhase
                                        );
                                    }
                                },
                                deep: true,
                            },
                        },
                        mounted() {
                            animator.attachDOM(
                                this.htmlElementIDs.mainCanvasID,
                                this.htmlElementIDs.bgCanvasID,
                                this.htmlElementIDs.pickCanvasID,
                                this.htmlElementIDs.timeRangeID,
                                this.htmlElementIDs.timeRangeDisplayID
                            );
                            const encounterPhase = this.encounterPhase;
                            this.updateAnimatorTimes(encounterPhase);
                        },
                        computed: {
                            phases: function () {
                                for (
                                    let i = 0;
                                    i < this.encounters.length;
                                    i++
                                ) {
                                    const encounter = this.encounters[i];
                                    if (encounter.active) {
                                        const phase =
                                            logData.phases[encounter.index];
                                        let phases = [];
                                        if (
                                            phase.type === PhaseTypes.INSTANCE
                                        ) {
                                            if (IsMultiEncounterLog) {
                                                return logData.phases.filter(
                                                    (x) =>
                                                        x.type ===
                                                            PhaseTypes.ENCOUNTER ||
                                                        x.type ===
                                                            PhaseTypes.INSTANCE
                                                );
                                            } else {
                                                return logData.phases;
                                            }
                                        } else {
                                            if (IsMultiEncounterLog) {
                                                for (
                                                    let j = 0;
                                                    j < logData.phases.length;
                                                    j++
                                                ) {
                                                    const subPhase =
                                                        logData.phases[j];
                                                    if (
                                                        subPhase === phase ||
                                                        subPhase.encounterPhase ===
                                                            encounter.index
                                                    ) {
                                                        phases.push(subPhase);
                                                    }
                                                }
                                            } else {
                                                return logData.phases;
                                            }
                                        }
                                        return phases;
                                    }
                                }
                                return logData.phases;
                            },
                            showNormalPhases: function () {
                                return (
                                    this.normalPhases.length > 1 ||
                                    this.hasBreakbarPhases
                                );
                            },
                            normalPhases: function () {
                                return this.phases.filter(
                                    (phase) => !phase.breakbarPhase
                                );
                            },
                            hasBreakbarPhases: function () {
                                return (
                                    this.phases.filter(
                                        (phase) => phase.breakbarPhase
                                    ).length > 0
                                );
                            },
                            speeds: function () {
                                return [
                                    0.125, 0.25, 0.5, 1.0, 2.0, 4.0, 8.0, 16.0,
                                ];
                            },
                            maxTime: function () {
                                return this.range.max - this.range.min;
                            },
                            minTime: function () {
                                return 0;
                            },
                            canvasSize: function () {
                                return {
                                    x: crData.sizes[0],
                                    y: crData.sizes[1],
                                };
                            },
                            htmlElementIDs: function () {
                                return {
                                    mainCanvasID: "main-canvas",
                                    bgCanvasID: "bg-canvas",
                                    pickCanvasID: "picking-canvas",
                                    timeRangeID: "timeRange",
                                    timeRangeDisplayID: "timeRangeDisplay",
                                };
                            },
                        },
                        methods: {
                            updateAnimatorTimes(phase) {
                                animator.updateRange(phase);
                                this.updatePhaseTime(phase);
                                animator._reselectIfEnglobed();
                            },
                            getSliderGradient: function () {
                                var startPercent, endPercent;
                                if (
                                    !this.sliderDelimiter ||
                                    this.sliderDelimiter.min === -1
                                ) {
                                    startPercent = 0;
                                    endPercent = 100;
                                } else {
                                    var max = this.maxTime;
                                    startPercent =
                                        (this.sliderDelimiter.min / max) * 100;
                                    endPercent =
                                        (this.sliderDelimiter.max / max) * 100;
                                }
                                return computeSliderGradient(
                                    "#888888",
                                    "#F3F3F3",
                                    startPercent,
                                    endPercent
                                );
                            },
                            getPhaseData: function (id) {
                                return logData.phases[id];
                            },
                            toggleBackwards: function () {
                                this.backwards = animator.toggleBackwards();
                            },
                            resetViewpoint: function () {
                                animator.resetViewpoint();
                            },
                            toggleAnimate: function () {
                                animator.toggleAnimate();
                            },
                            restartAnimate: function () {
                                animator.restartAnimate();
                            },
                            setSpeed: function (speed) {
                                animator.setSpeed(speed);
                                this.selectedSpeed = speed;
                            },
                            updateTime: function (value) {
                                const offset = this.range.min;
                                animator.updateTime(parseInt(value) + offset);
                            },
                            getPhaseName: function (phase) {
                                return phase === this.encounterPhase
                                    ? phase.nameNoMode
                                    : phase.name;
                            },
                            updatePhaseTime: function (phase) {
                                var min = phase.start * 1000;
                                var max = phase.end * 1000;
                                var name = this.getPhaseName(phase);
                                const offset = this.range.min;
                                this.sliderDelimiter.min = min - offset;
                                this.sliderDelimiter.max = max - offset;
                                this.sliderDelimiter.name = name;
                                this.updateTime(min - offset);
                            },
                            updateInputTime: function (value) {
                                animator.updateInputTime(value);
                            },
                        },
                    });
                }
                {
                    Vue.component("combat-replay-mechanics-list-component", {
                        props: ["selectedplayerid"],
                        template: `    <div class="d-flex flex-row flex-wrap justify-content-center align-items-center">        <div id="combat-replay-mechanics-list" class="combat-replay-mechanics-list-container d-flex d-flex-row justify-content-center w-100 scrollable-y"            style="max-width:450px">            <table class="table table-sm table-striped table-hover" cellspacing="0" width="100%">                <thead>                    <tr>                        <th style="width:100px">Time</th>                        <th style="width:200px"                            class="text-left combat-replay-mechanics-list-header position-relative">                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Filter Mechanics">                                Mechanic <span class="caret"></span>                            </a>                            <ul class="dropdown-menu p-2 font-weight-normal scrollabledropdown"                                style="width: 200px;">                                <div class="d-flex flex-column justify-content-center align-items-center mb-1"                                    style="border-bottom: 2px solid #bbb;">                                    <li>                                        <button style="width:165px;" type="button" class="btn btn-primary btn-sm"                                            @click="selectAllMechanics()" @click.stop="stopClickEvent">Select all                                            mechanics</button>                                    </li>                                    <li class="mb-1">                                        <button style="width:165px;" type="button" class="btn btn-primary btn-sm"                                            @click="deselectAllMechanics()" @click.stop="stopClickEvent">Deselect all                                            mechanics</button>                                    </li>                                </div>                                <li v-for="(mechanic, index) in mechanicsList" :key="index">                                    <input :id="'crml-mechanic-' + index" type="checkbox" v-model="mechanic.included"                                        @click.stop="stopClickEvent" />                                    <label :for="'crml-mechanic-' + index" @click.stop="stopClickEvent">                                        {{mechanic.shortName}}                                    </label>                                </li>                            </ul>                        </th>                        <th style="width:150px;"                            class="text-left combat-replay-mechanics-list-header position-relative">                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Filter Actors">                                Actor <span class="caret"></span>                            </a>                            <ul class="dropdown-menu p-2 font-weight-normal scrollabledropdown"                                style="width:150px;">                                <div class="d-flex flex-column justify-content-center align-items-center mb-1"                                    style="border-bottom: 2px solid #bbb;">                                    <li>                                        <button style="width:140px;" type="button" class="btn btn-primary btn-sm"                                            @click="selectAllActors()" @click.stop="stopClickEvent">Select all                                            actors</button>                                    </li>                                    <li class="mb-1">                                        <button style="width:140px;" type="button" class="btn btn-primary btn-sm"                                            @click="deselectAllActors()" @click.stop="stopClickEvent">Deselect all                                            actors</button>                                    </li>                                </div>                                <li v-for="(actor, index) in actorsList" :key="index">                                    <input :id="'crml-actor-' + index" type="checkbox" v-model="actor.included"                                        @click.stop="stopClickEvent" />                                    <label :for="'crml-actor-' + index" @click.stop="stopClickEvent">                                        {{actor.name}}                                    </label>                                </li>                            </ul>                        </th>                    </tr>                </thead>                <tbody>                    <tr v-for="event in filteredMechanicEvents" class="combat-replay-mechanics-list-row"                        :class="{active: event.actor.id === selectedplayerid}" @click="selectMechanic(event)">                        <td :data-original-title="'Timestamp'">{{(event.time / 1000).toFixed(2)}}s</td>                        <td class="text-left" :data-original-title="event.mechanic.name">{{event.mechanic.shortName}}</td>                        <td class="text-left">                            <span class="cr-ellipsis" :data-original-title="event.actor.name">                                {{event.actor.name}}                            </span>                        </td>                    </tr>                </tbody>            </table>        </div>    </div>`,
                        data: function () {
                            var mechanicEvents = [];
                            var phase = logData.phases[0];
                            var phaseTargets = phase.targets;
                            for (
                                var mechI = 0;
                                mechI < graphData.mechanics.length;
                                mechI++
                            ) {
                                var graphMechData = graphData.mechanics[mechI];
                                var logMechData = logData.mechanicMap[mechI];
                                var mechData = {
                                    name: logMechData.name,
                                    shortName: logMechData.shortName,
                                };
                                var pointsArray = graphMechData.points[0];
                                var icd = logMechData.icd;
                                // players
                                if (!logMechData.enemyMech) {
                                    for (
                                        var playerI = 0;
                                        playerI < pointsArray.length;
                                        playerI++
                                    ) {
                                        var lastTime = -1000000;
                                        var points = pointsArray[playerI];
                                        var player = logData.players[playerI];
                                        for (
                                            var i = 0;
                                            i < points.length;
                                            i++
                                        ) {
                                            var time = points[i][0] * 1000; // when mechanic occured in seconds
                                            if (
                                                icd === 0 ||
                                                time - lastTime > icd
                                            ) {
                                                mechanicEvents.push({
                                                    time: time,
                                                    actor: {
                                                        name: player.name,
                                                        enemy: false,
                                                        id: player.uniqueID,
                                                    },
                                                    mechanic: mechData,
                                                });
                                            }
                                            lastTime = time;
                                        }
                                    }
                                } else {
                                    // enemy
                                    for (
                                        var targetI = 0;
                                        targetI < pointsArray.length;
                                        targetI++
                                    ) {
                                        var points = pointsArray[targetI];
                                        var tarId = phaseTargets[targetI];
                                        // target tracked in phase
                                        if (tarId >= 0) {
                                            var target = logData.targets[tarId];
                                            for (
                                                var i = 0;
                                                i < points.length;
                                                i++
                                            ) {
                                                var time = points[i][0]; // when mechanic occured in seconds
                                                mechanicEvents.push({
                                                    time: time * 1000,
                                                    actor: {
                                                        name: target.name,
                                                        enemy: true,
                                                        id: -1,
                                                    }, // target selection not supported
                                                    mechanic: mechData,
                                                });
                                            }
                                        } else {
                                            // target not tracked in phase
                                            for (
                                                var i = 0;
                                                i < points.length;
                                                i++
                                            ) {
                                                var time = points[i][0]; // when mechanic occured in seconds
                                                mechanicEvents.push({
                                                    time: time * 1000,
                                                    actor: {
                                                        name: points[i][1],
                                                        enemy: true,
                                                        id: -1,
                                                    },
                                                    mechanic: mechData,
                                                });
                                            }
                                        }
                                    }
                                }
                            }

                            mechanicEvents.sort(function (a, b) {
                                return a.time - b.time;
                            });

                            var actors = {};
                            var mechanics = {};
                            for (var i = 0; i < mechanicEvents.length; i++) {
                                var event = mechanicEvents[i];
                                var mechName = event.mechanic.name;
                                var actorName = event.actor.name;
                                if (!mechanics[mechName]) {
                                    mechanics[mechName] = Object.assign(
                                        {},
                                        event.mechanic,
                                        { included: true }
                                    );
                                }
                                if (!actors[actorName]) {
                                    actors[actorName] = Object.assign(
                                        {},
                                        event.actor,
                                        { included: true }
                                    );
                                }
                            }

                            var actorsList = Object.values(actors); // could be sorted for more clarity
                            actorsList.sort(function (a, b) {
                                if (a.enemy !== b.enemy) {
                                    // Sort enemies before players
                                    return a.enemy ? -1 : 1;
                                }
                                return a.name.localeCompare(b.name);
                            });

                            var mechanicsList = Object.values(mechanics);
                            mechanicsList.sort(function (a, b) {
                                return a.shortName.localeCompare(b.shortName);
                            });

                            return {
                                mechanicEvents: mechanicEvents,
                                actors: actors,
                                actorsList: actorsList,
                                mechanics: mechanics,
                                mechanicsList: mechanicsList,
                                scrollTop: 0,
                                div: null,
                            };
                        },
                        activated() {
                            this.div = document.getElementById(
                                "combat-replay-mechanics-list"
                            );
                            this.div.scrollTop = this.scrollTop;
                            this.div.onscroll = (event) => {
                                this.scrollTop = this.div.scrollTop;
                            };
                        },
                        deactivated() {
                            this.div.onscroll = null;
                            this.div = null;
                        },
                        methods: {
                            selectMechanic: function (mechanic) {
                                animator.updateTime(mechanic.time);
                            },
                            stopClickEvent: function (event) {
                                event.stopPropagation();
                            },
                            selectAllMechanics: function () {
                                for (
                                    var i = 0;
                                    i < this.mechanicsList.length;
                                    i++
                                ) {
                                    this.mechanicsList[i].included = true;
                                }
                            },
                            selectAllActors: function () {
                                for (
                                    var i = 0;
                                    i < this.actorsList.length;
                                    i++
                                ) {
                                    this.actorsList[i].included = true;
                                }
                            },
                            deselectAllMechanics: function () {
                                for (
                                    var i = 0;
                                    i < this.mechanicsList.length;
                                    i++
                                ) {
                                    this.mechanicsList[i].included = false;
                                }
                            },
                            deselectAllActors: function () {
                                for (
                                    var i = 0;
                                    i < this.actorsList.length;
                                    i++
                                ) {
                                    this.actorsList[i].included = false;
                                }
                            },
                        },
                        computed: {
                            filteredMechanicEvents: function () {
                                return this.mechanicEvents.filter(
                                    function (event) {
                                        var actor =
                                            this.actors[event.actor.name];
                                        var mechanic =
                                            this.mechanics[event.mechanic.name];
                                        if (actor && !actor.included) {
                                            return false;
                                        }
                                        if (mechanic && !mechanic.included) {
                                            return false;
                                        }
                                        return true;
                                    }.bind(this)
                                );
                            },
                        },
                    });
                }
            }

            const noUpdateTime = -1;
            const updateText = -2;
            const deadIcon = new Image();
            deadIcon.crossOrigin = "Anonymous";
            deadIcon.onload = function () {
                animateCanvas(noUpdateTime);
            };
            const downEnemyIcon = new Image();
            downEnemyIcon.crossOrigin = "Anonymous";
            downEnemyIcon.onload = function () {
                animateCanvas(noUpdateTime);
            };
            const downAllyIcon = new Image();
            downAllyIcon.crossOrigin = "Anonymous";
            downAllyIcon.onload = function () {
                animateCanvas(noUpdateTime);
            };
            const dcIcon = new Image();
            dcIcon.crossOrigin = "Anonymous";
            dcIcon.onload = function () {
                animateCanvas(noUpdateTime);
            };
            const facingIcon = new Image();
            facingIcon.onload = function () {
                animateCanvas(noUpdateTime);
            };

            function ToRadians(degrees) {
                return degrees * (Math.PI / 180);
            }
            function ToDegrees(radians) {
                return radians / (Math.PI / 180);
            }

            const resolutionMultiplier = 2.0;

            const maxOverheadAnimationFrame = 50;
            let overheadAnimationFrame = maxOverheadAnimationFrame / 2;
            let overheadAnimationIncrement = 1;

            const uint32 = new Uint32Array(1);
            const uint32ToUint8 = new Uint8Array(uint32.buffer);

            // Define the type of the decoration. Must match ordering of the enum in CombatReplayDescription.cs
            const Types = {
                ActorOrientation: 0,
                BackgroundIcon: 1,
                Circle: 2,
                Doughnut: 3,
                Friendly: 4,
                FriendlyPlayer: 5,
                Icon: 6,
                IconOverhead: 7,
                Line: 8,
                Mob: 9,
                MovingPlatform: 10,
                Pie: 11,
                Player: 12,
                ProgressBar: 13,
                ProgressBarOverhead: 14,
                Rectangle: 15,
                SquadMarker: 16,
                SquadMarkerOverhead: 17,
                Target: 18,
                TargetPlayer: 19,
                Text: 20,
                Polygon: 21,
                TextOverhead: 22,
                Arena: 23,
            };

            function getDefaultCombatReplayTime() {
                var time = EIUrlParams.get("crTime");
                if (!time) {
                    return 0;
                }
                return Math.max(parseFloat(time), 0.0) * 1000;
            }

            var animator = null;
            // reactive structures
            const reactiveAnimationData = {
                time: getDefaultCombatReplayTime(),
                selectedActorID: null,
                animated: false,
                range: {
                    min: 0,
                    max: 1e12,
                },
            };

            var sliderDelimiter = {
                min: -1,
                max: -1,
                name: logData.phases[0].name,
            };
            //

            let InchToPixel = 10;
            let PollingRate = 150;

            // Scenegraph

            function standardDraw(drawable) {
                drawable.draw();
            }

            function selectableDraw(drawable) {
                if (!drawable.isSelected()) {
                    drawable.draw();
                    animator._drawActorOrientation(drawable.id);
                }
            }

            function selectablePickingDraw(drawable) {
                if (!drawable.isSelected()) {
                    drawable.drawPicking();
                }
            }

            class RenderablesBranch {
                constructor(start, end) {
                    this.start = start;
                    this.end = end;
                    this.halfPoint = (end - start) * 0.5 + start;
                    this.left = null;
                    this.right = null;
                    this.renderables = [];
                    this.leaf = true;
                    // Won't allow leaf below this
                    this.finalLeaf = this.end - this.start < 10000;
                }

                add(item) {
                    if (this.leaf) {
                        this.renderables.push(item);
                        // If too many renderables, remove leaf and redistribute
                        if (this.renderables.length > 50 && !this.finalLeaf) {
                            this.leaf = false;
                            const renderablesToRedistribute = this.renderables;
                            this.renderables = [];
                            for (
                                let i = 0;
                                i < renderablesToRedistribute.length;
                                i++
                            ) {
                                this.add(renderablesToRedistribute[i]);
                            }
                        }
                        return;
                    }
                    if (item.end <= this.halfPoint) {
                        if (!this.left) {
                            this.left = new RenderablesBranch(
                                this.start,
                                this.halfPoint
                            );
                        }
                        this.left.add(item);
                    } else if (
                        item.start > this.halfPoint &&
                        item.end <= this.end
                    ) {
                        if (!this.right) {
                            this.right = new RenderablesBranch(
                                this.halfPoint,
                                this.end
                            );
                        }
                        this.right.add(item);
                    } else {
                        this.renderables.push(item);
                    }
                }

                forEach(cb) {
                    for (let i = 0; i < this.renderables.length; i++) {
                        cb(this.renderables[i]);
                    }
                    if (this.left) {
                        this.left.forEach(cb);
                    }
                    if (this.right) {
                        this.right.forEach(cb);
                    }
                }

                draw(drawFunction) {
                    var time = animator.reactiveDataStatus.time;
                    if (this.start > time || this.end < time) {
                        return;
                    }
                    for (let i = 0; i < this.renderables.length; i++) {
                        drawFunction(this.renderables[i]);
                    }
                    if (this.left) {
                        this.left.draw(drawFunction);
                    }
                    if (this.right) {
                        this.right.draw(drawFunction);
                    }
                }

                any() {
                    return (
                        this.renderables.length > 0 || this.left || this.right
                    );
                }
            }

            class RenderablesRoot extends RenderablesBranch {
                constructor(start, end) {
                    super(start, end);
                    this._allRenderables = [];
                }

                add(item) {
                    super.add(item);
                    this._allRenderables.push(item);
                }
            }

            class MappedRenderablesRoot extends RenderablesRoot {
                constructor(start, end) {
                    super(start, end);
                    this.map = new Map();
                }

                add(item) {
                    super.add(item);
                    this.map.set(item.id, item);
                }

                get(id) {
                    return this.map.get(id);
                }

                has(id) {
                    return this.map.has(id);
                }
            }

            //

            class Animator {
                constructor(options) {
                    var _this = this;
                    // status
                    this.reactiveDataStatus = reactiveAnimationData;
                    // time
                    this.prevTime = 0;
                    this.times = [];
                    // simulation params
                    this.speed = 1;
                    this.backwards = false;
                    this.rangeControl = [
                        { enabled: false, radius: 180 },
                        { enabled: false, radius: 360 },
                        { enabled: false, radius: 720 },
                    ];
                    this.displaySettings = {
                        highlightSelectedGroup: true,
                        displayAllMinions: false,
                        displaySelectedMinions: true,
                        displayMechanics: true,
                        displaySquadMarkers: true,
                        displaySkillMechanics: true,
                        skillMechanicsMask: DefaultSkillDecorations,
                        displayTrashMobs: true,
                        useActorHitboxWidth: false,
                        followSelected: false,
                    };
                    this.coneControl = {
                        enabled: false,
                        openingAngle: 90,
                        radius: 360,
                    };
                    // actors
                    const start = logData.phases[0].start * 1000;
                    const end = logData.phases[0].end * 1000;
                    this.targetData = new MappedRenderablesRoot(start, end);
                    this.targetPlayerData = new MappedRenderablesRoot(
                        start,
                        end
                    );
                    this.playerData = new MappedRenderablesRoot(start, end);
                    this.trashMobData = new MappedRenderablesRoot(start, end);
                    this.friendlyMobData = new MappedRenderablesRoot(
                        start,
                        end
                    );
                    this.friendlyPlayerData = new MappedRenderablesRoot(
                        start,
                        end
                    );
                    this.decorationMetadata = new Map();
                    this.overheadActorData = new RenderablesRoot(start, end);
                    this.squadMarkerData = new RenderablesRoot(start, end);
                    this.overheadSquadMarkerData = new RenderablesRoot(
                        start,
                        end
                    );
                    this.mechanicActorData = new RenderablesRoot(start, end);
                    this.skillMechanicActorData = new RenderablesRoot(
                        start,
                        end
                    );
                    this.actorOrientationData = new Map();
                    this.backgroundActorData = [];
                    this.screenSpaceActorData = new RenderablesRoot(start, end);
                    this.agentDataPerParentID = new Map();
                    this.selectedActor = null;
                    // maps
                    this.backgroundImages = new RenderablesRoot(start, end);
                    // animation
                    this.needBGUpdate = false;
                    this.animation = null;
                    // manipulation
                    this.mouseDown = null;
                    this.dragged = false;
                    this.scale = 1.0;
                    // options
                    if (options) {
                        if (options.inchToPixel) {
                            InchToPixel = options.inchToPixel;
                        }
                        if (options.pollingRate) {
                            PollingRate = options.pollingRate;
                        }
                        if (options.actors) {
                            this._initActors(
                                options.actors,
                                options.decorationRenderings,
                                options.decorationMetadata
                            );
                        }
                        downEnemyIcon.src = UIIcons.DownedEnemy;
                        downAllyIcon.src = UIIcons.DownedAlly;
                        dcIcon.src = UIIcons.Disconnected;
                        deadIcon.src = UIIcons.Dead;
                        facingIcon.src = UIIcons.Facing;
                    }
                    let cur = start;
                    while (cur < end) {
                        this.times.push(cur);
                        cur += PollingRate;
                    }
                    this.reactiveDataStatus.time = start;
                    this.reactiveDataStatus.range.min = this.times[0];
                    this.reactiveDataStatus.range.max =
                        this.times[this.times.length - 1];
                }

                attachDOM(
                    mainCanvasID,
                    bgCanvasID,
                    pickCanvasID,
                    timeRangeID,
                    timeRangeDisplayID
                ) {
                    // animation
                    this.timeSlider = document.getElementById(timeRangeID);
                    this.timeSliderDisplay =
                        document.getElementById(timeRangeDisplayID);
                    // main canvas
                    this.mainCanvas = document.getElementById(mainCanvasID);
                    this.mainCanvas.style.width = this.mainCanvas.width + "px";
                    this.mainCanvas.style.height =
                        this.mainCanvas.height + "px";
                    this.mainCanvas.width *= resolutionMultiplier;
                    this.mainCanvas.height *= resolutionMultiplier;
                    this.mainContext = this.mainCanvas.getContext("2d");
                    this.mainContext.imageSmoothingEnabled = true;
                    // bg canvas
                    this.bgCanvas = document.getElementById(bgCanvasID);
                    this.bgCanvas.style.width = this.bgCanvas.width + "px";
                    this.bgCanvas.style.height = this.bgCanvas.height + "px";
                    this.bgCanvas.width *= resolutionMultiplier;
                    this.bgCanvas.height *= resolutionMultiplier;
                    this.bgContext = this.bgCanvas.getContext("2d");
                    this.bgContext.imageSmoothingEnabled = true;
                    // pick canvas
                    this.pickCanvas = document.getElementById(pickCanvasID);
                    this.pickCanvas.style.width = this.pickCanvas.width + "px";
                    this.pickCanvas.style.height =
                        this.pickCanvas.height + "px";
                    this.pickCanvas.width *= resolutionMultiplier;
                    this.pickCanvas.height *= resolutionMultiplier;
                    this.pickContext = this.pickCanvas.getContext("2d", {
                        willReadFrequently: true,
                    });
                    // manipulation
                    this.lastX = this.mainCanvas.width / 2;
                    this.lastY = this.mainCanvas.height / 2;
                    //
                    this._trackTransforms(this.mainContext);
                    this._trackTransforms(this.bgContext);
                    this._trackTransforms(this.pickContext);
                    this.mainContext.scale(
                        resolutionMultiplier,
                        resolutionMultiplier
                    );
                    this.bgContext.scale(
                        resolutionMultiplier,
                        resolutionMultiplier
                    );
                    this.pickContext.scale(
                        resolutionMultiplier,
                        resolutionMultiplier
                    );
                    this._initMouseEvents();
                    this._initTouchEvents();
                }

                _initActors(actors, decorationRenderings, decorationMetadata) {
                    for (let i = 0; i < decorationMetadata.length; i++) {
                        const metadata = decorationMetadata[i];
                        let MetadataClass = null;
                        switch (metadata.type) {
                            case Types.ActorOrientation:
                                MetadataClass = ActorOrientationMetadata;
                                break;
                            case Types.Circle:
                                MetadataClass = CircleMetadata;
                                break;
                            case Types.Polygon:
                                MetadataClass = PolygonMetadata;
                                break;
                            case Types.Doughnut:
                                MetadataClass = DoughnutMetadata;
                                break;
                            case Types.Line:
                                MetadataClass = LineMetadata;
                                break;
                            case Types.Pie:
                                MetadataClass = PieMetadata;
                                break;
                            case Types.Rectangle:
                                MetadataClass = RectangleMetadata;
                                break;
                            case Types.ProgressBar:
                                MetadataClass = ProgressBarMetadata;
                                break;
                            case Types.BackgroundIcon:
                                MetadataClass = IconMetadata;
                                break;
                            case Types.Icon:
                                MetadataClass = IconMetadata;
                                break;
                            case Types.IconOverhead:
                                MetadataClass = IconOverheadMetadata;
                                break;
                            case Types.ProgressBarOverhead:
                                MetadataClass = OverheadProgressBarMetadata;
                                break;
                            case Types.MovingPlatform:
                                MetadataClass = MovingPlatformMetadata;
                                break;
                            case Types.Text:
                                MetadataClass = TextMetadata;
                                break;
                            case Types.TextOverhead:
                                MetadataClass = TextOverheadMetadata;
                                break;
                            case Types.Arena:
                                MetadataClass = ArenaMetadata;
                                break;
                            default:
                                throw (
                                    "Unknown decoration type " + metadata.type
                                );
                        }
                        this.decorationMetadata.set(
                            metadata.signature,
                            new MetadataClass(metadata)
                        );
                    }
                    for (let i = 0; i < actors.length; i++) {
                        const actor = actors[i];
                        let ActorClass;
                        let actorSize = 0;
                        let mapToFill;
                        switch (actor.type) {
                            case Types.Player:
                                ActorClass = PlayerIconDrawable;
                                actorSize = 22;
                                mapToFill = this.playerData;
                                break;
                            case Types.Target:
                                ActorClass = NPCIconDrawable;
                                actorSize = 30;
                                mapToFill = this.targetData;
                                break;
                            case Types.TargetPlayer:
                                ActorClass = EnemyPlayerDrawable;
                                actorSize = 22;
                                mapToFill = this.targetPlayerData;
                                break;
                            case Types.Mob:
                                ActorClass = NPCIconDrawable;
                                actorSize = 25;
                                mapToFill = this.trashMobData;
                                break;
                            case Types.Friendly:
                                ActorClass = NPCIconDrawable;
                                actorSize = 22;
                                mapToFill = this.friendlyMobData;
                                break;
                            case Types.FriendlyPlayer:
                                ActorClass = FriendlyPlayerDrawable;
                                actorSize = 22;
                                mapToFill = this.friendlyPlayerData;
                                break;
                            default:
                                throw "Unknown decoration type " + actor.type;
                        }
                        const renderable = new ActorClass(actor, actorSize);
                        mapToFill.add(renderable);
                        if (renderable.parentID >= 0) {
                            let array =
                                this.agentDataPerParentID.get(
                                    renderable.parentID
                                ) ?? [];
                            array.push(renderable);
                            this.agentDataPerParentID.set(
                                renderable.parentID,
                                array
                            );
                        }
                    }
                    for (let i = 0; i < decorationRenderings.length; i++) {
                        const decorationRendering = {};
                        decorationRendering._metadataContainer =
                            this.decorationMetadata;
                        Object.assign(
                            decorationRendering,
                            decorationRenderings[i]
                        );
                        if (!decorationRendering.isMechanicOrSkill) {
                            switch (decorationRendering.type) {
                                case Types.ActorOrientation:
                                    let orientationID =
                                        decorationRendering.connectedTo
                                            .masterID;
                                    var orientationDrawable =
                                        new ActorOrientationDrawable(
                                            decorationRendering
                                        );
                                    if (
                                        this.agentDataPerParentID.has(
                                            orientationID
                                        )
                                    ) {
                                        let halfTime =
                                            (orientationDrawable.start +
                                                orientationDrawable.end) /
                                            2;
                                        let agents =
                                            this.agentDataPerParentID.get(
                                                orientationID
                                            );
                                        for (
                                            let i = 0;
                                            i < agents.length;
                                            i++
                                        ) {
                                            let agent = agents[i];
                                            if (
                                                agent.start <= halfTime &&
                                                agent.end >= halfTime
                                            ) {
                                                this.actorOrientationData.set(
                                                    agents[i].id,
                                                    orientationDrawable
                                                );
                                                break;
                                            }
                                        }
                                    } else {
                                        this.actorOrientationData.set(
                                            orientationID,
                                            orientationDrawable
                                        );
                                    }
                                    break;
                                case Types.MovingPlatform:
                                    this.backgroundActorData.push(
                                        new MovingPlatformDrawable(
                                            decorationRendering
                                        )
                                    );
                                    break;
                                case Types.BackgroundIcon:
                                    this.backgroundActorData.push(
                                        new BackgroundIconMechanicDrawable(
                                            decorationRendering
                                        )
                                    );
                                    break;
                                case Types.Arena:
                                    this.backgroundImages.add(
                                        new ArenaDrawable(decorationRendering)
                                    );
                                    break;
                                default:
                                    throw (
                                        "Unknown decoration type " +
                                        decorationRendering.type
                                    );
                            }
                        } else {
                            let DecorationClass;
                            switch (decorationRendering.type) {
                                case Types.Text:
                                    if (
                                        decorationRendering.connectedTo
                                            .isScreenSpace
                                    ) {
                                        this.screenSpaceActorData.add(
                                            new TextDrawable(
                                                decorationRendering
                                            )
                                        );
                                        continue;
                                    }
                                    DecorationClass = TextDrawable;
                                    break;
                                case Types.TextOverhead:
                                    this.overheadActorData.add(
                                        new TextOverheadDrawable(
                                            decorationRendering
                                        )
                                    );
                                    continue;
                                case Types.Circle:
                                    DecorationClass = CircleMechanicDrawable;
                                    break;
                                case Types.Polygon:
                                    DecorationClass = PolygonMechanicDrawable;
                                    break;
                                case Types.Rectangle:
                                    DecorationClass = RectangleMechanicDrawable;
                                    break;
                                case Types.ProgressBar:
                                    DecorationClass =
                                        ProgressBarMechanicDrawable;
                                    break;
                                case Types.Doughnut:
                                    DecorationClass = DoughnutMechanicDrawable;
                                    break;
                                case Types.Pie:
                                    DecorationClass = PieMechanicDrawable;
                                    break;
                                case Types.Line:
                                    DecorationClass = LineMechanicDrawable;
                                    break;
                                case Types.Icon:
                                    DecorationClass = IconMechanicDrawable;
                                    break;
                                case Types.IconOverhead:
                                    this.overheadActorData.add(
                                        new IconOverheadMechanicDrawable(
                                            decorationRendering
                                        )
                                    );
                                    continue;
                                case Types.ProgressBarOverhead:
                                    this.overheadActorData.add(
                                        new OverheadProgressBarMechanicDrawable(
                                            decorationRendering
                                        )
                                    );
                                    continue;
                                case Types.SquadMarker:
                                    this.squadMarkerData.add(
                                        new IconMechanicDrawable(
                                            decorationRendering
                                        )
                                    );
                                    continue;
                                case Types.SquadMarkerOverhead:
                                    this.overheadSquadMarkerData.add(
                                        new IconOverheadMechanicDrawable(
                                            decorationRendering
                                        )
                                    );
                                    continue;
                                default:
                                    throw (
                                        "Unknown decoration type " +
                                        decorationRendering.type
                                    );
                            }
                            const decoration = new DecorationClass(
                                decorationRendering
                            );
                            if (decorationRendering.skillMode) {
                                this.skillMechanicActorData.add(decoration);
                            } else {
                                this.mechanicActorData.add(decoration);
                            }
                        }
                    }
                }

                updateRange(phase) {
                    let min = Math.max(this.times[0], phase.start * 1000);
                    let max = Math.min(
                        this.times[this.times.length - 1],
                        phase.end * 1000
                    );
                    this.reactiveDataStatus.range.min = min;
                    this.reactiveDataStatus.range.max = max;
                }

                updateTime(value) {
                    this.reactiveDataStatus.time = parseInt(value);
                    if (this.animation === null) {
                        animateCanvas(noUpdateTime);
                    }
                }

                updateTextInput() {
                    this.timeSliderDisplay.value = (
                        (this.reactiveDataStatus.time -
                            this.reactiveDataStatus.range.min) /
                        1000.0
                    ).toFixed(3);
                }

                updateInputTime(value) {
                    try {
                        const cleanedString = value.replace(",", ".");
                        const parsedTime = parseFloat(cleanedString);
                        if (isNaN(parsedTime) || !isFinite(parsedTime)) {
                            return;
                        }
                        const ms = Math.round(parsedTime * 1000.0);
                        const min = this.reactiveDataStatus.range.min;
                        const max = this.reactiveDataStatus.range.max;
                        this.reactiveDataStatus.time = Math.min(
                            Math.max(ms, min),
                            max
                        );
                        animateCanvas(updateText);
                    } catch (error) {
                        console.error(error);
                    }
                }

                toggleAnimate() {
                    if (!this.startAnimate(true)) {
                        this.stopAnimate(true);
                    }
                }

                startAnimate(updateReactiveStatus) {
                    if (this.animation === null && this.times.length > 0) {
                        const max = this.reactiveDataStatus.range.max;
                        const min = this.reactiveDataStatus.range.min;
                        if (
                            this.reactiveDataStatus.time >= max &&
                            !this.backwards
                        ) {
                            this.reactiveDataStatus.time = min;
                        }
                        this.prevTime = new Date().getTime();
                        this.animation = requestAnimationFrame(animateCanvas);
                        if (updateReactiveStatus) {
                            this.reactiveDataStatus.animated = true;
                        }
                        return true;
                    }
                    return false;
                }

                stopAnimate(updateReactiveStatus) {
                    if (this.animation !== null) {
                        window.cancelAnimationFrame(this.animation);
                        this.animation = null;
                        if (updateReactiveStatus) {
                            this.reactiveDataStatus.animated = false;
                        }
                        return true;
                    }
                    return false;
                }

                restartAnimate() {
                    this.reactiveDataStatus.time =
                        this.reactiveDataStatus.range.min;
                    if (this.animation === null) {
                        animateCanvas(noUpdateTime);
                    }
                }

                selectActor(actorId, keepIfEqual = false) {
                    if (DEBUG) {
                        const inLogActor =
                            logData.players.filter(
                                (x) => x.uniqueID === actorId
                            )[0] ||
                            logData.targets.filter(
                                (x) => x.uniqueID === actorId
                            )[0];
                        if (inLogActor) {
                            alert(actorId + " " + inLogActor.name);
                        } else {
                            alert(actorId);
                        }
                    }
                    let actor = this.getActorData(actorId);
                    if (
                        !actor ||
                        (!keepIfEqual && this.selectedActor === actor)
                    ) {
                        this.selectedActor = null;
                        this.reactiveDataStatus.selectedActorID = null;
                    } else {
                        this.selectedActor = actor;
                        this.reactiveDataStatus.selectedActorID = actorId;
                    }
                    if (this.animation === null) {
                        animateCanvas(noUpdateTime);
                    }
                }

                _reselectIfEnglobed() {
                    if (
                        this.selectedActor &&
                        this.selectedActor.parentID >= 0
                    ) {
                        const perParentArray = this.agentDataPerParentID.get(
                            this.selectedActor.parentID
                        );
                        if (perParentArray) {
                            let actor = perParentArray.filter(
                                (x) => x.getPosition() != null
                            )[0];
                            if (!actor) {
                                const time = this.reactiveDataStatus.time;
                                // check for first in interval
                                let candidates = perParentArray.filter(
                                    (x) => x.start <= time && x.end >= time
                                );
                                if (candidates.length) {
                                    actor = candidates[0];
                                } else {
                                    // first
                                    candidates = perParentArray.filter(
                                        (x) => x.start >= time
                                    );
                                    if (candidates.length) {
                                        actor = candidates[0];
                                    } else {
                                        // last
                                        candidates = perParentArray.filter(
                                            (x) => x.end <= time
                                        );
                                        if (candidates.length) {
                                            actor =
                                                candidates[
                                                    candidates.length - 1
                                                ];
                                        }
                                    }
                                }
                            }
                            this.selectedActor = actor || this.selectedActor;
                            this.reactiveDataStatus.selectedActorID =
                                this.selectedActor.id;
                        }
                    }
                }

                getSelectableActorData(actorId) {
                    return (
                        animator.targetData.get(actorId) ||
                        animator.playerData.get(actorId) ||
                        animator.friendlyMobData.get(actorId) ||
                        animator.friendlyPlayerData.get(actorId) ||
                        animator.targetPlayerData.get(actorId)
                    );
                }

                getActorData(actorId) {
                    return (
                        this.getSelectableActorData(actorId) ||
                        animator.trashMobData.get(actorId)
                    );
                }

                getActiveActorMarkers(actorID) {
                    let res = [];
                    const _this = this;
                    this.overheadSquadMarkerData.forEach((marker) => {
                        if (
                            marker.canDraw() &&
                            marker.getPosition() &&
                            marker.master === _this.getActorData(actorID)
                        ) {
                            res.push(marker);
                        }
                    });
                    return res;
                }

                toggleFollowSelected() {
                    this.displaySettings.followSelected =
                        !this.displaySettings.followSelected;
                    animateCanvas(noUpdateTime);
                }

                toggleHighlightSelectedGroup() {
                    this.displaySettings.highlightSelectedGroup =
                        !this.displaySettings.highlightSelectedGroup;
                    animateCanvas(noUpdateTime);
                }

                toggleDisplayAllMinions() {
                    this.displaySettings.displayAllMinions =
                        !this.displaySettings.displayAllMinions;
                    animateCanvas(noUpdateTime);
                }

                toggleDisplaySelectedMinions() {
                    this.displaySettings.displaySelectedMinions =
                        !this.displaySettings.displaySelectedMinions;
                    animateCanvas(noUpdateTime);
                }

                toggleUseActorHitboxWidth() {
                    this.displaySettings.useActorHitboxWidth =
                        !this.displaySettings.useActorHitboxWidth;
                    animateCanvas(noUpdateTime);
                }

                toggleTrashMobs() {
                    this.displaySettings.displayTrashMobs =
                        !this.displaySettings.displayTrashMobs;
                    animateCanvas(noUpdateTime);
                }

                toggleMechanics() {
                    this.displaySettings.displayMechanics =
                        !this.displaySettings.displayMechanics;
                    animateCanvas(noUpdateTime);
                }

                toggleSquadMarkers() {
                    this.displaySettings.displaySquadMarkers =
                        !this.displaySettings.displaySquadMarkers;
                    animateCanvas(noUpdateTime);
                }

                toggleSkills() {
                    this.displaySettings.displaySkillMechanics =
                        !this.displaySettings.displaySkillMechanics;
                    animateCanvas(noUpdateTime);
                }

                toggleSkillCategoryMask(mask) {
                    if ((this.displaySettings.skillMechanicsMask & mask) > 0) {
                        this.displaySettings.skillMechanicsMask &= ~mask;
                    } else {
                        this.displaySettings.skillMechanicsMask |= mask;
                    }
                    animateCanvas(noUpdateTime);
                }

                toggleConeDisplay() {
                    this.coneControl.enabled = !this.coneControl.enabled;
                    animateCanvas(noUpdateTime);
                }

                setConeRadius(value) {
                    this.coneControl.radius = value;
                    animateCanvas(noUpdateTime);
                }

                setConeAngle(value) {
                    this.coneControl.openingAngle = value;
                    animateCanvas(noUpdateTime);
                }

                resetViewpoint() {
                    var canvas = this.mainCanvas;
                    var ctx = this.mainContext;
                    var bgCtx = this.bgContext;

                    this.lastX = canvas.width / 2;
                    this.lastY = canvas.height / 2;
                    this.mouseDown = null;
                    this.dragged = false;
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.scale(resolutionMultiplier, resolutionMultiplier);
                    bgCtx.setTransform(1, 0, 0, 1, 0, 0);
                    bgCtx.scale(resolutionMultiplier, resolutionMultiplier);
                    this.needBGUpdate = true;
                    if (this.animation === null) {
                        animateCanvas(noUpdateTime);
                    }
                }

                _initMouseEvents() {
                    var _this = this;
                    var canvas = this.mainCanvas;
                    var ctx = this.mainContext;
                    var bgCtx = this.bgContext;
                    var pickCtx = this.pickContext;

                    canvas.addEventListener(
                        "mousedown",
                        function (evt) {
                            evt.preventDefault();
                            _this.lastX =
                                evt.offsetX || evt.pageX - canvas.offsetLeft;
                            _this.lastY =
                                evt.offsetY || evt.pageY - canvas.offsetTop;
                            _this.mouseDown = {
                                pt: ctx.transformedPoint(
                                    _this.lastX,
                                    _this.lastY
                                ),
                                time: Date.now(),
                            };
                            _this.dragged = false;
                        },
                        false
                    );

                    canvas.addEventListener(
                        "mousemove",
                        function (evt) {
                            evt.preventDefault();
                            _this.lastX =
                                evt.offsetX || evt.pageX - canvas.offsetLeft;
                            _this.lastY =
                                evt.offsetY || evt.pageY - canvas.offsetTop;
                            _this.dragged = true;
                            if (_this.mouseDown) {
                                var pt = ctx.transformedPoint(
                                    _this.lastX,
                                    _this.lastY
                                );
                                var downPt = _this.mouseDown.pt;
                                ctx.translate(pt.x - downPt.x, pt.y - downPt.y);
                                bgCtx.translate(
                                    pt.x - downPt.x,
                                    pt.y - downPt.y
                                );
                                _this.needBGUpdate = true;
                                if (_this.animation === null) {
                                    animateCanvas(noUpdateTime);
                                }
                            }
                        },
                        false
                    );

                    document.body.addEventListener(
                        "mouseup",
                        function (evt) {
                            if (
                                _this.mouseDown &&
                                Date.now() - _this.mouseDown.time < 150
                            ) {
                                _this._drawPickCanvas();
                                var downPt = {
                                    x: Math.round(
                                        _this.lastX * resolutionMultiplier
                                    ),
                                    y: Math.round(
                                        _this.lastY * resolutionMultiplier
                                    ),
                                };
                                var pickedColor = pickCtx.getImageData(
                                    downPt.x,
                                    downPt.y,
                                    1,
                                    1
                                ).data;
                                uint32ToUint8[0] = pickedColor[0];
                                uint32ToUint8[1] = pickedColor[1];
                                uint32ToUint8[2] = pickedColor[2];
                                uint32ToUint8[3] = 0;
                                var actorID = uint32[0];
                                _this.selectActor(actorID, true);
                            }
                            _this.mouseDown = null;
                        },
                        false
                    );

                    var zoom = function (evt) {
                        evt.preventDefault();
                        var delta = evt.wheelDelta
                            ? evt.wheelDelta / 40
                            : evt.detail
                            ? -evt.detail
                            : 0;
                        if (delta) {
                            var pt = ctx.transformedPoint(
                                _this.lastX,
                                _this.lastY
                            );
                            ctx.translate(pt.x, pt.y);
                            bgCtx.translate(pt.x, pt.y);
                            var factor = Math.pow(1.1, delta);
                            ctx.scale(factor, factor);
                            if (50 / (InchToPixel * _this.scale) < 10) {
                                ctx.scale(1.0 / factor, 1.0 / factor);
                                factor = 1.0;
                            }
                            ctx.translate(-pt.x, -pt.y);
                            bgCtx.scale(factor, factor);
                            bgCtx.translate(-pt.x, -pt.y);
                            _this.needBGUpdate = true;
                            if (_this.animation === null) {
                                animateCanvas(noUpdateTime);
                            }
                        }
                    };

                    canvas.addEventListener("DOMMouseScroll", zoom, false);
                    canvas.addEventListener("mousewheel", zoom, false);
                }

                _initTouchEvents() {
                    // todo
                }

                setSpeed(value) {
                    this.speed = value;
                }

                getSpeed() {
                    if (this.backwards) {
                        return -this.speed;
                    }
                    return this.speed;
                }

                toggleBackwards() {
                    this.backwards = !this.backwards;
                    return this.backwards;
                }

                toggleRange(index) {
                    this.rangeControl[index].enabled =
                        !this.rangeControl[index].enabled;
                    animateCanvas(noUpdateTime);
                }

                setRangeRadius(index, value) {
                    this.rangeControl[index].radius = value;
                    animateCanvas(noUpdateTime);
                }

                // https://codepen.io/anon/pen/KrExzG
                _trackTransforms(ctx) {
                    var svg = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "svg"
                    );
                    var xform = svg.createSVGMatrix();
                    ctx.getTransform = function () {
                        return xform;
                    };

                    var drawImage = ctx.drawImage;
                    ctx.drawImage = function () {
                        const image = arguments[0];
                        if (
                            !image ||
                            !image.complete ||
                            image.naturalWidth === 0
                        ) {
                            return;
                        }
                        return drawImage.call(ctx, ...arguments);
                    };

                    var savedTransforms = [];
                    var save = ctx.save;
                    ctx.save = function () {
                        savedTransforms.push(xform.translate(0, 0));
                        return save.call(ctx);
                    };

                    var restore = ctx.restore;
                    ctx.restore = function () {
                        xform = savedTransforms.pop();
                        return restore.call(ctx);
                    };

                    var scale = ctx.scale;
                    var _this = this;
                    ctx.scale = function (sx, sy) {
                        xform = xform.scale(sx, sy);
                        var xAxis = Math.sqrt(
                            xform.a * xform.a + xform.b * xform.b
                        );
                        var yAxis = Math.sqrt(
                            xform.c * xform.c + xform.d * xform.d
                        );
                        _this.scale =
                            Math.max(xAxis, yAxis) / resolutionMultiplier;
                        return scale.call(ctx, sx, sy);
                    };

                    var rotate = ctx.rotate;
                    ctx.rotate = function (radians) {
                        xform = xform.rotate((radians * 180) / Math.PI);
                        return rotate.call(ctx, radians);
                    };

                    var translate = ctx.translate;
                    ctx.translate = function (dx, dy) {
                        xform = xform.translate(dx, dy);
                        return translate.call(ctx, dx, dy);
                    };

                    var transform = ctx.transform;
                    ctx.transform = function (a, b, c, d, e, f) {
                        var m2 = svg.createSVGMatrix();
                        m2.a = a;
                        m2.b = b;
                        m2.c = c;
                        m2.d = d;
                        m2.e = e;
                        m2.f = f;
                        xform = xform.multiply(m2);
                        return transform.call(ctx, a, b, c, d, e, f);
                    };

                    var setTransform = ctx.setTransform;
                    ctx.setTransform = function (a, b, c, d, e, f) {
                        xform.a = a;
                        xform.b = b;
                        xform.c = c;
                        xform.d = d;
                        xform.e = e;
                        xform.f = f;
                        return setTransform.call(ctx, a, b, c, d, e, f);
                    };

                    var pt = svg.createSVGPoint();
                    ctx.transformedPoint = function (x, y) {
                        pt.x = x * resolutionMultiplier;
                        pt.y = y * resolutionMultiplier;
                        return pt.matrixTransform(xform.inverse());
                    };
                }
                // animation
                _drawBGCanvas() {
                    const _this = this;
                    if (!this.needBGUpdate) {
                        this.backgroundImages.forEach((x) => {
                            if (x.needsUpdate()) {
                                _this.needBGUpdate = true;
                            }
                        });
                    }
                    if (this.needBGUpdate || this._mustMoveToSelected()) {
                        this.needBGUpdate = false;
                        var ctx = this.bgContext;
                        var canvas = this.bgCanvas;
                        var p1 = ctx.transformedPoint(0, 0);
                        var p2 = ctx.transformedPoint(
                            canvas.width,
                            canvas.height
                        );
                        ctx.clearRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);

                        ctx.save();
                        {
                            ctx.setTransform(1, 0, 0, 1, 0, 0);
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                        }
                        ctx.restore();

                        //ctx.save();
                        {
                            this._moveToSelected(ctx);
                            this.backgroundImages.draw(standardDraw);
                            //ctx.globalCompositeOperation = "color-burn";
                            ctx.save();
                            {
                                ctx.setTransform(1, 0, 0, 1, 0, 0);
                                // draw scale
                                ctx.lineWidth = 3 * resolutionMultiplier;
                                ctx.strokeStyle = "#CC2200";
                                var pos = resolutionMultiplier * 70;
                                var width = resolutionMultiplier * 50;
                                var height = resolutionMultiplier * 6;
                                // main line
                                ctx.beginPath();
                                ctx.moveTo(pos, pos);
                                ctx.lineTo(pos + width, pos);
                                ctx.stroke();
                                ctx.lineWidth = 2 * resolutionMultiplier;
                                // right border
                                ctx.beginPath();
                                ctx.moveTo(
                                    pos - resolutionMultiplier,
                                    pos + height
                                );
                                ctx.lineTo(
                                    pos - resolutionMultiplier,
                                    pos - height
                                );
                                ctx.stroke();
                                // left border
                                ctx.beginPath();
                                ctx.moveTo(
                                    pos + width + resolutionMultiplier,
                                    pos + height
                                );
                                ctx.lineTo(
                                    pos + width + resolutionMultiplier,
                                    pos - height
                                );
                                ctx.stroke();
                                // text
                                var fontSize = 13 * resolutionMultiplier;
                                ctx.font =
                                    "bold " + fontSize + "px Comic Sans MS";
                                ctx.fillStyle = "#CC2200";
                                ctx.textAlign = "center";
                                ctx.fillText(
                                    (50 / (InchToPixel * this.scale)).toFixed(
                                        1
                                    ) + " units",
                                    resolutionMultiplier * 95,
                                    resolutionMultiplier * 60
                                );
                            }
                            ctx.restore();
                        }
                        //ctx.restore();
                        //ctx.globalCompositeOperation = 'normal';
                    }
                }

                _drawActorOrientation(key) {
                    if (this.actorOrientationData.has(key)) {
                        this.actorOrientationData.get(key).draw();
                    }
                }

                _drawPickCanvas() {
                    var _this = this;
                    var mainCtx = this.mainContext;
                    var mainTransform = mainCtx.getTransform();
                    var ctx = this.pickContext;
                    var canvas = this.pickCanvas;
                    var p1 = ctx.transformedPoint(0, 0);
                    var p2 = ctx.transformedPoint(canvas.width, canvas.height);
                    ctx.clearRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
                    ctx.save();
                    {
                        ctx.setTransform(1, 0, 0, 1, 0, 0);
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                    }
                    ctx.restore();

                    //ctx.save();
                    {
                        ctx.setTransform(
                            mainTransform.a,
                            mainTransform.b,
                            mainTransform.c,
                            mainTransform.d,
                            mainTransform.e,
                            mainTransform.f
                        );

                        if (!this.displaySettings.useActorHitboxWidth) {
                            this.friendlyMobData.draw(selectablePickingDraw);
                            this.friendlyPlayerData.draw(selectablePickingDraw);
                            this.playerData.draw(selectablePickingDraw);
                        }

                        if (this.displaySettings.displayTrashMobs) {
                            this.trashMobData.draw(selectablePickingDraw);
                        }

                        this.targetData.draw(selectablePickingDraw);
                        this.targetPlayerData.draw(selectablePickingDraw);
                        if (this.displaySettings.useActorHitboxWidth) {
                            this.friendlyMobData.draw(selectablePickingDraw);
                            this.friendlyPlayerData.draw(selectablePickingDraw);
                            this.playerData.draw(selectablePickingDraw);
                        }
                        if (this.selectedActor !== null) {
                            this.selectedActor.drawPicking();
                        }
                    }

                    //ctx.restore();
                }

                _drawMainCanvas() {
                    var _this = this;
                    var ctx = this.mainContext;
                    var canvas = this.mainCanvas;
                    var p1 = ctx.transformedPoint(0, 0);
                    var p2 = ctx.transformedPoint(canvas.width, canvas.height);
                    ctx.clearRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
                    ctx.save();
                    {
                        ctx.setTransform(1, 0, 0, 1, 0, 0);
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                    }
                    ctx.restore();
                    //ctx.save();
                    {
                        this._moveToSelected(ctx);
                        // Background items commonly overlap so they need to be drawn in the correct order by height
                        // This is sorted in reverse order because the z axis is inverted
                        animator.backgroundActorData.sort(
                            (x, y) => y.getHeight() - x.getHeight()
                        );
                        for (
                            let i = 0;
                            i < animator.backgroundActorData.length;
                            i++
                        ) {
                            animator.backgroundActorData[i].draw();
                        }
                        if (this.displaySettings.displayMechanics) {
                            this.mechanicActorData.draw(standardDraw);
                        }

                        if (this.displaySettings.displaySkillMechanics) {
                            this.skillMechanicActorData.draw(standardDraw);
                        }

                        if (!this.displaySettings.useActorHitboxWidth) {
                            this.friendlyMobData.draw(selectableDraw);
                            this.friendlyPlayerData.draw(selectableDraw);
                            this.playerData.draw(selectableDraw);
                        }

                        if (this.displaySettings.displayTrashMobs) {
                            this.trashMobData.draw(selectableDraw);
                        }

                        this.targetData.draw(selectableDraw);
                        this.targetPlayerData.draw(selectableDraw);
                        if (this.displaySettings.useActorHitboxWidth) {
                            this.friendlyMobData.draw(selectableDraw);
                            this.friendlyPlayerData.draw(selectableDraw);
                            this.playerData.draw(selectableDraw);
                        }
                        if (this.selectedActor !== null) {
                            this.selectedActor.draw();
                            this._drawActorOrientation(this.selectedActor.id);
                        }
                        if (this.displaySettings.displayMechanics) {
                            this.overheadActorData.draw(standardDraw);
                        }
                        if (this.displaySettings.displaySquadMarkers) {
                            this.squadMarkerData.draw(standardDraw);
                            this.overheadSquadMarkerData.draw(standardDraw);
                        }
                        ctx.save();
                        {
                            ctx.setTransform(1, 0, 0, 1, 0, 0);
                            // Screen space actors
                            this.screenSpaceActorData.draw(standardDraw);
                        }
                        ctx.restore();
                    }
                    //ctx.restore();
                }

                _mustMoveToSelected() {
                    return (
                        this.displaySettings.followSelected &&
                        this.selectedActor !== null &&
                        this.selectedActor.canDraw()
                    );
                }

                _moveToSelected(ctx) {
                    if (this._mustMoveToSelected()) {
                        const pos = this.selectedActor.getPosition();
                        if (pos !== null) {
                            ctx.setTransform(1, 0, 0, 1, 0, 0);
                            ctx.scale(
                                this.scale * resolutionMultiplier,
                                this.scale * resolutionMultiplier
                            );
                            const translateScale =
                                0.5 / resolutionMultiplier / this.scale;
                            ctx.translate(
                                -pos.x + this.mainCanvas.width * translateScale,
                                -pos.y + this.mainCanvas.height * translateScale
                            );
                        }
                    }
                }
                draw() {
                    if (!this.mainCanvas) {
                        return;
                    }
                    this._reselectIfEnglobed();
                    //
                    //this._drawPickCanvas();
                    this._drawBGCanvas();
                    this._drawMainCanvas();
                    if (
                        overheadAnimationFrame === maxOverheadAnimationFrame ||
                        overheadAnimationFrame === 0
                    ) {
                        overheadAnimationIncrement *= -1;
                    }
                    overheadAnimationFrame += overheadAnimationIncrement;
                }
            }

            function animateCanvas(noRequest) {
                if (animator == null) {
                    return;
                }
                let lastTime = animator.reactiveDataStatus.range.max;
                let firstTime = animator.reactiveDataStatus.range.min;
                if (noRequest > noUpdateTime && animator.animation !== null) {
                    let curTime = new Date().getTime();
                    let timeOffset = curTime - animator.prevTime;
                    animator.prevTime = curTime;
                    animator.reactiveDataStatus.time = Math.round(
                        Math.max(
                            Math.min(
                                animator.reactiveDataStatus.time +
                                    animator.getSpeed() * timeOffset,
                                lastTime
                            ),
                            0
                        )
                    );
                }
                if (
                    (animator.reactiveDataStatus.time === lastTime &&
                        !animator.backwards) ||
                    (animator.reactiveDataStatus.time === firstTime &&
                        animator.backwards)
                ) {
                    animator.stopAnimate(true);
                }
                animator.timeSlider.value = (
                    animator.reactiveDataStatus.time -
                    animator.reactiveDataStatus.range.min
                ).toString();
                if (noRequest > updateText) {
                    animator.updateTextInput();
                }
                animator.draw();
                if (noRequest > noUpdateTime && animator.animation !== null) {
                    animator.animation = requestAnimationFrame(animateCanvas);
                }
            }
            /*
function initCombatReplay(actors, options) {
    // manipulation events
    canvas.addEventListener('touchstart', function (evt) {
        var touch = evt.changedTouches[0];
        if (!touch) {
            return;
        }
        lastX = (touch.pageX - canvas.offsetLeft);
        lastY = (touch.pageY - canvas.offsetTop);
        mouseDown = ctx.transformedPoint(lastX, lastY);
        dragged = false;
        return evt.preventDefault() && false;
    }, false);

    canvas.addEventListener('touchmove', function (evt) {
        var touch = evt.changedTouches[0];
        if (!touch) {
            return;
        }
        lastX = (touch.pageX - canvas.offsetLeft);
        lastY = (touch.pageY - canvas.offsetTop);
        dragged = true;
        if (mouseDown) {
            var pt = ctx.transformedPoint(lastX, lastY);
            ctx.translate(pt.x - mouseDown.x, pt.y - mouseDown.y);
            animateCanvas(noUpdateTime);
        }
        return evt.preventDefault() && false;
    }, false);
    document.body.addEventListener('touchend', function (evt) {
        mouseDown = null;
    }, false);
}
*/
            /*jshint esversion: 6 */
            /* jshint node: true */
            /*jslint browser: true */
            /*global animator, animateCanvas, noUpdateTime, deadIcon, dcIcon, downAllyIcon, downEnemyIcon*/
            ("use strict");
            //// ACTORS

            function IsPresentInArray(array, time) {
                for (let i = 0; i < array.length; i += 2) {
                    if (array[i] <= time && array[i + 1] >= time) {
                        return true;
                    }
                }
                return false;
            }

            class IconDrawable {
                constructor(params, pixelSize) {
                    this.positions = params.positions;
                    this.angles = params.angles;
                    this.start = params.start;
                    this.end = params.end;
                    this.img = new Image();
                    this.img.src = params.img;
                    this.img.onload = function () {
                        animateCanvas(noUpdateTime);
                    };
                    this.pixelSize = pixelSize;
                    this.group = null;
                    this.dead =
                        typeof params.dead !== "undefined" ? params.dead : null;
                    this.down =
                        typeof params.down !== "undefined" ? params.down : null;
                    this.dc =
                        typeof params.dc !== "undefined" ? params.dc : null;
                    this.hide =
                        typeof params.hide !== "undefined" ? params.hide : null;
                    this.breakbarActive =
                        typeof params.breakbarActive !== "undefined"
                            ? params.breakbarActive
                            : null;
                    this.hitboxWidth = InchToPixel * params.hitboxWidth;
                    //
                    this.id = params.id;
                    this.parentID = params.parentID;
                    uint32[0] = params.id;
                    this.pickingColor =
                        params.img && params.img.length > 0
                            ? `rgba(${uint32ToUint8[0]}, ${uint32ToUint8[1]}, ${uint32ToUint8[2]}, 1)`
                            : null;
                }

                isSelected() {
                    return animator.selectedActor === this;
                }

                inSelectedGroup() {
                    return false;
                }

                died() {
                    if (this.dead === null || this.dead.length === 0) {
                        return false;
                    }
                    return IsPresentInArray(
                        this.dead,
                        animator.reactiveDataStatus.time
                    );
                }

                downed() {
                    if (this.down === null || this.down.length === 0) {
                        return false;
                    }
                    return IsPresentInArray(
                        this.down,
                        animator.reactiveDataStatus.time
                    );
                }

                disconnected() {
                    return this._disconnected(animator.reactiveDataStatus.time);
                }

                _disconnected(time) {
                    if (this.dc === null || this.dc.length === 0) {
                        return false;
                    }
                    return IsPresentInArray(this.dc, time);
                }

                isBreakbarActive() {
                    if (
                        this.breakbarActive === null ||
                        this.breakbarActive.length === 0
                    ) {
                        return false;
                    }
                    return IsPresentInArray(
                        this.breakbarActive,
                        animator.reactiveDataStatus.time
                    );
                }

                _isFriendly() {
                    return (
                        animator.playerData.has(this.id) ||
                        animator.friendlyMobData.has(this.id) ||
                        animator.friendlyPlayerData.has(this.id)
                    );
                }

                getIcon() {
                    if (this.died()) {
                        return deadIcon;
                    }
                    if (this.downed()) {
                        return this._isFriendly()
                            ? downAllyIcon
                            : downEnemyIcon;
                    }
                    if (this.disconnected()) {
                        return dcIcon;
                    }
                    return this.img;
                }

                getInterpolatedRotation(startIndex, currentIndex) {
                    const offsetedIndex = currentIndex - startIndex;
                    const initialAngle = this.angles[offsetedIndex];
                    const timeValue = animator.times[currentIndex];
                    var angle = 0;
                    var time = animator.reactiveDataStatus.time;
                    if (
                        time - timeValue > 0 &&
                        offsetedIndex < this.angles.length - 1
                    ) {
                        const nextTimeValue = animator.times[currentIndex + 1];
                        let nextAngle = this.angles[offsetedIndex + 1];
                        // Make sure the interpolation is only done on the shortest path to avoid big flips around PI or -PI radians
                        if (nextAngle - initialAngle < -180) {
                            nextAngle += 360.0;
                        } else if (nextAngle - initialAngle > 180) {
                            nextAngle -= 360.0;
                        }
                        angle =
                            initialAngle +
                            ((time - timeValue) / (nextTimeValue - timeValue)) *
                                (nextAngle - initialAngle);
                    } else {
                        angle = initialAngle;
                    }
                    return angle;
                }

                getInterpolatedPosition(startIndex, currentIndex) {
                    const offsetedIndex = currentIndex - startIndex;
                    const positionX = this.positions[2 * offsetedIndex];
                    const positionY = this.positions[2 * offsetedIndex + 1];
                    const timeValue = animator.times[currentIndex];
                    var pt = {
                        x: 0,
                        y: 0,
                    };
                    var time = animator.reactiveDataStatus.time;
                    if (
                        time - timeValue > 0 &&
                        offsetedIndex < 0.5 * this.positions.length - 1
                    ) {
                        const nextTimeValue = animator.times[currentIndex + 1];
                        const nextPositionX =
                            this.positions[2 * offsetedIndex + 2];
                        const nextPositionY =
                            this.positions[2 * offsetedIndex + 3];
                        pt.x =
                            positionX +
                            ((time - timeValue) / (nextTimeValue - timeValue)) *
                                (nextPositionX - positionX);
                        pt.y =
                            positionY +
                            ((time - timeValue) / (nextTimeValue - timeValue)) *
                                (nextPositionY - positionY);
                    } else {
                        pt.x = positionX;
                        pt.y = positionY;
                    }
                    pt.x =
                        Math.round(10 * pt.x * animator.scale) /
                        (10 * animator.scale);
                    pt.y =
                        Math.round(10 * pt.y * animator.scale) /
                        (10 * animator.scale);
                    return pt;
                }

                canDraw() {
                    if (
                        this.hide &&
                        this.hide.length > 0 &&
                        IsPresentInArray(
                            this.hide,
                            animator.reactiveDataStatus.time
                        )
                    ) {
                        return false;
                    }
                    return true;
                }

                getRotation() {
                    if (
                        this.angles === null ||
                        this.angles.length === 0 ||
                        this.disconnected()
                    ) {
                        return null;
                    }
                    var time = animator.reactiveDataStatus.time;
                    if (
                        this.start !== -1 &&
                        (this.start > time || this.end < time)
                    ) {
                        return null;
                    }
                    if (this.angles.length === 1) {
                        return this.angles[0];
                    }
                    const lastTime = animator.times[animator.times.length - 1];
                    const startIndex = Math.ceil(
                        ((animator.times.length - 1) *
                            Math.max(this.start, 0)) /
                            lastTime
                    );
                    const currentIndex = Math.floor(
                        ((animator.times.length - 1) * time) / lastTime
                    );
                    return this.getInterpolatedRotation(
                        startIndex,
                        Math.max(currentIndex, startIndex)
                    );
                }

                _getPosition(time) {
                    if (
                        this.positions === null ||
                        this.positions.length === 0 ||
                        this._disconnected(time)
                    ) {
                        return null;
                    }
                    if (
                        this.start !== -1 &&
                        (this.start > time || this.end < time)
                    ) {
                        return null;
                    }
                    if (this.positions.length === 2) {
                        return {
                            x: this.positions[0],
                            y: this.positions[1],
                        };
                    }
                    const lastTime = animator.times[animator.times.length - 1];
                    const startIndex = Math.ceil(
                        ((animator.times.length - 1) *
                            Math.max(this.start, 0)) /
                            lastTime
                    );
                    const currentIndex = Math.floor(
                        ((animator.times.length - 1) * time) / lastTime
                    );
                    return this.getInterpolatedPosition(
                        startIndex,
                        Math.max(currentIndex, startIndex)
                    );
                }

                getPosition(_time) {
                    return this._getPosition(animator.reactiveDataStatus.time);
                }

                getSize() {
                    if (
                        animator.displaySettings.useActorHitboxWidth &&
                        this.hitboxWidth > 0
                    ) {
                        return this.hitboxWidth;
                    } else {
                        return this.pixelSize / animator.scale;
                    }
                }

                draw() {
                    if (!this.canDraw() || this.pickingColor == null) {
                        return;
                    }
                    const pos = this.getPosition();
                    if (pos === null) {
                        return;
                    }
                    var ctx = animator.mainContext;
                    const fullSize = this.getSize();
                    const halfSize = fullSize / 2;
                    var isSelected = this.isSelected();
                    var inSelectedGroup = this.inSelectedGroup();
                    if (
                        animator.displaySettings.highlightSelectedGroup &&
                        !isSelected &&
                        inSelectedGroup
                    ) {
                        ctx.beginPath();
                        ctx.lineWidth = (2 / animator.scale).toString();
                        ctx.strokeStyle = "blue";
                        ctx.rect(
                            pos.x - halfSize,
                            pos.y - halfSize,
                            fullSize,
                            fullSize
                        );
                        ctx.stroke();
                    } else if (isSelected) {
                        ctx.beginPath();
                        ctx.lineWidth = (4 / animator.scale).toString();
                        ctx.strokeStyle = "green";
                        ctx.rect(
                            pos.x - halfSize,
                            pos.y - halfSize,
                            fullSize,
                            fullSize
                        );
                        ctx.stroke();
                        animator.rangeControl.forEach(function (element) {
                            if (!element.enabled) {
                                return;
                            }
                            ctx.beginPath();
                            ctx.lineWidth = (2 / animator.scale).toString();
                            ctx.strokeStyle = "green";
                            ctx.arc(
                                pos.x,
                                pos.y,
                                InchToPixel * element.radius,
                                0,
                                2 * Math.PI
                            );
                            ctx.stroke();
                        });
                    }
                    ctx.drawImage(
                        this.getIcon(),
                        pos.x - halfSize,
                        pos.y - halfSize,
                        fullSize,
                        fullSize
                    );
                }

                drawPicking() {
                    if (!this.canDraw() || !this.pickingColor) {
                        return;
                    }
                    const pos = this.getPosition();
                    if (pos === null) {
                        return;
                    }
                    var ctx = animator.pickContext;

                    ctx.save();
                    ctx.translate(pos.x, pos.y);
                    const fullSize = this.getSize();
                    const halfSize = fullSize / 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, halfSize, 0, 2 * Math.PI);
                    ctx.fillStyle = this.pickingColor;
                    ctx.fill();
                    ctx.restore();
                }
            }

            class PlayerIconDrawable extends IconDrawable {
                constructor(params, pixelSize) {
                    super(params, pixelSize);
                    this.group = params.group;
                    this.img.crossOrigin = "Anonymous";
                }

                inSelectedGroup() {
                    return (
                        animator.selectedActor !== null &&
                        animator.selectedActor.group === this.group
                    );
                }
            }

            class NonSquadIconDrawable extends IconDrawable {
                constructor(params, pixelSize) {
                    super(params, pixelSize);
                    this.masterID =
                        typeof params.masterID !== "undefined" &&
                        params.masterID >= 0
                            ? params.masterID
                            : -1;
                    this.master = null;
                }

                canDraw() {
                    if (!super.canDraw()) {
                        return false;
                    }
                    const perParentArray = animator.agentDataPerParentID.get(
                        this.masterID
                    );
                    if (perParentArray) {
                        this.master = perParentArray.filter(
                            (x) => x.getPosition() != null
                        )[0];
                    } else if (this.master === null) {
                        this.master = animator.getActorData(this.masterID);
                    }
                    if (
                        this.master &&
                        !animator.displaySettings.displayAllMinions
                    ) {
                        return (
                            (this.master.isSelected() || this.isSelected()) &&
                            animator.displaySettings.displaySelectedMinions
                        );
                    }
                    return true;
                }
            }

            class NPCIconDrawable extends NonSquadIconDrawable {
                constructor(params, pixelSize) {
                    super(params, pixelSize);
                }
            }

            let adjustedEnemyDeadIcon = null;
            let adjustedFriendlyDeadIcon = null;
            let adjustedFriendlyDownIcon = null;

            function adjustImageColor(image, colorAdjuster) {
                const imageWidth = image.width;
                const imageHeight = image.height;
                const offscreen = new OffscreenCanvas(imageWidth, imageHeight);
                const ctx = offscreen.getContext("2d");
                ctx.drawImage(image, 0, 0);
                const imageData = ctx.getImageData(
                    0,
                    0,
                    imageWidth,
                    imageHeight
                );
                for (let i = 0; i < imageData.data.length; i += 4) {
                    let color = colorAdjuster(
                        imageData.data[i + 0],
                        imageData.data[i + 1],
                        imageData.data[i + 2],
                        imageData.data[i + 3]
                    );
                    imageData.data[i + 0] = color.r;
                    imageData.data[i + 1] = color.g;
                    imageData.data[i + 2] = color.b;
                    imageData.data[i + 3] = color.a;
                }
                ctx.putImageData(imageData, 0, 0);
                offscreen.complete = true;
                offscreen.naturalWidth = imageWidth;
                offscreen.naturalHeight = imageHeight;
                return offscreen;
            }

            class NonSquadPlayerDrawable extends NonSquadIconDrawable {
                constructor(params, pixelSize) {
                    super(params, pixelSize);
                    this.img.crossOrigin = "Anonymous";
                    this.adjustedImg = null;
                    this.colorAdjuster = null;
                }

                _getDownIcon() {
                    return null;
                }

                _getDeadIcon() {
                    return null;
                }

                getIcon() {
                    if (this.died()) {
                        return this._getDeadIcon();
                    }
                    if (this.downed()) {
                        return this._getDownIcon();
                    }
                    if (this.disconnected()) {
                        return dcIcon;
                    }
                    if (!this.adjustedImg && this.img.complete) {
                        this.adjustedImg = adjustImageColor(
                            this.img,
                            this.colorAdjuster
                        );
                    }
                    return this.adjustedImg;
                }
            }

            class EnemyPlayerDrawable extends NonSquadPlayerDrawable {
                constructor(params, pixelSize) {
                    super(params, pixelSize);
                    this.colorAdjuster = (r, g, b, a) => {
                        let grayScale = 0.299 * r + 0.587 * g + 0.114 * b;
                        return {
                            r: grayScale,
                            g: 0.3 * grayScale,
                            b: 0.3 * grayScale,
                            a: a,
                        };
                    };
                }
                _getDownIcon() {
                    return downEnemyIcon;
                }

                _getDeadIcon() {
                    if (!adjustedEnemyDeadIcon && deadIcon.complete) {
                        adjustedEnemyDeadIcon = adjustImageColor(
                            deadIcon,
                            this.colorAdjuster
                        );
                    }
                    return adjustedEnemyDeadIcon;
                }
            }

            class FriendlyPlayerDrawable extends NonSquadPlayerDrawable {
                constructor(params, pixelSize) {
                    super(params, pixelSize);
                    this.colorAdjuster = (r, g, b, a) => {
                        let grayScale = 0.299 * r + 0.587 * g + 0.114 * b;
                        return {
                            r: 0.3 * grayScale,
                            g: grayScale,
                            b: 0.3 * grayScale,
                            a: a,
                        };
                    };
                }
                _getDownIcon() {
                    if (!adjustedFriendlyDownIcon && downAllyIcon.complete) {
                        adjustedFriendlyDownIcon = adjustImageColor(
                            downAllyIcon,
                            this.colorAdjuster
                        );
                    }
                    return adjustedFriendlyDownIcon;
                }
                _getDeadIcon() {
                    if (!adjustedFriendlyDeadIcon && deadIcon.complete) {
                        adjustedFriendlyDeadIcon = adjustImageColor(
                            deadIcon,
                            this.colorAdjuster
                        );
                    }
                    return adjustedFriendlyDeadIcon;
                }
            } /*jshint esversion: 6 */
            /* jshint node: true */
            /*jslint browser: true */
            /*global animator, ToRadians, overheadAnimationFrame, maxOverheadAnimationFrame, facingIcon, animateCanvas, noUpdateTime, SkillDecorationCategory*/
            ("use strict");

            class GenericMetadata {
                constructor(params) {}
            }

            class TextMetadata extends GenericMetadata {
                constructor(params) {
                    super(params);
                    this.color = params.color;
                    this.backgroundColor = params.backgroundColor;
                }
            }

            class TextOverheadMetadata extends TextMetadata {
                constructor(params) {
                    super(params);
                }
            }

            class GenericAttachedMetadata extends GenericMetadata {
                constructor(params) {
                    super(params);
                }
            }

            class ActorOrientationMetadata extends GenericAttachedMetadata {
                constructor(params) {
                    super(params);
                }
            }

            class FormMetadata extends GenericAttachedMetadata {
                constructor(params) {
                    super(params);
                    this.color = params.color;
                }
            }

            class CircleMetadata extends FormMetadata {
                constructor(params) {
                    super(params);
                    this.radius = InchToPixel * params.radius;
                    this.minRadius = InchToPixel * params.minRadius;
                }
            }

            class PolygonMetadata extends FormMetadata {
                constructor(params) {
                    super(params);
                    this.radius = InchToPixel * params.radius;
                    this.nbPolygon = params.nbPolygon;
                }
            }

            class DoughnutMetadata extends FormMetadata {
                constructor(params) {
                    super(params);
                    this.outerRadius = InchToPixel * params.outerRadius;
                    this.innerRadius = InchToPixel * params.innerRadius;
                }
            }

            class LineMetadata extends FormMetadata {
                constructor(params) {
                    super(params);
                    this.thickness = params.thickness;
                    this.worldSizeThickness = params.worldSizeThickness;
                    if (this.worldSizeThickness) {
                        this.thickness *= InchToPixel;
                    }
                }
            }

            class PieMetadata extends CircleMetadata {
                constructor(params) {
                    super(params);
                    this.openingAngle = params.openingAngle;
                    this.openingAngleRadians = ToRadians(this.openingAngle);
                    this.halfOpeningAngle = 0.5 * this.openingAngle;
                }
            }

            class RectangleMetadata extends FormMetadata {
                constructor(params) {
                    super(params);
                    this.width = InchToPixel * params.width;
                    this.height = InchToPixel * params.height;
                }
            }

            class ProgressBarMetadata extends RectangleMetadata {
                constructor(params) {
                    super(params);
                    this.secondaryColor = params.secondaryColor;
                }
            }

            class OverheadProgressBarMetadata extends ProgressBarMetadata {
                constructor(params) {
                    super(params);
                    this.pixelWidth = params.pixelWidth;
                    this.pixelHeight = params.pixelHeight;
                }
            }

            class ArenaMetadata extends GenericAttachedMetadata {
                constructor(params) {
                    super(params);
                    this.imageUrl = params.image;
                    this.image = new Image();
                    this.image.src = this.imageUrl;
                    this.image.onload = () => {
                        animator.needBGUpdate = true;
                        animateCanvas(noUpdateTime);
                    };
                    this.width = InchToPixel * params.width;
                    this.height = InchToPixel * params.height;
                }
            }

            class GenericIconMetadata extends GenericAttachedMetadata {
                constructor(params) {
                    super(params);
                    this.imageUrl = params.image;
                    this.image = new Image();
                    this.image.src = this.imageUrl;
                    this.image.onload = () => animateCanvas(noUpdateTime);
                    this.pixelSize = params.pixelSize;
                    this.worldSize = InchToPixel * params.worldSize;
                }
            }

            class BackgroundIconMetadata extends GenericIconMetadata {
                constructor(params) {
                    super(params);
                }
            }

            class IconMetadata extends GenericIconMetadata {
                constructor(params) {
                    super(params);
                    this.opacity = params.opacity;
                }
            }

            class IconOverheadMetadata extends IconMetadata {
                constructor(params) {
                    super(params);
                }
            }

            class BackgroundMetadata extends GenericMetadata {
                constructor(params) {
                    super(params);
                }
            }

            class MovingPlatformMetadata extends BackgroundMetadata {
                constructor(params) {
                    super(params);
                    this.imageUrl = params.image;
                    this.image = new Image();
                    this.image.src = this.imageUrl;
                    this.image.onload = () => animateCanvas(noUpdateTime);
                    this.width = InchToPixel * params.width;
                    this.height = InchToPixel * params.height;
                }
            }

            //// BASE MECHANIC

            const InterpolationMethod = {
                LINEAR: 0,
                STEP: 1,
            };

            function interpolatedPositionFetcher(
                connection,
                master,
                start,
                end
            ) {
                let index = -1;
                const totalPoints = connection.positions.length / 3;
                const time = animator.reactiveDataStatus.time;
                for (let i = 0; i < totalPoints; i++) {
                    const posTime = connection.positions[3 * i + 2];
                    if (time < posTime) {
                        break;
                    }
                    index = i;
                }
                if (index === -1) {
                    return {
                        x: connection.positions[0],
                        y: connection.positions[1],
                    };
                } else if (index === totalPoints - 1) {
                    return {
                        x: connection.positions[3 * index],
                        y: connection.positions[3 * index + 1],
                    };
                } else {
                    const cur = {
                        x: connection.positions[3 * index],
                        y: connection.positions[3 * index + 1],
                    };
                    switch (connection.interpolationMethod) {
                        case InterpolationMethod.LINEAR:
                            const curTime = connection.positions[3 * index + 2];
                            const next = {
                                x: connection.positions[3 * (index + 1)],
                                y: connection.positions[3 * (index + 1) + 1],
                            };
                            const nextTime =
                                connection.positions[3 * (index + 1) + 2];
                            const pt = {
                                x: 0,
                                y: 0,
                            };
                            pt.x =
                                cur.x +
                                ((time - curTime) / (nextTime - curTime)) *
                                    (next.x - cur.x);
                            pt.y =
                                cur.y +
                                ((time - curTime) / (nextTime - curTime)) *
                                    (next.y - cur.y);
                            return pt;
                        case InterpolationMethod.STEP:
                            return cur;
                        default:
                            return null;
                    }
                }
            }

            function staticPositionFetcher(connection, master, start, end) {
                const factor = connection.isScreenSpace
                    ? resolutionMultiplier
                    : 1;
                return {
                    x: factor * connection.position[0],
                    y: factor * connection.position[1],
                };
            }

            function noOffsetFetcher(connection) {
                return {
                    x: 0,
                    y: 0,
                };
            }

            function staticOffsetFetcher(connection) {
                return {
                    x: InchToPixel * connection.offset[0],
                    y: InchToPixel * connection.offset[1],
                };
            }

            function positionToMasterPositionFetcher(
                connection,
                master,
                start,
                end
            ) {
                if (!master) {
                    return null;
                }
                const initialPosition = {
                    x: connection.position[0],
                    y: connection.position[1],
                };
                const initialTime = connection.position[2];
                const time = animator.reactiveDataStatus.time;
                if (time <= initialTime) {
                    return null;
                }
                if (!connection._positions) {
                    const pollingRate = PollingRate / 2;
                    const velocity = InchToPixel * connection.velocity;
                    let currentPosition = initialPosition;
                    connection._positions = [
                        {
                            x: currentPosition.x,
                            y: currentPosition.y,
                            time: initialTime,
                        },
                    ];
                    for (let i = 1; i < (end - start) / pollingRate + 1; i++) {
                        let nextTime = initialTime + i * pollingRate;
                        const targetPosition = master._getPosition(nextTime);
                        if (!targetPosition) {
                            connection._positions.push({
                                x: currentPosition.x,
                                y: currentPosition.y,
                                time: nextTime,
                            });
                        } else {
                            const vector = {
                                x: targetPosition.x - currentPosition.x,
                                y: targetPosition.y - currentPosition.y,
                            };
                            const length = Math.sqrt(
                                vector.x * vector.x + vector.y * vector.y
                            );
                            vector.x /= Math.max(length, 1e-6);
                            vector.y /= Math.max(length, 1e-6);
                            const factor = pollingRate * velocity;
                            connection._positions.push({
                                x: currentPosition.x + factor * vector.x,
                                y: currentPosition.y + factor * vector.y,
                                time: nextTime,
                            });
                            currentPosition = connection._positions[i];
                        }
                    }
                }
                const positions = connection._positions;
                // TODO: optimize if necessary
                let i = 0;
                for (i = 0; i < positions.length; i++) {
                    let cur = positions[i];
                    if (cur.time > time) {
                        break;
                    }
                }
                const cur = positions[i - 1];
                const next = positions[i];
                const factor = (time - cur.time) / (next.time - cur.time);
                return {
                    x: factor * (next.x - cur.x) + cur.x,
                    y: factor * (next.y - cur.y) + cur.y,
                };
            }

            function masterPositionFetcher(connection, master, start, end) {
                if (!master) {
                    return null;
                }
                return master.getPosition();
            }

            function noAngleFetcher(connection, master, start, end) {
                return 0;
            }

            function interpolatedAngleFetcher(
                connection,
                master,
                dstMaster,
                start,
                end
            ) {
                let index = -1;
                const totalPoints = connection.angles.length / 2;
                const time = animator.reactiveDataStatus.time;
                for (let i = 0; i < totalPoints; i++) {
                    const posTime = connection.angles[2 * i + 1];
                    if (time < posTime) {
                        break;
                    }
                    index = i;
                }
                if (index === -1) {
                    return connection.angles[0];
                } else if (index === totalPoints - 1) {
                    return connection.angles[2 * index];
                } else {
                    const cur = connection.angles[2 * index];
                    switch (connection.interpolationMethod) {
                        case InterpolationMethod.LINEAR:
                            const curTime = connection.angles[2 * index + 1];
                            let next = connection.angles[2 * (index + 1)];
                            const nextTime =
                                connection.angles[2 * (index + 1) + 1];
                            // Make sure the interpolation is only done on the shortest path to avoid big flips around PI or -PI radians
                            if (next - cur < -180) {
                                next += 360.0;
                            } else if (next - cur > 180) {
                                next -= 360.0;
                            }
                            const interpolatedAngle =
                                cur +
                                ((time - curTime) / (nextTime - curTime)) *
                                    (next - cur);
                            return interpolatedAngle;
                        case InterpolationMethod.STEP:
                            return cur;
                        default:
                            return 0;
                    }
                }
            }

            function spinningAngleFetcher(
                connection,
                master,
                dstMaster,
                start,
                end
            ) {
                const time = animator.reactiveDataStatus.time;
                const factor = Math.max((time - start) / (end - start), 0.0);
                return connection.angle + factor * connection.spinAngle;
            }

            function staticAngleFetcher(
                connection,
                master,
                dstMaster,
                start,
                end
            ) {
                return connection.angle;
            }

            function masterRotationFetcher(
                connection,
                master,
                dstMaster,
                start,
                end
            ) {
                if (!master) {
                    return null;
                }
                return master.getRotation();
            }

            function masterToMasterRotationFetcher(
                connection,
                master,
                dstMaster,
                start,
                end
            ) {
                if (!master || !dstMaster) {
                    return null;
                }
                const origin = master.getPosition();
                const dst = dstMaster.getPosition();
                if (!origin || !dst) {
                    return null;
                }
                const vector = {
                    x: dst.x - origin.x,
                    y: dst.y - origin.y,
                };
                return ToDegrees(Math.atan2(vector.y, vector.x));
            }

            const RotationOffsetMode = {
                addToMaster: 0,
                absoluteOrientation: 1,
                rotateAfterTranslationOffset: 2,
            };

            class MechanicDrawable {
                constructor(params) {
                    this.start = params.start;
                    this.end = params.end;
                    this.positionFetcher = null;
                    this.connectedTo = params.connectedTo;
                    if (this.connectedTo.velocity >= 0) {
                        this.positionFetcher = positionToMasterPositionFetcher;
                    } else if (this.connectedTo.interpolationMethod >= 0) {
                        this.positionFetcher = interpolatedPositionFetcher;
                    } else if (this.connectedTo.position) {
                        this.positionFetcher = staticPositionFetcher;
                    } else if (this.connectedTo.masterID >= 0) {
                        this.positionFetcher = masterPositionFetcher;
                    }
                    this.offsetFetcher = noOffsetFetcher;
                    if (this.connectedTo.offset) {
                        this.offsetFetcher = staticOffsetFetcher;
                    }
                    this.rotationFetcher = noAngleFetcher;
                    this.rotationConnectedTo = params.rotationConnectedTo;
                    this.rotationOffset = 0;
                    this.rotationOffsetMode = RotationOffsetMode.addToMaster;
                    if (this.rotationConnectedTo) {
                        if (this.rotationConnectedTo.interpolationMethod >= 0) {
                            this.rotationFetcher = interpolatedAngleFetcher;
                        } else if (
                            this.rotationConnectedTo.spinAngle !== undefined
                        ) {
                            this.rotationFetcher = spinningAngleFetcher;
                        } else if (
                            this.rotationConnectedTo.angle !== undefined
                        ) {
                            this.rotationFetcher = staticAngleFetcher;
                        } else if (this.rotationConnectedTo.dstMasterID) {
                            this.rotationFetcher =
                                masterToMasterRotationFetcher;
                        } else if (this.rotationConnectedTo.masterID) {
                            this.rotationFetcher = masterRotationFetcher;
                            this.rotationOffset =
                                this.rotationConnectedTo.rotationOffset;
                            this.rotationOffsetMode =
                                this.rotationConnectedTo.rotationOffsetMode;
                        }
                    }
                    this.master = null;
                    this.rotationMaster = null;
                    this.dstRotationMaster = null;
                    // Skill mode
                    this.ownerID = null;
                    this.owner = null;
                    this.category = 0;
                    if (params.skillMode) {
                        this.ownerID = params.skillMode.owner.ownerID;
                        this.category = params.skillMode.category;
                    }
                    //
                    this.metadata = params._metadataContainer.get(
                        params.metadataSignature
                    );
                }

                draw() {
                    console.error("Draw should be overriden");
                    // to override
                }

                getOffset() {
                    const time = animator.reactiveDataStatus.time;
                    if (this.start > time || this.end < time) {
                        return null;
                    }
                    return this.offsetFetcher(this.connectedTo);
                }

                getRotation() {
                    const time = animator.reactiveDataStatus.time;
                    if (this.start > time || this.end < time) {
                        return null;
                    }
                    return this.rotationFetcher(
                        this.rotationConnectedTo,
                        this.rotationMaster,
                        this.dstRotationMaster,
                        this.start,
                        this.end
                    );
                }

                getPosition() {
                    const time = animator.reactiveDataStatus.time;
                    if (this.start > time || this.end < time) {
                        return null;
                    }
                    return this.positionFetcher(
                        this.connectedTo,
                        this.master,
                        this.start,
                        this.end
                    );
                }

                moveContext(ctx, pos, rot) {
                    const angle = ToRadians(rot);
                    const offsetAngle = ToRadians(this.rotationOffset);
                    const offset = this.getOffset();
                    const offsetAfterRotation =
                        this.connectedTo.offsetAfterRotation;
                    ctx.translate(pos.x, pos.y);
                    if (!offsetAfterRotation) {
                        ctx.translate(offset.x, offset.y);
                    }
                    ctx.rotate(angle);
                    if (
                        offsetAngle !== 0 &&
                        this.rotationOffsetMode ===
                            RotationOffsetMode.addToMaster
                    ) {
                        ctx.rotate(offsetAngle);
                    }
                    if (offsetAfterRotation) {
                        ctx.translate(offset.x, offset.y);
                    }
                    if (
                        offsetAngle !== 0 &&
                        this.rotationOffsetMode ===
                            RotationOffsetMode.rotateAfterTranslationOffset
                    ) {
                        ctx.rotate(offsetAngle);
                    }
                    if (
                        offsetAngle !== 0 &&
                        this.rotationOffsetMode ===
                            RotationOffsetMode.absoluteOrientation
                    ) {
                        ctx.rotate(-angle);
                        ctx.rotate(offsetAngle);
                    }
                }

                canDraw() {
                    if (this.connectedTo === null) {
                        return false;
                    }
                    if (
                        this.positionFetcher === masterPositionFetcher ||
                        this.positionFetcher === positionToMasterPositionFetcher
                    ) {
                        const masterID = this.connectedTo.masterID;
                        const perParentArray =
                            animator.agentDataPerParentID.get(masterID);
                        if (perParentArray) {
                            this.master = perParentArray.filter(
                                (x) => x.getPosition() != null
                            )[0];
                        } else if (this.master === null) {
                            this.master = animator.getActorData(masterID);
                        }
                        if (
                            !this.master ||
                            (!this.master.canDraw() && !this.ownerID)
                        ) {
                            return false;
                        }
                    }
                    if (
                        this.rotationFetcher === masterRotationFetcher ||
                        this.rotationFetcher === masterToMasterRotationFetcher
                    ) {
                        const masterID = this.rotationConnectedTo.masterID;
                        const perParentArray =
                            animator.agentDataPerParentID.get(masterID);
                        if (perParentArray) {
                            this.rotationMaster = perParentArray.filter(
                                (x) => x.getPosition() != null
                            )[0];
                        } else if (this.rotationMaster === null) {
                            this.rotationMaster =
                                animator.getActorData(masterID);
                        }
                        if (
                            !this.rotationMaster ||
                            (!this.rotationMaster.canDraw() && !this.ownerID)
                        ) {
                            return false;
                        }
                        if (
                            this.rotationFetcher ===
                            masterToMasterRotationFetcher
                        ) {
                            const dstMasterID =
                                this.rotationConnectedTo.dstMasterID;
                            const perDstParentArray =
                                animator.agentDataPerParentID.get(dstMasterID);
                            if (perDstParentArray) {
                                this.dstRotationMaster =
                                    perDstParentArray.filter(
                                        (x) => x.getPosition() != null
                                    )[0];
                            } else if (this.dstRotationMaster === null) {
                                this.dstRotationMaster =
                                    animator.getActorData(dstMasterID);
                            }
                            if (
                                !this.dstRotationMaster ||
                                (!this.dstRotationMaster.canDraw() &&
                                    !this.ownerID)
                            ) {
                                return false;
                            }
                        }
                    }
                    if (this.ownerID !== null) {
                        const ownerID = this.ownerID;
                        const perParentArray =
                            animator.agentDataPerParentID.get(ownerID);
                        if (perParentArray) {
                            this.owner = perParentArray.filter(
                                (x) => x.getPosition() != null
                            )[0];
                        } else if (this.owner === null) {
                            this.owner = animator.getActorData(ownerID);
                        }
                        if (!this.owner) {
                            return false;
                        }
                        let renderMask =
                            animator.displaySettings.skillMechanicsMask;
                        let drawOnSelect =
                            (renderMask &
                                SkillDecorationCategory["Show On Select"]) >
                            0;
                        renderMask &=
                            ~SkillDecorationCategory["Show On Select"];
                        if ((this.category & renderMask) > 0) {
                            return true;
                        } else if (
                            drawOnSelect &&
                            (this.owner.isSelected() ||
                                (this.owner.master &&
                                    this.owner.master.isSelected()))
                        ) {
                            return true;
                        }
                        return false;
                    }
                    return true;
                }
            }
            //// FACING
            class ActorOrientationDrawable extends MechanicDrawable {
                constructor(params) {
                    super(params);
                }

                draw() {
                    if (!this.canDraw()) {
                        return;
                    }
                    const pos = this.getPosition();
                    const rot = this.getRotation();
                    if (pos === null || rot === null) {
                        return;
                    }
                    const ctx = animator.mainContext;
                    ctx.save();
                    this.moveContext(ctx, pos, rot);
                    const facingFullSize = (5 * this.master.getSize()) / 3;
                    const facingHalfSize = facingFullSize / 2;
                    if (
                        this.master !== null &&
                        animator.coneControl.enabled &&
                        this.master.isSelected()
                    ) {
                        ctx.save();
                        const coneOpening = ToRadians(
                            animator.coneControl.openingAngle
                        );
                        ctx.rotate(0.5 * coneOpening);
                        const coneRadius =
                            InchToPixel * animator.coneControl.radius;
                        ctx.beginPath();
                        ctx.arc(0, 0, coneRadius, -coneOpening, 0, false);
                        ctx.arc(0, 0, 0, 0, coneOpening, true);
                        ctx.closePath();
                        ctx.fillStyle = "rgba(0, 255, 200, 0.3)";
                        ctx.fill();
                        ctx.restore();
                    }
                    ctx.drawImage(
                        facingIcon,
                        -facingHalfSize,
                        -facingHalfSize,
                        facingFullSize,
                        facingFullSize
                    );
                    ctx.restore();
                }
            }
            //// FORMS
            class FormMechanicDrawable extends MechanicDrawable {
                constructor(params) {
                    super(params);
                    this.fill = !!params.fill;
                    this.growingEnd = params.growingEnd;
                    this.growingReverse = !!params.growingReverse;
                }

                get color() {
                    return this.metadata.color;
                }

                getPercent() {
                    if (this.growingEnd <= this.start) {
                        return 1.0;
                    }
                    const time = animator.reactiveDataStatus.time;
                    let value = Math.min(
                        (time - this.start) / (this.growingEnd - this.start),
                        1.0
                    );
                    if (this.growingReverse) {
                        value = 1 - value;
                    }
                    return value;
                }
            }

            class CircleMechanicDrawable extends FormMechanicDrawable {
                constructor(params) {
                    super(params);
                }

                get radius() {
                    return this.metadata.radius;
                }

                get minRadius() {
                    return this.metadata.minRadius;
                }

                draw() {
                    if (!this.canDraw()) {
                        return;
                    }
                    const pos = this.getPosition();
                    const rot = this.getRotation();
                    if (pos === null || rot === null) {
                        return;
                    }
                    const ctx = animator.mainContext;
                    ctx.save();
                    this.moveContext(ctx, pos, rot);
                    ctx.beginPath();
                    ctx.arc(
                        0,
                        0,
                        this.getPercent() * (this.radius - this.minRadius) +
                            this.minRadius,
                        0,
                        2 * Math.PI
                    );
                    ctx.closePath();
                    if (this.fill) {
                        ctx.fillStyle = this.color;
                        ctx.fill();
                    } else {
                        ctx.lineWidth = (2 / animator.scale).toString();
                        ctx.strokeStyle = this.color;
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }

            class PolygonMechanicDrawable extends FormMechanicDrawable {
                constructor(params) {
                    super(params);
                }

                get radius() {
                    return this.metadata.radius;
                }

                get nbPolygon() {
                    return this.metadata.nbPolygon;
                }

                draw() {
                    if (!this.canDraw()) {
                        return;
                    }
                    const pos = this.getPosition();
                    const rot = this.getRotation();
                    if (pos === null || rot === null) {
                        return;
                    }
                    const ctx = animator.mainContext;
                    ctx.save();
                    this.moveContext(ctx, pos, rot);
                    ctx.beginPath();
                    const radius = this.getPercent() * this.radius;
                    const nbPolygon = this.nbPolygon;
                    ctx.moveTo(radius * Math.cos(0), radius * Math.sin(0));
                    for (let i = 1; i <= nbPolygon; i += 1) {
                        ctx.lineTo(
                            radius * Math.cos((i * 2 * Math.PI) / nbPolygon),
                            radius * Math.sin((i * 2 * Math.PI) / nbPolygon)
                        );
                    }

                    if (this.fill) {
                        ctx.fillStyle = this.color;
                        ctx.fill();
                    } else {
                        ctx.lineWidth = (2 / animator.scale).toString();
                        ctx.strokeStyle = this.color;
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }

            class DoughnutMechanicDrawable extends FormMechanicDrawable {
                constructor(params) {
                    super(params);
                }

                get outerRadius() {
                    return this.metadata.outerRadius;
                }

                get innerRadius() {
                    return this.metadata.innerRadius;
                }

                drawOuterCircle(percent) {
                    const ctx = animator.mainContext;
                    if (this.growingReverse) {
                        ctx.arc(0, 0, this.outerRadius, 2 * Math.PI, 0, false);
                    } else {
                        ctx.arc(
                            0,
                            0,
                            this.innerRadius +
                                percent * (this.outerRadius - this.innerRadius),
                            2 * Math.PI,
                            0,
                            false
                        );
                    }
                }

                drawInnerCircle(percent) {
                    const ctx = animator.mainContext;
                    if (this.growingReverse) {
                        ctx.arc(
                            0,
                            0,
                            this.innerRadius +
                                percent * (this.outerRadius - this.innerRadius),
                            0,
                            2 * Math.PI,
                            true
                        );
                    } else {
                        ctx.arc(0, 0, this.innerRadius, 0, 2 * Math.PI, true);
                    }
                }

                draw() {
                    if (!this.canDraw()) {
                        return;
                    }
                    const pos = this.getPosition();
                    const rot = this.getRotation();
                    if (pos === null || rot === null) {
                        return;
                    }
                    const percent = this.getPercent();
                    const ctx = animator.mainContext;
                    ctx.save();
                    this.moveContext(ctx, pos, rot);
                    if (this.fill) {
                        ctx.fillStyle = this.color;

                        ctx.beginPath();
                        this.drawOuterCircle(percent);
                        this.drawInnerCircle(percent);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        ctx.lineWidth = (2 / animator.scale).toString();
                        ctx.strokeStyle = this.color;

                        ctx.beginPath();
                        this.drawOuterCircle(percent);
                        ctx.closePath();
                        ctx.stroke();

                        ctx.beginPath();
                        this.drawInnerCircle(percent);
                        ctx.closePath();
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }

            class RectangleMechanicDrawable extends FormMechanicDrawable {
                constructor(params) {
                    super(params);
                }

                get height() {
                    return this.metadata.height;
                }

                get width() {
                    return this.metadata.width;
                }

                draw() {
                    if (!this.canDraw()) {
                        return;
                    }
                    const pos = this.getPosition();
                    const rot = this.getRotation();
                    if (pos === null || rot === null) {
                        return;
                    }
                    const percent = this.getPercent();
                    const ctx = animator.mainContext;
                    ctx.save();
                    this.moveContext(ctx, pos, rot);
                    ctx.beginPath();
                    ctx.rect(
                        -0.5 * percent * this.width,
                        -0.5 * percent * this.height,
                        percent * this.width,
                        percent * this.height
                    );
                    ctx.closePath();
                    if (this.fill) {
                        ctx.fillStyle = this.color;
                        ctx.fill();
                    } else {
                        ctx.lineWidth = (2 / animator.scale).toString();
                        ctx.strokeStyle = this.color;
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }

            class ProgressBarMechanicDrawable extends RectangleMechanicDrawable {
                constructor(params) {
                    super(params);
                    this.interpolationMethod = params.interpolationMethod;
                    this.progress = params.progress;
                }

                get secondaryColor() {
                    return this.metadata.secondaryColor;
                }

                getSecondaryOffset() {
                    return null;
                }

                computeProgress() {
                    const progress = this.progress;
                    let index = -1;
                    const totalPoints = progress.length;
                    const time = animator.reactiveDataStatus.time;
                    for (let i = 0; i < totalPoints; i++) {
                        const posTime = progress[i][0];
                        if (time < posTime) {
                            break;
                        }
                        index = i;
                    }
                    if (index === -1) {
                        return progress[0][1];
                    } else if (index === totalPoints - 1) {
                        return progress[index][1];
                    } else {
                        const cur = progress[index][1];
                        switch (this.interpolationMethod) {
                            case InterpolationMethod.LINEAR:
                                const curTime = progress[index][0];
                                const next = progress[index + 1][1];
                                const nextTime = progress[index + 1][0];
                                const interpolated =
                                    cur +
                                    ((time - curTime) / (nextTime - curTime)) *
                                        (next - cur);
                                return interpolated;
                            case InterpolationMethod.STEP:
                                return cur;
                            default:
                                return 0;
                        }
                    }
                }

                getSize() {
                    return {
                        h: this.height,
                        w: this.width,
                    };
                }

                draw() {
                    if (!this.canDraw()) {
                        return;
                    }
                    const pos = this.getPosition();
                    const rot = this.getRotation();
                    if (pos === null || rot === null) {
                        return;
                    }
                    const size = this.getSize();
                    const progressPercent = this.computeProgress() / 100.0;
                    const ctx = animator.mainContext;
                    ctx.save();
                    this.moveContext(ctx, pos, rot);
                    const secondaryOffset = this.getSecondaryOffset();
                    if (secondaryOffset) {
                        ctx.translate(secondaryOffset.x, secondaryOffset.y);
                    }
                    const normalizedRot = Math.abs(
                        (ToRadians(rot + this.rotationOffset) / Math.PI) % 2
                    );
                    if (0.5 < normalizedRot && normalizedRot < 1.5) {
                        // make sure the progress bar remains upright
                        ctx.rotate(-ToRadians(180));
                    }
                    if (progressPercent > 0) {
                        ctx.beginPath();
                        ctx.rect(
                            -0.5 * size.w,
                            -0.5 * size.h,
                            progressPercent * size.w,
                            size.h
                        );
                        ctx.closePath();
                        ctx.fillStyle = this.color;
                        ctx.fill();
                        //
                        ctx.beginPath();
                        ctx.rect(
                            -0.5 * size.w,
                            -0.5 * size.h,
                            progressPercent * size.w,
                            size.h
                        );
                        ctx.closePath();
                        ctx.lineWidth = (3 / animator.scale).toString();
                        ctx.strokeStyle = this.color;
                        ctx.stroke();
                        //
                        ctx.beginPath();
                        ctx.rect(-0.5 * size.w, -0.5 * size.h, size.w, size.h);
                        ctx.closePath();
                        ctx.lineWidth = (2 / animator.scale).toString();
                        ctx.strokeStyle = this.color;
                        ctx.stroke();
                        if (progressPercent < 1) {
                            const reverseProgressPercent =
                                1.0 - progressPercent;
                            ctx.beginPath();
                            ctx.rect(
                                (-0.5 + progressPercent) * size.w,
                                -0.5 * size.h,
                                reverseProgressPercent * size.w,
                                size.h
                            );
                            ctx.closePath();
                            ctx.fillStyle = this.secondaryColor;
                            ctx.fill();
                        }
                    }
                    ctx.restore();
                }
            }

            class OverheadProgressBarMechanicDrawable extends ProgressBarMechanicDrawable {
                constructor(params) {
                    super(params);
                }
                get pixelHeight() {
                    return this.metadata.pixelHeight;
                }

                get pixelWidth() {
                    return this.metadata.pixelWidth;
                }
                getSecondaryOffset() {
                    if (!this.master) {
                        console.error("Invalid OverheadProgressBar decoration");
                        return null;
                    }
                    const masterSize = this.master.getSize();
                    let offset = {
                        x: 0,
                        y: 0,
                    };
                    offset.y -= masterSize / 4 + this.getSize().h;
                    return offset;
                }

                getSize() {
                    if (animator.displaySettings.useActorHitboxWidth) {
                        return {
                            h: this.height,
                            w: this.width,
                        };
                    } else {
                        return {
                            h: this.pixelHeight / animator.scale,
                            w: this.pixelWidth / animator.scale,
                        };
                    }
                }
            }
            class PieMechanicDrawable extends FormMechanicDrawable {
                constructor(params) {
                    super(params);
                }

                get openingAngleRadians() {
                    return this.metadata.openingAngleRadians;
                }

                get halfOpeningAngle() {
                    return this.metadata.halfOpeningAngle;
                }

                get radius() {
                    return this.metadata.radius;
                }

                draw() {
                    if (!this.canDraw()) {
                        return;
                    }
                    const pos = this.getPosition();
                    const rot = this.getRotation();
                    if (pos === null || rot === null) {
                        return;
                    }
                    const ctx = animator.mainContext;
                    const percent = this.getPercent();
                    ctx.save();
                    this.moveContext(ctx, pos, rot + this.halfOpeningAngle);
                    ctx.beginPath();
                    ctx.arc(
                        0,
                        0,
                        percent * this.radius,
                        -this.openingAngleRadians,
                        0,
                        false
                    );
                    ctx.arc(0, 0, 0, 0, this.openingAngleRadians, true);
                    ctx.closePath();
                    if (this.fill) {
                        ctx.fillStyle = this.color;
                        ctx.fill();
                    } else {
                        ctx.lineWidth = (2 / animator.scale).toString();
                        ctx.strokeStyle = this.color;
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }

            class LineMechanicDrawable extends FormMechanicDrawable {
                constructor(params) {
                    super(params);
                    this.connectedFrom = params.connectedFrom;
                    this.targetPositionFetcher = null;
                    if (this.connectedFrom.interpolationMethod >= 0) {
                        this.targetPositionFetcher =
                            interpolatedPositionFetcher;
                    } else if (this.connectedFrom.position instanceof Array) {
                        this.targetPositionFetcher = staticPositionFetcher;
                    } else {
                        this.targetPositionFetcher = masterPositionFetcher;
                    }
                    this.targetOffsetFetcher = noOffsetFetcher;
                    if (this.connectedFrom.offset) {
                        this.targetOffsetFetcher = staticOffsetFetcher;
                    }
                    this.endMaster = null;
                }

                get thickness() {
                    return this.metadata.thickness;
                }

                get worldSizeThickness() {
                    return this.metadata.worldSizeThickness;
                }

                getTargetPosition() {
                    const time = animator.reactiveDataStatus.time;
                    if (this.start > time || this.end < time) {
                        return null;
                    }
                    const pos = this.targetPositionFetcher(
                        this.connectedFrom,
                        this.endMaster
                    );
                    if (!pos) {
                        return null;
                    }
                    const offset = this.targetOffsetFetcher(this.connectedFrom);
                    pos.x += offset.x;
                    pos.y += offset.y;
                    return pos;
                }

                canDraw() {
                    if (this.connectedFrom === null) {
                        return false;
                    }
                    if (this.targetPositionFetcher === masterPositionFetcher) {
                        const masterID = this.connectedFrom.masterID;
                        const perParentArray =
                            animator.agentDataPerParentID.get(masterID);
                        if (perParentArray) {
                            this.endMaster = perParentArray.filter(
                                (x) => x.getPosition() != null
                            )[0];
                        } else if (this.endMaster === null) {
                            this.endMaster = animator.getActorData(masterID);
                        }
                        if (!this.endMaster || !this.endMaster.canDraw()) {
                            return false;
                        }
                    }
                    return super.canDraw();
                }

                draw() {
                    if (!this.canDraw()) {
                        return;
                    }
                    const pos = this.getPosition();
                    const target = this.getTargetPosition();
                    if (pos === null || target === null) {
                        return;
                    }
                    const percent = this.getPercent();
                    const ctx = animator.mainContext;
                    ctx.save();
                    if (this.growingReverse) {
                        this.moveContext(ctx, target, 0);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(
                            (1 - percent) * (pos.x - target.x),
                            percent * (pos.y - target.y)
                        );
                        ctx.closePath();
                    } else {
                        this.moveContext(ctx, pos, 0);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(
                            percent * (target.x - pos.x),
                            percent * (target.y - pos.y)
                        );
                        ctx.closePath();
                    }
                    let thickness = this.thickness;
                    if (!this.worldSizeThickness) {
                        thickness /= animator.scale;
                    }
                    ctx.lineWidth = thickness.toString();
                    ctx.strokeStyle = this.color;
                    ctx.stroke();
                    ctx.restore();
                }
            }
            //// BACKGROUND
            class BackgroundDrawable {
                constructor(params) {
                    this.start = params.start;
                    this.end = params.end;
                    this.metadata = params._metadataContainer.get(
                        params.metadataSignature
                    );
                }

                draw() {
                    // to override
                }

                getHeight() {
                    // to override
                    return 0;
                }

                getPosition() {
                    // to override
                    return null;
                }
            }

            class MovingPlatformDrawable extends BackgroundDrawable {
                constructor(params) {
                    super(params);
                    this.positions = params.positions;
                    if (this.positions.length > 1) {
                        this.currentIndex = 0;
                        this.currentStart = Number.NEGATIVE_INFINITY;
                        this.currentEnd = this.positions[0][5];
                    }
                }

                get image() {
                    return this.metadata.image;
                }

                get imageUrl() {
                    return this.metadata.imageUrl;
                }

                get height() {
                    return this.metadata.height;
                }

                get width() {
                    return this.metadata.width;
                }

                draw() {
                    const pos = this.getInterpolatedPosition();
                    if (pos === null) {
                        return;
                    }
                    const ctx = animator.mainContext;
                    const rads = pos.angle;
                    ctx.save();
                    ctx.translate(pos.x, pos.y);
                    ctx.rotate(rads % (2 * Math.PI));
                    ctx.globalAlpha = pos.opacity;
                    ctx.drawImage(
                        this.image,
                        -0.5 * this.width,
                        -0.5 * this.height,
                        this.width,
                        this.height
                    );
                    ctx.restore();
                }

                getHeight() {
                    let position = this.getInterpolatedPosition();
                    if (position === null) {
                        return Number.NEGATIVE_INFINITY;
                    }

                    return position.z;
                }

                getInterpolatedPosition() {
                    let time = animator.reactiveDataStatus.time;
                    if (time < this.start || time > this.end) {
                        return null;
                    }
                    if (this.positions.length === 0) {
                        return null;
                    }
                    if (this.positions.length === 1) {
                        return {
                            x: this.positions[0][0],
                            y: this.positions[0][1],
                            z: this.positions[0][2],
                            angle: this.positions[0][3],
                            opacity: this.positions[0][4],
                        };
                    }

                    let i;
                    let changed = false;
                    if (this.currentStart <= time && time < this.currentEnd) {
                        i = this.currentIndex;
                    } else {
                        for (i = 0; i < this.positions.length; i++) {
                            let positionTime = this.positions[i][5];
                            if (positionTime > time) {
                                break;
                            }
                        }
                        changed = true;
                    }

                    if (changed) {
                        this.currentIndex = i;
                        if (i === 0) {
                            this.currentStart = Number.NEGATIVE_INFINITY;
                            this.currentEnd = this.positions[0][5];
                        } else {
                            this.currentStart = this.positions[i - 1][5];
                            if (i === this.positions.length) {
                                this.currentEnd = Number.POSITIVE_INFINITY;
                            } else {
                                this.currentEnd = this.positions[i][5];
                            }
                        }
                    }

                    if (i === 0) {
                        // First position is in the future
                        return null;
                    }

                    if (i === this.positions.length) {
                        // The last position is in the past, use the last position
                        return {
                            x: this.positions[i - 1][0],
                            y: this.positions[i - 1][1],
                            z: this.positions[i - 1][2],
                            angle: this.positions[i - 1][3],
                            opacity: this.positions[i - 1][4],
                        };
                    }

                    let progress =
                        (time - this.positions[i - 1][5]) /
                        (this.positions[i][5] - this.positions[i - 1][5]);

                    return {
                        x:
                            this.positions[i - 1][0] * (1 - progress) +
                            this.positions[i][0] * progress,
                        y:
                            this.positions[i - 1][1] * (1 - progress) +
                            this.positions[i][1] * progress,
                        z:
                            this.positions[i - 1][2] * (1 - progress) +
                            this.positions[i][2] * progress,
                        angle:
                            this.positions[i - 1][3] * (1 - progress) +
                            this.positions[i][3] * progress,
                        opacity:
                            this.positions[i - 1][4] * (1 - progress) +
                            this.positions[i][4] * progress,
                    };
                }
            }
            ///

            class ArenaDrawable extends MechanicDrawable {
                constructor(params) {
                    super(params);
                    this.previouslyRendered = false;
                }

                get image() {
                    return this.metadata.image;
                }

                get imageUrl() {
                    return this.metadata.imageUrl;
                }

                get width() {
                    return this.metadata.width;
                }

                get height() {
                    return this.metadata.height;
                }

                needsUpdate() {
                    if (!this.canDraw()) {
                        return this.previouslyRendered;
                    }
                    const pos = this.getPosition();
                    if (pos === null) {
                        return this.previouslyRendered;
                    }
                    return !this.previouslyRendered;
                }

                draw() {
                    this.previouslyRendered = false;
                    if (!this.canDraw()) {
                        return;
                    }
                    const pos = this.getPosition();
                    if (pos === null) {
                        return;
                    }
                    this.previouslyRendered = true;
                    const ctx = animator.bgContext;
                    ctx.save();
                    this.moveContext(ctx, pos, null);
                    const height = this.height;
                    const width = this.width;
                    ctx.clearRect(0, 0, width, height);
                    ctx.drawImage(this.image, 0, 0, width, height);
                    ctx.restore();
                }
            }

            class IconMechanicDrawable extends MechanicDrawable {
                constructor(params) {
                    super(params);
                    this.canRotate = false;
                    this.text = params.text;
                }

                get image() {
                    return this.metadata.image;
                }

                get imageUrl() {
                    return this.metadata.imageUrl;
                }

                get pixelSize() {
                    return this.metadata.pixelSize;
                }

                get worldSize() {
                    return this.metadata.worldSize;
                }

                getSize() {
                    if (
                        animator.displaySettings.useActorHitboxWidth &&
                        this.worldSize > 0
                    ) {
                        return this.worldSize;
                    } else if (this.pixelSize > 0) {
                        return this.pixelSize / animator.scale;
                    } else if (this.worldSize > 0) {
                        return this.worldSize;
                    }
                }

                getOpacity() {
                    return this.metadata.opacity;
                }

                getSecondaryOffset() {
                    return null;
                }

                draw() {
                    if (!this.canDraw()) {
                        return;
                    }
                    const pos = this.getPosition();
                    const rot = this.getRotation();
                    if (pos === null || rot === null) {
                        return;
                    }

                    const ctx = animator.mainContext;
                    ctx.save();
                    this.moveContext(ctx, pos, rot);
                    ctx.globalAlpha = this.getOpacity();
                    const secondaryOffset = this.getSecondaryOffset();
                    if (secondaryOffset) {
                        ctx.translate(secondaryOffset.x, secondaryOffset.y);
                    }
                    if (!this.canRotate) {
                        // Don't rotate the icon
                        ctx.rotate(-ToRadians(rot + this.rotationOffset));
                    }
                    const size = this.getSize();
                    const aspectRatio = this.image.width / this.image.height;
                    const sizeW = size * aspectRatio;
                    ctx.drawImage(
                        this.image,
                        -sizeW / 2,
                        -size / 2,
                        sizeW,
                        size
                    );
                    if (this.text) {
                        const font = "bold " + sizeW / 1.5 + "px Comic Sans MS";
                        ctx.font = font;
                        ctx.fillStyle = "rgb(0,0,0)";
                        ctx.textAlign = "center";
                        ctx.fillText(this.text, 0, sizeW / 2.5);
                    }
                    ctx.restore();
                }
            }

            class BackgroundIconMechanicDrawable extends IconMechanicDrawable {
                constructor(params) {
                    super(params);
                    this.canRotate = true;
                    this.opacities = params.opacities;
                    this.heights = params.heights;
                }

                getHeight() {
                    let index = -1;
                    const heights = this.heights;
                    const totalPoints = heights.length / 2;
                    const time = animator.reactiveDataStatus.time;
                    for (let i = 0; i < totalPoints; i++) {
                        let heightTime = heights[2 * i + 1];
                        if (time < heightTime) {
                            index = i - 1;
                            break;
                        }
                        index = i;
                    }
                    if (index === -1) {
                        return heights[0];
                    } else if (index === totalPoints - 1) {
                        return heights[2 * index];
                    } else {
                        return heights[2 * index];
                    }
                }

                getOpacity() {
                    let index = -1;
                    const opacities = this.opacities;
                    const totalPoints = opacities.length / 2;
                    const time = animator.reactiveDataStatus.time;
                    let interpolate = 0;
                    for (let i = 0; i < totalPoints; i++) {
                        let opacityTime = opacities[2 * i + 1];
                        if (time < opacityTime) {
                            if (opacityTime - time <= 1500)
                                interpolate = opacityTime;
                            index = i - 1;
                            break;
                        }
                        index = i;
                    }
                    if (index === -1) {
                        return opacities[0];
                    } else if (interpolate > 0) {
                        return (
                            opacities[2 * (index + 1)] -
                            ((interpolate - time) *
                                (opacities[2 * (index + 1)] -
                                    opacities[2 * index])) /
                                1500
                        );
                    } else {
                        return opacities[2 * index];
                    }
                }
            }

            class IconOverheadMechanicDrawable extends IconMechanicDrawable {
                constructor(params) {
                    super(params);
                }

                getSize() {
                    if (
                        animator.displaySettings.useActorHitboxWidth &&
                        this.worldSize > 0
                    ) {
                        return this.worldSize;
                    } else {
                        return this.pixelSize / animator.scale;
                    }
                }

                getSecondaryOffset() {
                    if (!this.master) {
                        console.error("Invalid IconOverhead decoration");
                        return null;
                    }
                    const masterSize = this.master.getSize();
                    const scale = animator.displaySettings.useActorHitboxWidth
                        ? 1 / InchToPixel
                        : animator.scale;
                    let offset = {
                        x: 0,
                        y: 0,
                    };
                    offset.y -=
                        masterSize / 3.0 +
                        this.getSize() / 2.0 +
                        (3.0 * overheadAnimationFrame) /
                            maxOverheadAnimationFrame /
                            scale;
                    return offset;
                }
            }

            //

            class TextDrawable extends MechanicDrawable {
                constructor(params) {
                    super(params);
                    this.text = params.text;
                    this.bold = !!params.bold;
                    this.fontSize = params.fontSize;
                    this.fontType = params.fontType || "Comic Sans MS";
                }
                get color() {
                    return this.metadata.color;
                }
                get backgroundColor() {
                    return this.metadata.backgroundColor;
                }

                getFontSize() {
                    if (this.connectedTo.isScreenSpace) {
                        return this.fontSize * resolutionMultiplier;
                    }
                    return this.fontSize / animator.scale;
                }

                getSecondaryOffset() {
                    return null;
                }

                draw() {
                    if (!this.canDraw()) {
                        return;
                    }
                    const pos = this.getPosition();
                    const rot = this.getRotation();
                    if (pos === null || rot === null) {
                        return;
                    }
                    const fontSize = this.getFontSize();
                    pos.y += fontSize / 2;
                    const ctx = animator.mainContext;
                    ctx.save();
                    this.moveContext(ctx, pos, rot);
                    const secondaryOffset = this.getSecondaryOffset();
                    if (secondaryOffset) {
                        ctx.translate(secondaryOffset.x, secondaryOffset.y);
                    }
                    // Don't rotate the text
                    ctx.rotate(-ToRadians(rot + this.rotationOffset));
                    const font =
                        (this.bold ? "bold " : "") +
                        fontSize +
                        "px " +
                        this.fontType;
                    ctx.font = font;
                    ctx.fillStyle = this.color;
                    ctx.textAlign = "center";
                    ctx.fillText(this.text, 0, 0);
                    ctx.restore();
                }
            }

            class TextOverheadDrawable extends TextDrawable {
                constructor(params) {
                    super(params);
                }

                getFontSize() {
                    if (animator.displaySettings.useActorHitboxWidth) {
                        return (
                            this.fontSize /
                            (resolutionMultiplier * resolutionMultiplier)
                        );
                    } else {
                        return this.fontSize / animator.scale;
                    }
                }

                getSecondaryOffset() {
                    if (!this.master) {
                        console.error("Invalid TextOverhead decoration");
                        return null;
                    }
                    const masterSize = this.master.getSize();
                    const scale = animator.displaySettings.useActorHitboxWidth
                        ? 1 / InchToPixel
                        : animator.scale;
                    let offset = {
                        x: 0,
                        y: 0,
                    };
                    offset.y -=
                        masterSize / 3.0 +
                        this.getFontSize() / 2.0 +
                        (3.0 * overheadAnimationFrame) /
                            maxOverheadAnimationFrame /
                            scale;
                    return offset;
                }
            }
        </script>
    </head>
    <body class="theme-slate">
        <script>
            $("body").addClass("theme-" + window.theme);
        </script>
        <div class="ei-container-small" id="content">
            <div
                class="d-flex flex-row justify-content-center align-items-center mt-2"
            >
                <div
                    class="d-flex flex-column justify-content-center align-items-center"
                >
                    <img
                        class="mb-1 icon"
                        data-original-title="As of arcdps 20210923, animated cast events' durations are broken, as such, any feature having a dependency on it are to be taken with a grain of salt. Impacted features are: &lt;br&gt;- Rotations &lt;br&gt;- Time spent in animation statistics &lt;br&gt;- Mechanics &lt;br&gt;- Phases &lt;br&gt;- Combat Replay Decorations"
                        src="https://i.imgur.com/k3tdKEQ.png"
                    />
                </div>
                <div class="card fight-summary" style="min-width: 350px">
                    <!-- -->
                    <h3 class="card-header text-center">
                        Standard Kitty Golem
                    </h3>
                    <!-- -->
                    <div class="card-body card-body-encounter container">
                        <div
                            class="d-flex flex-row justify-content-center align-items-center"
                        >
                            <div
                                class="d-flex flex-column mr-3 justify-content-center"
                            >
                                <!-- -->
                                <img
                                    alt="Standard Kitty Golem"
                                    class="encounter-icon"
                                    src="https://assets.gw2dat.com//1203237.png"
                                />
                            </div>
                            <div
                                class="ml-1 d-flex flex-column justify-content-center"
                            >
                                <div class="mb-1">
                                    <div
                                        class="small"
                                        style="text-align: center"
                                    >
                                        Standard Kitty Golem
                                    </div>
                                    <div>
                                        <div
                                            class="healthBar"
                                            style="
                                                background: linear-gradient(
                                                    to right,
                                                    red 0%,
                                                    yellow 0%,
                                                    yellow 0%,
                                                    green 0%
                                                );
                                            "
                                        ></div>
                                        <div
                                            class="super-small"
                                            style="text-align: center"
                                        >
                                            4000000 HP
                                        </div>
                                    </div>
                                </div>
                                <!-- -->
                                <div class="mb-2 mt-2">
                                    Duration: 01m 39s 486ms
                                </div>
                                <!-- -->
                                <!-- -->
                                <!-- -->
                                <div class="text text-success">
                                    Result: Success
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div
                    class="d-flex flex-column justify-content-center align-items-center ml-5"
                >
                    <div
                        class="d-flex flex-row justify-content-center align-items-center mt-2 mb-2"
                    >
                        <ul class="nav nav-pills" style="pointer-events: auto">
                            <li class="nav-item">
                                <a class="nav-link"> Light Theme </a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link active"> Dark Theme </a>
                            </li>
                        </ul>
                    </div>
                    <div
                        class="d-flex flex-row justify-content-center align-items-center"
                    >
                        <ul class="nav nav-pills">
                            <li class="nav-item mb-1">
                                <a class="nav-link active"> Statistics </a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link"> Combat Replay </a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link"> Healing Statistics </a>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
            <div>
                <div>
                    <div
                        class="d-flex flex-row justify-content-center mt-1"
                        id="phase-nav"
                    >
                        <div>
                            <ul
                                class="nav nav-pills d-flex flex-row justify-content-center"
                            >
                                <li
                                    class="nav-item"
                                    data-original-title="99.486 seconds &lt;br /&gt; Start: 0&lt;br /&gt; End: 99.486"
                                >
                                    <a class="nav-link active"> Full Fight </a>
                                </li>
                                <li
                                    class="nav-item"
                                    data-original-title="81.23 seconds &lt;br /&gt; Start: 0&lt;br /&gt; End: 81.23"
                                >
                                    <a class="nav-link"> Fourth Number </a>
                                </li>
                                <li
                                    class="nav-item"
                                    data-original-title="62.63 seconds &lt;br /&gt; Start: 0&lt;br /&gt; End: 62.63"
                                >
                                    <a class="nav-link"> Third Number </a>
                                </li>
                                <li
                                    class="nav-item"
                                    data-original-title="43.13 seconds &lt;br /&gt; Start: 0&lt;br /&gt; End: 43.13"
                                >
                                    <a class="nav-link"> Second Number </a>
                                </li>
                                <li
                                    class="nav-item"
                                    data-original-title="23.03 seconds &lt;br /&gt; Start: 0&lt;br /&gt; End: 23.03"
                                >
                                    <a class="nav-link"> First Number </a>
                                </li>
                                <li
                                    class="nav-item"
                                    data-original-title="23.03 seconds &lt;br /&gt; Start: 0&lt;br /&gt; End: 23.03"
                                >
                                    <a class="nav-link"> 100% - 80% </a>
                                </li>
                                <li
                                    class="nav-item"
                                    data-original-title="20.1 seconds &lt;br /&gt; Start: 23.03&lt;br /&gt; End: 43.13"
                                >
                                    <a class="nav-link"> 80% - 60% </a>
                                </li>
                                <li
                                    class="nav-item"
                                    data-original-title="19.5 seconds &lt;br /&gt; Start: 43.13&lt;br /&gt; End: 62.63"
                                >
                                    <a class="nav-link"> 60% - 40% </a>
                                </li>
                                <li
                                    class="nav-item"
                                    data-original-title="18.6 seconds &lt;br /&gt; Start: 62.63&lt;br /&gt; End: 81.23"
                                >
                                    <a class="nav-link"> 40% - 20% </a>
                                </li>
                                <li
                                    class="nav-item"
                                    data-original-title="18.256 seconds &lt;br /&gt; Start: 81.23&lt;br /&gt; End: 99.486"
                                >
                                    <a class="nav-link"> 20% - 0% </a>
                                </li>
                            </ul>
                            <!-- -->
                        </div>
                    </div>
                    <div
                        class="d-flex flex-row justify-content-center mb-2 mt-2"
                        id="actors"
                    >
                        <div
                            class="flex-row justify-content-center align-items-center flex-wrap mr-5 d-flex"
                        >
                            <div
                                class="d-flex flex-row justify-content-center flex-wrap"
                                style="width: 80px"
                            >
                                <div
                                    class="d-flex flex-row justify-content-center align-items-center flex-wrap"
                                    style="max-width: 408px"
                                >
                                    <div>
                                        <img
                                            alt="Standard Kitty Golem"
                                            class="icon-lg mr-2 ml-2 target-cell active"
                                            data-original-title="Standard Kitty Golem"
                                            src="https://i.imgur.com/TCSo8TI.png"
                                        />
                                        <div
                                            class="d-flex flex-row justify-content-center align-items-center mb-2"
                                        >
                                            <img
                                                alt="Health"
                                                class="icon"
                                                data-original-title="Health: 4000000"
                                                src="https://wiki.guildwars2.com/images/b/be/Vitality.png"
                                            />
                                            <img
                                                alt="Toughness"
                                                class="icon"
                                                data-original-title="Toughness: 1374"
                                                hbheight=""
                                                src="https://wiki.guildwars2.com/images/1/12/Toughness.png"
                                            />
                                            <img
                                                alt="Hitbox Width"
                                                class="icon"
                                                data-original-title="Hitbox Width: 140"
                                                src="https://i.imgur.com/QSI79aT.png"
                                            />
                                            <!-- -->
                                        </div>
                                    </div>
                                </div>
                                <div
                                    class="ml-4 d-flex flex-column justify-content-center align-items-center"
                                    style="max-width: 362px; display: none"
                                >
                                    <div
                                        class="d-flex flex-row justify-content-center align-items-center flex-wrap"
                                    ></div>
                                    <div style="display: none">
                                        <ul class="scale85 nav nav-pills">
                                            <li class="nav-item">
                                                <a class="nav-link">
                                                    Select All
                                                </a>
                                            </li>
                                            <li class="nav-item">
                                                <a class="nav-link">
                                                    Deselect All
                                                </a>
                                            </li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="ml-5">
                            <div class="d-flex flex-row">
                                <div class="d-flex flex-column mr-1">
                                    <img
                                        class="icon"
                                        data-original-title="
                        &lt;span style='text-align:left;display: block;'&gt;
                        A player has a stat score if they are above 60% of the maximum stat present in the squad. For example if the maximum healing power stat inside the squad is 1000, anybody with a healing power stat above 600 will be flagged as with healing power.
                        &lt;/span&gt;
                    "
                                        src="https://i.imgur.com/nSYuby8.png"
                                    />
                                    <img
                                        class="icon"
                                        data-original-title="
                &lt;span style='text-align:left;display: block;'&gt;
                Weapons are estimated based on skills that were cast by the player.
                &lt;/span&gt;
                "
                                        src="https://i.imgur.com/nSYuby8.png"
                                    />
                                </div>
                                <div
                                    class="d-flex flex-column"
                                    style="max-width: 900px"
                                >
                                    <div class="d-flex flex-wrap mb-1">
                                        <div
                                            class="player-cell d-flex flex-column align-items-center justify-content-center active"
                                        >
                                            <div>
                                                <img
                                                    alt="Paragon"
                                                    class="icon"
                                                    data-original-title="Paragon"
                                                    src="https://i.imgur.com/Wp4lhTM.png"
                                                />
                                                <!-- -->
                                                <img
                                                    alt="Condition Damage"
                                                    class="icon"
                                                    data-original-title="Condition Damage"
                                                    src="https://wiki.guildwars2.com/images/5/54/Condition_Damage.png"
                                                />
                                                <img
                                                    alt="Concentration"
                                                    class="icon"
                                                    data-original-title="Concentration"
                                                    src="https://wiki.guildwars2.com/images/4/44/Boon_Duration.png"
                                                />
                                                <!-- -->
                                                <!-- -->
                                            </div>
                                            <div>
                                                <div>
                                                    <div>
                                                        <img
                                                            class="icon"
                                                            data-original-title="Sword"
                                                            src="https://render.guildwars2.com/file/3C4AA1BD79DAB49201C81D934AC7567B286E711B/631658.png"
                                                        />
                                                        <img
                                                            class="icon"
                                                            data-original-title="Sword"
                                                            src="https://render.guildwars2.com/file/3C4AA1BD79DAB49201C81D934AC7567B286E711B/631658.png"
                                                        />
                                                        <!-- -->
                                                    </div>
                                                    <!-- -->
                                                </div>
                                            </div>
                                            <div
                                                class="d-flex align-items-center justify-content-center"
                                            >
                                                <!-- -->
                                                <!-- -->
                                                <span
                                                    class="player-cell-shorten"
                                                    data-original-title="Sota Jarmo - Arzon.5629"
                                                >
                                                    Sota Jarmo
                                                </span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <ul class="nav nav-tabs">
                        <li>
                            <a class="nav-link"> General Stats </a>
                        </li>
                        <li>
                            <a class="nav-link"> Buffs </a>
                        </li>
                        <li>
                            <a class="nav-link"> Damage Modifiers </a>
                        </li>
                        <!-- -->
                        <li>
                            <a class="nav-link"> Graph </a>
                        </li>
                        <!-- -->
                        <li>
                            <a class="nav-link"> Targets Summary </a>
                        </li>
                        <li>
                            <a class="nav-link active"> Player Summary </a>
                        </li>
                    </ul>
                    <div>
                        <h3 class="text-center mt-2">
                            <img
                                alt="Paragon"
                                class="icon"
                                src="https://i.imgur.com/Wp4lhTM.png"
                            />
                            Sota Jarmo
                        </h3>
                        <ul class="nav nav-tabs">
                            <li>
                                <a class="nav-link"> Outgoing Damage </a>
                            </li>
                            <li>
                                <a class="nav-link"> Incoming Damage </a>
                            </li>
                            <li>
                                <a class="nav-link"> Graph </a>
                            </li>
                            <li>
                                <a class="nav-link"> Boon Status </a>
                            </li>
                            <li>
                                <a class="nav-link active"> Simple Rotation </a>
                            </li>
                            <li>
                                <a class="nav-link"> Advanced Rotation </a>
                            </li>
                            <li>
                                <a class="nav-link"> Consumables </a>
                            </li>
                            <li>
                                <a class="nav-link" style="display: none">
                                    Death Recap
                                </a>
                            </li>
                        </ul>
                        <div>
                            <div>
                                <div
                                    class="d-flex flex-row justify-content-center mt-1 mb-1"
                                >
                                    <ul
                                        class="d-flex flex-row justify-content-center nav nav-pills mr-1 scale85"
                                    >
                                        <li class="nav-item">
                                            <a class="nav-link active">
                                                Show auto attacks
                                            </a>
                                        </li>
                                        <li class="nav-item">
                                            <a class="nav-link">
                                                Hide interrupted auto attacks
                                            </a>
                                        </li>
                                        <li class="nav-item">
                                            <a class="nav-link active">
                                                Hide &lt; 10ms
                                            </a>
                                        </li>
                                    </ul>
                                    <ul
                                        class="d-flex flex-row justify-content-center nav nav-pills ml-1 mr-1 scale85"
                                    >
                                        <li class="nav-item">
                                            <a class="nav-link">
                                                Hide all instant cast
                                            </a>
                                        </li>
                                        <li class="nav-item">
                                            <a class="nav-link">
                                                Hide instant cast skills
                                            </a>
                                        </li>
                                        <li class="nav-item">
                                            <a class="nav-link">
                                                Hide gear procs
                                            </a>
                                        </li>
                                        <li class="nav-item">
                                            <a class="nav-link">
                                                Hide trait procs
                                            </a>
                                        </li>
                                        <!-- -->
                                    </ul>
                                    <ul
                                        class="d-flex flex-row justify-content-center nav nav-pills ml-1 scale85"
                                    >
                                        <li class="nav-item">
                                            <a class="nav-link">
                                                Small icons
                                            </a>
                                        </li>
                                        <li class="nav-item">
                                            <a class="nav-link active">
                                                Small auto attack icons
                                            </a>
                                        </li>
                                    </ul>
                                </div>
                                <div
                                    class="d-flex flex-row justify-content-center mt-1 mb-1"
                                >
                                    <ul class="nav nav-pills mr-1 ml-1 scale85">
                                        <li class="nav-item rot-animfull">
                                            <a
                                                class="nav-link active"
                                                data-original-title="Toggle full after cast border"
                                            >
                                                Full After Cast
                                            </a>
                                        </li>
                                        <li class="nav-item rot-cancelled">
                                            <a
                                                class="nav-link active"
                                                data-original-title="Toggle interrupted cast border"
                                            >
                                                Interrupted
                                            </a>
                                        </li>
                                        <li class="nav-item rot-instant">
                                            <a
                                                class="nav-link active"
                                                data-original-title="Toggle instant cast border"
                                            >
                                                Instant
                                            </a>
                                        </li>
                                        <li class="nav-item rot-unknown">
                                            <a
                                                class="nav-link active"
                                                data-original-title="Toggle unknown cast border"
                                            >
                                                Unknown
                                            </a>
                                        </li>
                                    </ul>
                                </div>
                                <div class="mb-4 mt-2" style="z-index: 1">
                                    <a
                                        class="dropdown-toggle"
                                        data-toggle="dropdown"
                                        href="#"
                                        style="font-size: 1.1em"
                                        title="Filter Skills"
                                    >
                                        Skills
                                        <span class="caret"> </span>
                                    </a>
                                    <ul
                                        class="dropdown-menu p-2 font-weight-normal scrollabledropdown"
                                        style="min-width: 165px"
                                    >
                                        <div
                                            class="d-flex flex-column justify-content-center align-items-center mb-1"
                                            style="
                                                border-bottom: 2px solid
                                                    rgb(187, 187, 187);
                                            "
                                        >
                                            <li>
                                                <button
                                                    class="btn btn-primary btn-sm"
                                                    style="
                                                        width: 160px;
                                                        padding: 0.4rem;
                                                    "
                                                    type="button"
                                                >
                                                    Select all
                                                </button>
                                            </li>
                                            <li class="mb-1">
                                                <button
                                                    class="btn btn-primary btn-sm"
                                                    style="
                                                        width: 160px;
                                                        padding: 0.4rem;
                                                    "
                                                    type="button"
                                                >
                                                    Deselect all
                                                </button>
                                            </li>
                                        </div>
                                        <li>
                                            <div style="width: max-content">
                                                <input
                                                    id="simple-rotation-player-0-0"
                                                    type="checkbox"
                                                />
                                                <label
                                                    for="simple-rotation-player-0-0"
                                                    style="
                                                        font-size: 1em;
                                                        white-space: nowrap;
                                                        margin-top: 2px;
                                                    "
                                                >
                                                    <img
                                                        class="icon"
                                                        src="https://render.guildwars2.com/file/A4D0D740CF360E0840EF76282843109C759C63A8/3680225.png"
                                                    />
                                                    Chant of Action
                                                </label>
                                            </div>
                                        </li>
                                        <li>
                                            <div style="width: max-content">
                                                <input
                                                    id="simple-rotation-player-1-0"
                                                    type="checkbox"
                                                />
                                                <label
                                                    for="simple-rotation-player-1-0"
                                                    style="
                                                        font-size: 1em;
                                                        white-space: nowrap;
                                                        margin-top: 2px;
                                                    "
                                                >
                                                    <img
                                                        class="icon"
                                                        src="https://render.guildwars2.com/file/71EB0DF5243A382A100E5ACB0870994D59BC47B7/103005.png"
                                                    />
                                                    Final Thrust
                                                </label>
                                            </div>
                                        </li>
                                        <li>
                                            <div style="width: max-content">
                                                <input
                                                    id="simple-rotation-player-2-0"
                                                    type="checkbox"
                                                />
                                                <label
                                                    for="simple-rotation-player-2-0"
                                                    style="
                                                        font-size: 1em;
                                                        white-space: nowrap;
                                                        margin-top: 2px;
                                                    "
                                                >
                                                    <img
                                                        class="icon"
                                                        src="https://render.guildwars2.com/file/4CEC34046638217807126F9BB1CADACB63E834D0/103014.png"
                                                    />
                                                    Flurry
                                                </label>
                                            </div>
                                        </li>
                                        <li>
                                            <div style="width: max-content">
                                                <input
                                                    id="simple-rotation-player-3-0"
                                                    type="checkbox"
                                                />
                                                <label
                                                    for="simple-rotation-player-3-0"
                                                    style="
                                                        font-size: 1em;
                                                        white-space: nowrap;
                                                        margin-top: 2px;
                                                    "
                                                >
                                                    <img
                                                        class="icon"
                                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                                    />
                                                    Gash
                                                </label>
                                            </div>
                                        </li>
                                        <li>
                                            <div style="width: max-content">
                                                <input
                                                    id="simple-rotation-player-4-0"
                                                    type="checkbox"
                                                />
                                                <label
                                                    for="simple-rotation-player-4-0"
                                                    style="
                                                        font-size: 1em;
                                                        white-space: nowrap;
                                                        margin-top: 2px;
                                                    "
                                                >
                                                    <img
                                                        class="icon"
                                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                                    />
                                                    Hamstring
                                                </label>
                                            </div>
                                        </li>
                                        <li>
                                            <div style="width: max-content">
                                                <input
                                                    id="simple-rotation-player-5-0"
                                                    type="checkbox"
                                                />
                                                <label
                                                    for="simple-rotation-player-5-0"
                                                    style="
                                                        font-size: 1em;
                                                        white-space: nowrap;
                                                        margin-top: 2px;
                                                    "
                                                >
                                                    <img
                                                        class="icon"
                                                        src="https://render.guildwars2.com/file/4876CF1E0673120898A5EEFE9D2409741E182EAE/103060.png"
                                                    />
                                                    Impale
                                                </label>
                                            </div>
                                        </li>
                                        <li>
                                            <div style="width: max-content">
                                                <input
                                                    id="simple-rotation-player-6-0"
                                                    type="checkbox"
                                                />
                                                <label
                                                    for="simple-rotation-player-6-0"
                                                    style="
                                                        font-size: 1em;
                                                        white-space: nowrap;
                                                        margin-top: 2px;
                                                    "
                                                >
                                                    <img
                                                        class="icon"
                                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                                    />
                                                    Sever Artery
                                                </label>
                                            </div>
                                        </li>
                                        <li>
                                            <div style="width: max-content">
                                                <input
                                                    id="simple-rotation-player-7-0"
                                                    type="checkbox"
                                                />
                                                <label
                                                    for="simple-rotation-player-7-0"
                                                    style="
                                                        font-size: 1em;
                                                        white-space: nowrap;
                                                        margin-top: 2px;
                                                    "
                                                >
                                                    <img
                                                        class="icon"
                                                        src="https://render.guildwars2.com/file/450973A6DE4D0BEE580256F5759F632B7EBC7ADD/103798.png"
                                                    />
                                                    Signet of Might
                                                </label>
                                            </div>
                                        </li>
                                        <li>
                                            <div style="width: max-content">
                                                <input
                                                    id="simple-rotation-player-8-0"
                                                    type="checkbox"
                                                />
                                                <label
                                                    for="simple-rotation-player-8-0"
                                                    style="
                                                        font-size: 1em;
                                                        white-space: nowrap;
                                                        margin-top: 2px;
                                                    "
                                                >
                                                    <img
                                                        class="icon"
                                                        src="https://render.guildwars2.com/file/7A530D5434F9E9E80ED14DBE48EEE90427E33A2B/104113.png"
                                                    />
                                                    Signet of Rage
                                                </label>
                                            </div>
                                        </li>
                                        <li>
                                            <div style="width: max-content">
                                                <input
                                                    id="simple-rotation-player-9-0"
                                                    type="checkbox"
                                                />
                                                <label
                                                    for="simple-rotation-player-9-0"
                                                    style="
                                                        font-size: 1em;
                                                        white-space: nowrap;
                                                        margin-top: 2px;
                                                    "
                                                >
                                                    <img
                                                        class="icon"
                                                        src="https://render.guildwars2.com/file/3763DF075356FE2A22A56915EB0B982B32F3FBA3/104128.png"
                                                    />
                                                    Signet of Stamina
                                                </label>
                                            </div>
                                        </li>
                                    </ul>
                                </div>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Flurry at -0.083s for 1317ms&lt;br&gt;Flurry cast 1 of 12&lt;br&gt;Skill cast 1 of 288"
                                        src="https://render.guildwars2.com/file/4CEC34046638217807126F9BB1CADACB63E834D0/103014.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon rot-animfull"
                                        data-original-title="Final Thrust at 1.234s for 363ms&lt;br&gt;Final Thrust cast 1 of 12&lt;br&gt;Skill cast 2 of 288"
                                        src="https://render.guildwars2.com/file/71EB0DF5243A382A100E5ACB0870994D59BC47B7/103005.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Impale at 1.597s for 360ms&lt;br&gt;Impale cast 1 of 10&lt;br&gt;Skill cast 3 of 288"
                                        src="https://render.guildwars2.com/file/4876CF1E0673120898A5EEFE9D2409741E182EAE/103060.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 1.957s for 280ms&lt;br&gt;Sever Artery cast 1 of 87&lt;br&gt;Skill cast 4 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 2.237s for 358ms&lt;br&gt;Gash cast 1 of 79&lt;br&gt;Skill cast 5 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 2.595s for 319ms&lt;br&gt;Hamstring cast 1 of 77&lt;br&gt;Skill cast 6 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 2.914s for 282ms&lt;br&gt;Sever Artery cast 2 of 87&lt;br&gt;Skill cast 7 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 3.196s for 357ms&lt;br&gt;Gash cast 2 of 79&lt;br&gt;Skill cast 8 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 3.553s for 323ms&lt;br&gt;Hamstring cast 2 of 77&lt;br&gt;Skill cast 9 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 3.876s for 286ms&lt;br&gt;Sever Artery cast 3 of 87&lt;br&gt;Skill cast 10 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 4.162s for 355ms&lt;br&gt;Gash cast 3 of 79&lt;br&gt;Skill cast 11 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 4.517s for 316ms&lt;br&gt;Hamstring cast 3 of 77&lt;br&gt;Skill cast 12 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 4.833s for 280ms&lt;br&gt;Sever Artery cast 4 of 87&lt;br&gt;Skill cast 13 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 5.113s for 364ms&lt;br&gt;Gash cast 4 of 79&lt;br&gt;Skill cast 14 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 5.478s for 317ms&lt;br&gt;Hamstring cast 4 of 77&lt;br&gt;Skill cast 15 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 5.795s for 278ms&lt;br&gt;Sever Artery cast 5 of 87&lt;br&gt;Skill cast 16 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 6.073s for 361ms&lt;br&gt;Gash cast 5 of 79&lt;br&gt;Skill cast 17 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 6.434s for 320ms&lt;br&gt;Hamstring cast 5 of 77&lt;br&gt;Skill cast 18 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 6.754s for 281ms&lt;br&gt;Sever Artery cast 6 of 87&lt;br&gt;Skill cast 19 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 7.035s for 362ms&lt;br&gt;Gash cast 6 of 79&lt;br&gt;Skill cast 20 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 7.397s for 321ms&lt;br&gt;Hamstring cast 6 of 77&lt;br&gt;Skill cast 21 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Flurry at 7.718s for 1316ms&lt;br&gt;Flurry cast 2 of 12&lt;br&gt;Skill cast 22 of 288"
                                        src="https://render.guildwars2.com/file/4CEC34046638217807126F9BB1CADACB63E834D0/103014.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 9.034s for 283ms&lt;br&gt;Sever Artery cast 7 of 87&lt;br&gt;Skill cast 23 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 9.317s for 356ms&lt;br&gt;Gash cast 7 of 79&lt;br&gt;Skill cast 24 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 9.673s for 285ms&lt;br&gt;Hamstring cast 7 of 77&lt;br&gt;Skill cast 25 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon rot-animfull"
                                        data-original-title="Final Thrust at 9.996s for 360ms&lt;br&gt;Final Thrust cast 2 of 12&lt;br&gt;Skill cast 26 of 288"
                                        src="https://render.guildwars2.com/file/71EB0DF5243A382A100E5ACB0870994D59BC47B7/103005.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 10.356s for 282ms&lt;br&gt;Sever Artery cast 8 of 87&lt;br&gt;Skill cast 27 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 10.638s for 360ms&lt;br&gt;Gash cast 8 of 79&lt;br&gt;Skill cast 28 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 10.998s for 320ms&lt;br&gt;Hamstring cast 8 of 77&lt;br&gt;Skill cast 29 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 11.318s for 276ms&lt;br&gt;Sever Artery cast 9 of 87&lt;br&gt;Skill cast 30 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 11.594s for 360ms&lt;br&gt;Gash cast 9 of 79&lt;br&gt;Skill cast 31 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 11.954s for 320ms&lt;br&gt;Hamstring cast 9 of 77&lt;br&gt;Skill cast 32 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Impale at 12.317s for 356ms&lt;br&gt;Impale cast 2 of 10&lt;br&gt;Skill cast 33 of 288"
                                        src="https://render.guildwars2.com/file/4876CF1E0673120898A5EEFE9D2409741E182EAE/103060.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 12.673s for 283ms&lt;br&gt;Sever Artery cast 10 of 87&lt;br&gt;Skill cast 34 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 12.956s for 362ms&lt;br&gt;Gash cast 10 of 79&lt;br&gt;Skill cast 35 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 13.318s for 319ms&lt;br&gt;Hamstring cast 10 of 77&lt;br&gt;Skill cast 36 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 13.637s for 281ms&lt;br&gt;Sever Artery cast 11 of 87&lt;br&gt;Skill cast 37 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 13.918s for 359ms&lt;br&gt;Gash cast 11 of 79&lt;br&gt;Skill cast 38 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 14.277s for 319ms&lt;br&gt;Hamstring cast 11 of 77&lt;br&gt;Skill cast 39 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 14.596s for 281ms&lt;br&gt;Sever Artery cast 12 of 87&lt;br&gt;Skill cast 40 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 14.877s for 356ms&lt;br&gt;Gash cast 12 of 79&lt;br&gt;Skill cast 41 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 15.233s for 320ms&lt;br&gt;Hamstring cast 12 of 77&lt;br&gt;Skill cast 42 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 15.553s for 283ms&lt;br&gt;Sever Artery cast 13 of 87&lt;br&gt;Skill cast 43 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 15.836s for 362ms&lt;br&gt;Gash cast 13 of 79&lt;br&gt;Skill cast 44 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 16.198s for 279ms&lt;br&gt;Hamstring cast 13 of 77&lt;br&gt;Skill cast 45 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Flurry at 16.515s for 1317ms&lt;br&gt;Flurry cast 3 of 12&lt;br&gt;Skill cast 46 of 288"
                                        src="https://render.guildwars2.com/file/4CEC34046638217807126F9BB1CADACB63E834D0/103014.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon rot-instant"
                                        data-original-title="Signet of Stamina at 16.716s&lt;br&gt;Signet of Stamina cast 1 of 5&lt;br&gt;Skill cast 47 of 288"
                                        src="https://render.guildwars2.com/file/3763DF075356FE2A22A56915EB0B982B32F3FBA3/104128.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 17.832s for 282ms&lt;br&gt;Sever Artery cast 14 of 87&lt;br&gt;Skill cast 48 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 18.114s for 362ms&lt;br&gt;Gash cast 14 of 79&lt;br&gt;Skill cast 49 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 18.476s for 282ms&lt;br&gt;Hamstring cast 14 of 77&lt;br&gt;Skill cast 50 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon rot-animfull"
                                        data-original-title="Final Thrust at 18.796s for 361ms&lt;br&gt;Final Thrust cast 3 of 12&lt;br&gt;Skill cast 51 of 288"
                                        src="https://render.guildwars2.com/file/71EB0DF5243A382A100E5ACB0870994D59BC47B7/103005.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 19.157s for 277ms&lt;br&gt;Sever Artery cast 15 of 87&lt;br&gt;Skill cast 52 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 19.434s for 360ms&lt;br&gt;Gash cast 15 of 79&lt;br&gt;Skill cast 53 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 19.794s for 323ms&lt;br&gt;Hamstring cast 15 of 77&lt;br&gt;Skill cast 54 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 20.117s for 280ms&lt;br&gt;Sever Artery cast 16 of 87&lt;br&gt;Skill cast 55 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 20.397s for 358ms&lt;br&gt;Gash cast 16 of 79&lt;br&gt;Skill cast 56 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 20.755s for 320ms&lt;br&gt;Hamstring cast 16 of 77&lt;br&gt;Skill cast 57 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 21.075s for 281ms&lt;br&gt;Sever Artery cast 17 of 87&lt;br&gt;Skill cast 58 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 21.356s for 361ms&lt;br&gt;Gash cast 17 of 79&lt;br&gt;Skill cast 59 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 21.717s for 317ms&lt;br&gt;Hamstring cast 17 of 77&lt;br&gt;Skill cast 60 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 22.034s for 283ms&lt;br&gt;Sever Artery cast 18 of 87&lt;br&gt;Skill cast 61 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 22.317s for 356ms&lt;br&gt;Gash cast 18 of 79&lt;br&gt;Skill cast 62 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 22.673s for 285ms&lt;br&gt;Hamstring cast 18 of 77&lt;br&gt;Skill cast 63 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Impale at 22.998s for 360ms&lt;br&gt;Impale cast 3 of 10&lt;br&gt;Skill cast 64 of 288"
                                        src="https://render.guildwars2.com/file/4876CF1E0673120898A5EEFE9D2409741E182EAE/103060.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 23.358s for 278ms&lt;br&gt;Sever Artery cast 19 of 87&lt;br&gt;Skill cast 65 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 23.636s for 360ms&lt;br&gt;Gash cast 19 of 79&lt;br&gt;Skill cast 66 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 23.996s for 320ms&lt;br&gt;Hamstring cast 19 of 77&lt;br&gt;Skill cast 67 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 24.316s for 280ms&lt;br&gt;Sever Artery cast 20 of 87&lt;br&gt;Skill cast 68 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 24.596s for 359ms&lt;br&gt;Gash cast 20 of 79&lt;br&gt;Skill cast 69 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 24.955s for 320ms&lt;br&gt;Hamstring cast 20 of 77&lt;br&gt;Skill cast 70 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Flurry at 25.317s for 1315ms&lt;br&gt;Flurry cast 4 of 12&lt;br&gt;Skill cast 71 of 288"
                                        src="https://render.guildwars2.com/file/4CEC34046638217807126F9BB1CADACB63E834D0/103014.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 26.632s for 284ms&lt;br&gt;Sever Artery cast 21 of 87&lt;br&gt;Skill cast 72 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 26.916s for 361ms&lt;br&gt;Gash cast 21 of 79&lt;br&gt;Skill cast 73 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 27.277s for 319ms&lt;br&gt;Hamstring cast 21 of 77&lt;br&gt;Skill cast 74 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon rot-animfull"
                                        data-original-title="Final Thrust at 27.596s for 359ms&lt;br&gt;Final Thrust cast 4 of 12&lt;br&gt;Skill cast 75 of 288"
                                        src="https://render.guildwars2.com/file/71EB0DF5243A382A100E5ACB0870994D59BC47B7/103005.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 27.955s for 279ms&lt;br&gt;Sever Artery cast 22 of 87&lt;br&gt;Skill cast 76 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 28.234s for 362ms&lt;br&gt;Gash cast 22 of 79&lt;br&gt;Skill cast 77 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 28.596s for 320ms&lt;br&gt;Hamstring cast 22 of 77&lt;br&gt;Skill cast 78 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 28.916s for 280ms&lt;br&gt;Sever Artery cast 23 of 87&lt;br&gt;Skill cast 79 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 29.196s for 359ms&lt;br&gt;Gash cast 23 of 79&lt;br&gt;Skill cast 80 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 29.555s for 319ms&lt;br&gt;Hamstring cast 23 of 77&lt;br&gt;Skill cast 81 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 29.874s for 283ms&lt;br&gt;Sever Artery cast 24 of 87&lt;br&gt;Skill cast 82 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 30.157s for 359ms&lt;br&gt;Gash cast 24 of 79&lt;br&gt;Skill cast 83 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 30.516s for 318ms&lt;br&gt;Hamstring cast 24 of 77&lt;br&gt;Skill cast 84 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 30.834s for 279ms&lt;br&gt;Sever Artery cast 25 of 87&lt;br&gt;Skill cast 85 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 31.113s for 365ms&lt;br&gt;Gash cast 25 of 79&lt;br&gt;Skill cast 86 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 31.478s for 196ms&lt;br&gt;Hamstring cast 25 of 77&lt;br&gt;Skill cast 87 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Signet of Rage at 31.752s for 166ms&lt;br&gt;Signet of Rage cast 1 of 1&lt;br&gt;Skill cast 88 of 288"
                                        src="https://render.guildwars2.com/file/7A530D5434F9E9E80ED14DBE48EEE90427E33A2B/104113.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 31.918s for 277ms&lt;br&gt;Sever Artery cast 26 of 87&lt;br&gt;Skill cast 89 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 32.195s for 362ms&lt;br&gt;Gash cast 26 of 79&lt;br&gt;Skill cast 90 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 32.557s for 320ms&lt;br&gt;Hamstring cast 26 of 77&lt;br&gt;Skill cast 91 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 32.877s for 278ms&lt;br&gt;Sever Artery cast 27 of 87&lt;br&gt;Skill cast 92 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 33.155s for 357ms&lt;br&gt;Gash cast 27 of 79&lt;br&gt;Skill cast 93 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 33.512s for 243ms&lt;br&gt;Hamstring cast 27 of 77&lt;br&gt;Skill cast 94 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Impale at 33.755s for 359ms&lt;br&gt;Impale cast 4 of 10&lt;br&gt;Skill cast 95 of 288"
                                        src="https://render.guildwars2.com/file/4876CF1E0673120898A5EEFE9D2409741E182EAE/103060.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon rot-cancelled"
                                        data-original-title="Sever Artery at 34.114s for 40ms&lt;br&gt;Sever Artery cast 28 of 87&lt;br&gt;Skill cast 96 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Flurry at 34.154s for 1323ms&lt;br&gt;Flurry cast 5 of 12&lt;br&gt;Skill cast 97 of 288"
                                        src="https://render.guildwars2.com/file/4CEC34046638217807126F9BB1CADACB63E834D0/103014.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon rot-instant"
                                        data-original-title="Signet of Stamina at 34.598s&lt;br&gt;Signet of Stamina cast 2 of 5&lt;br&gt;Skill cast 98 of 288"
                                        src="https://render.guildwars2.com/file/3763DF075356FE2A22A56915EB0B982B32F3FBA3/104128.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 35.477s for 277ms&lt;br&gt;Sever Artery cast 29 of 87&lt;br&gt;Skill cast 99 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon rot-cancelled"
                                        data-original-title="Gash at 35.754s for 81ms&lt;br&gt;Gash cast 28 of 79&lt;br&gt;Skill cast 100 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon rot-animfull"
                                        data-original-title="Final Thrust at 35.835s for 363ms&lt;br&gt;Final Thrust cast 5 of 12&lt;br&gt;Skill cast 101 of 288"
                                        src="https://render.guildwars2.com/file/71EB0DF5243A382A100E5ACB0870994D59BC47B7/103005.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 36.198s for 276ms&lt;br&gt;Sever Artery cast 30 of 87&lt;br&gt;Skill cast 102 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 36.474s for 359ms&lt;br&gt;Gash cast 29 of 79&lt;br&gt;Skill cast 103 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 36.833s for 244ms&lt;br&gt;Hamstring cast 28 of 77&lt;br&gt;Skill cast 104 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon rot-animfull"
                                        data-original-title="Chant of Action at 37.077s for 240ms&lt;br&gt;Chant of Action cast 1 of 2&lt;br&gt;Skill cast 105 of 288"
                                        src="https://render.guildwars2.com/file/A4D0D740CF360E0840EF76282843109C759C63A8/3680225.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 37.317s for 281ms&lt;br&gt;Sever Artery cast 31 of 87&lt;br&gt;Skill cast 106 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 37.598s for 359ms&lt;br&gt;Gash cast 30 of 79&lt;br&gt;Skill cast 107 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 37.957s for 319ms&lt;br&gt;Hamstring cast 29 of 77&lt;br&gt;Skill cast 108 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 38.276s for 280ms&lt;br&gt;Sever Artery cast 32 of 87&lt;br&gt;Skill cast 109 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 38.556s for 361ms&lt;br&gt;Gash cast 31 of 79&lt;br&gt;Skill cast 110 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 38.917s for 321ms&lt;br&gt;Hamstring cast 30 of 77&lt;br&gt;Skill cast 111 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 39.238s for 276ms&lt;br&gt;Sever Artery cast 33 of 87&lt;br&gt;Skill cast 112 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 39.514s for 359ms&lt;br&gt;Gash cast 32 of 79&lt;br&gt;Skill cast 113 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 39.873s for 323ms&lt;br&gt;Hamstring cast 31 of 77&lt;br&gt;Skill cast 114 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 40.196s for 277ms&lt;br&gt;Sever Artery cast 34 of 87&lt;br&gt;Skill cast 115 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 40.473s for 363ms&lt;br&gt;Gash cast 33 of 79&lt;br&gt;Skill cast 116 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 40.836s for 321ms&lt;br&gt;Hamstring cast 32 of 77&lt;br&gt;Skill cast 117 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 41.157s for 278ms&lt;br&gt;Sever Artery cast 35 of 87&lt;br&gt;Skill cast 118 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 41.435s for 359ms&lt;br&gt;Gash cast 34 of 79&lt;br&gt;Skill cast 119 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 41.794s for 322ms&lt;br&gt;Hamstring cast 33 of 77&lt;br&gt;Skill cast 120 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon rot-cancelled"
                                        data-original-title="Sever Artery at 42.116s for 39ms&lt;br&gt;Sever Artery cast 36 of 87&lt;br&gt;Skill cast 121 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Flurry at 42.155s for 1322ms&lt;br&gt;Flurry cast 6 of 12&lt;br&gt;Skill cast 122 of 288"
                                        src="https://render.guildwars2.com/file/4CEC34046638217807126F9BB1CADACB63E834D0/103014.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 43.477s for 279ms&lt;br&gt;Sever Artery cast 37 of 87&lt;br&gt;Skill cast 123 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 43.756s for 363ms&lt;br&gt;Gash cast 35 of 79&lt;br&gt;Skill cast 124 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 44.119s for 315ms&lt;br&gt;Hamstring cast 34 of 77&lt;br&gt;Skill cast 125 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon rot-animfull"
                                        data-original-title="Final Thrust at 44.478s for 356ms&lt;br&gt;Final Thrust cast 6 of 12&lt;br&gt;Skill cast 126 of 288"
                                        src="https://render.guildwars2.com/file/71EB0DF5243A382A100E5ACB0870994D59BC47B7/103005.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Impale at 44.834s for 363ms&lt;br&gt;Impale cast 5 of 10&lt;br&gt;Skill cast 127 of 288"
                                        src="https://render.guildwars2.com/file/4876CF1E0673120898A5EEFE9D2409741E182EAE/103060.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 45.197s for 281ms&lt;br&gt;Sever Artery cast 38 of 87&lt;br&gt;Skill cast 128 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 45.478s for 355ms&lt;br&gt;Gash cast 36 of 79&lt;br&gt;Skill cast 129 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 45.833s for 325ms&lt;br&gt;Hamstring cast 35 of 77&lt;br&gt;Skill cast 130 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 46.158s for 279ms&lt;br&gt;Sever Artery cast 39 of 87&lt;br&gt;Skill cast 131 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 46.437s for 357ms&lt;br&gt;Gash cast 37 of 79&lt;br&gt;Skill cast 132 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 46.794s for 324ms&lt;br&gt;Hamstring cast 36 of 77&lt;br&gt;Skill cast 133 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 47.118s for 277ms&lt;br&gt;Sever Artery cast 40 of 87&lt;br&gt;Skill cast 134 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 47.395s for 359ms&lt;br&gt;Gash cast 38 of 79&lt;br&gt;Skill cast 135 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 47.754s for 324ms&lt;br&gt;Hamstring cast 37 of 77&lt;br&gt;Skill cast 136 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 48.078s for 278ms&lt;br&gt;Sever Artery cast 41 of 87&lt;br&gt;Skill cast 137 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 48.356s for 359ms&lt;br&gt;Gash cast 39 of 79&lt;br&gt;Skill cast 138 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 48.715s for 319ms&lt;br&gt;Hamstring cast 38 of 77&lt;br&gt;Skill cast 139 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 49.034s for 283ms&lt;br&gt;Sever Artery cast 42 of 87&lt;br&gt;Skill cast 140 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 49.317s for 356ms&lt;br&gt;Gash cast 40 of 79&lt;br&gt;Skill cast 141 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 49.673s for 322ms&lt;br&gt;Hamstring cast 39 of 77&lt;br&gt;Skill cast 142 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 49.995s for 279ms&lt;br&gt;Sever Artery cast 43 of 87&lt;br&gt;Skill cast 143 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 50.274s for 359ms&lt;br&gt;Gash cast 41 of 79&lt;br&gt;Skill cast 144 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 50.633s for 324ms&lt;br&gt;Hamstring cast 40 of 77&lt;br&gt;Skill cast 145 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon rot-cancelled"
                                        data-original-title="Sever Artery at 50.957s for 38ms&lt;br&gt;Sever Artery cast 44 of 87&lt;br&gt;Skill cast 146 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Flurry at 50.995s for 1322ms&lt;br&gt;Flurry cast 7 of 12&lt;br&gt;Skill cast 147 of 288"
                                        src="https://render.guildwars2.com/file/4CEC34046638217807126F9BB1CADACB63E834D0/103014.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon rot-instant"
                                        data-original-title="Signet of Stamina at 51.315s&lt;br&gt;Signet of Stamina cast 3 of 5&lt;br&gt;Skill cast 148 of 288"
                                        src="https://render.guildwars2.com/file/3763DF075356FE2A22A56915EB0B982B32F3FBA3/104128.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 52.317s for 277ms&lt;br&gt;Sever Artery cast 45 of 87&lt;br&gt;Skill cast 149 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 52.594s for 363ms&lt;br&gt;Gash cast 42 of 79&lt;br&gt;Skill cast 150 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon rot-instant"
                                        data-original-title="Signet of Might at 52.836s&lt;br&gt;Signet of Might cast 1 of 3&lt;br&gt;Skill cast 151 of 288"
                                        src="https://render.guildwars2.com/file/450973A6DE4D0BEE580256F5759F632B7EBC7ADD/103798.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 52.957s for 278ms&lt;br&gt;Hamstring cast 41 of 77&lt;br&gt;Skill cast 152 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon rot-animfull"
                                        data-original-title="Final Thrust at 53.274s for 365ms&lt;br&gt;Final Thrust cast 7 of 12&lt;br&gt;Skill cast 153 of 288"
                                        src="https://render.guildwars2.com/file/71EB0DF5243A382A100E5ACB0870994D59BC47B7/103005.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 53.639s for 278ms&lt;br&gt;Sever Artery cast 46 of 87&lt;br&gt;Skill cast 154 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 53.917s for 360ms&lt;br&gt;Gash cast 43 of 79&lt;br&gt;Skill cast 155 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 54.277s for 318ms&lt;br&gt;Hamstring cast 42 of 77&lt;br&gt;Skill cast 156 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 54.595s for 278ms&lt;br&gt;Sever Artery cast 47 of 87&lt;br&gt;Skill cast 157 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 54.873s for 361ms&lt;br&gt;Gash cast 44 of 79&lt;br&gt;Skill cast 158 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 55.234s for 239ms&lt;br&gt;Hamstring cast 43 of 77&lt;br&gt;Skill cast 159 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Impale at 55.473s for 361ms&lt;br&gt;Impale cast 6 of 10&lt;br&gt;Skill cast 160 of 288"
                                        src="https://render.guildwars2.com/file/4876CF1E0673120898A5EEFE9D2409741E182EAE/103060.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 55.834s for 279ms&lt;br&gt;Sever Artery cast 48 of 87&lt;br&gt;Skill cast 161 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 56.113s for 362ms&lt;br&gt;Gash cast 45 of 79&lt;br&gt;Skill cast 162 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 56.475s for 319ms&lt;br&gt;Hamstring cast 44 of 77&lt;br&gt;Skill cast 163 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 56.794s for 280ms&lt;br&gt;Sever Artery cast 49 of 87&lt;br&gt;Skill cast 164 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 57.074s for 359ms&lt;br&gt;Gash cast 46 of 79&lt;br&gt;Skill cast 165 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 57.433s for 323ms&lt;br&gt;Hamstring cast 45 of 77&lt;br&gt;Skill cast 166 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 57.756s for 276ms&lt;br&gt;Sever Artery cast 50 of 87&lt;br&gt;Skill cast 167 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 58.032s for 365ms&lt;br&gt;Gash cast 47 of 79&lt;br&gt;Skill cast 168 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 58.397s for 319ms&lt;br&gt;Hamstring cast 46 of 77&lt;br&gt;Skill cast 169 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 58.716s for 282ms&lt;br&gt;Sever Artery cast 51 of 87&lt;br&gt;Skill cast 170 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 58.998s for 358ms&lt;br&gt;Gash cast 48 of 79&lt;br&gt;Skill cast 171 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 59.356s for 321ms&lt;br&gt;Hamstring cast 47 of 77&lt;br&gt;Skill cast 172 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon rot-cancelled"
                                        data-original-title="Sever Artery at 59.677s for 38ms&lt;br&gt;Sever Artery cast 52 of 87&lt;br&gt;Skill cast 173 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Flurry at 59.715s for 1319ms&lt;br&gt;Flurry cast 8 of 12&lt;br&gt;Skill cast 174 of 288"
                                        src="https://render.guildwars2.com/file/4CEC34046638217807126F9BB1CADACB63E834D0/103014.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 61.034s for 279ms&lt;br&gt;Sever Artery cast 53 of 87&lt;br&gt;Skill cast 175 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 61.313s for 362ms&lt;br&gt;Gash cast 49 of 79&lt;br&gt;Skill cast 176 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 61.675s for 319ms&lt;br&gt;Hamstring cast 48 of 77&lt;br&gt;Skill cast 177 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon rot-animfull"
                                        data-original-title="Final Thrust at 62.033s for 363ms&lt;br&gt;Final Thrust cast 8 of 12&lt;br&gt;Skill cast 178 of 288"
                                        src="https://render.guildwars2.com/file/71EB0DF5243A382A100E5ACB0870994D59BC47B7/103005.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 62.396s for 276ms&lt;br&gt;Sever Artery cast 54 of 87&lt;br&gt;Skill cast 179 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 62.672s for 363ms&lt;br&gt;Gash cast 50 of 79&lt;br&gt;Skill cast 180 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 63.035s for 318ms&lt;br&gt;Hamstring cast 49 of 77&lt;br&gt;Skill cast 181 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 63.353s for 284ms&lt;br&gt;Sever Artery cast 55 of 87&lt;br&gt;Skill cast 182 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 63.637s for 358ms&lt;br&gt;Gash cast 51 of 79&lt;br&gt;Skill cast 183 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 63.995s for 317ms&lt;br&gt;Hamstring cast 50 of 77&lt;br&gt;Skill cast 184 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 64.312s for 284ms&lt;br&gt;Sever Artery cast 56 of 87&lt;br&gt;Skill cast 185 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 64.596s for 357ms&lt;br&gt;Gash cast 52 of 79&lt;br&gt;Skill cast 186 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 64.953s for 319ms&lt;br&gt;Hamstring cast 51 of 77&lt;br&gt;Skill cast 187 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 65.272s for 283ms&lt;br&gt;Sever Artery cast 57 of 87&lt;br&gt;Skill cast 188 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 65.555s for 362ms&lt;br&gt;Gash cast 53 of 79&lt;br&gt;Skill cast 189 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 65.917s for 317ms&lt;br&gt;Hamstring cast 52 of 77&lt;br&gt;Skill cast 190 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Impale at 66.272s for 359ms&lt;br&gt;Impale cast 7 of 10&lt;br&gt;Skill cast 191 of 288"
                                        src="https://render.guildwars2.com/file/4876CF1E0673120898A5EEFE9D2409741E182EAE/103060.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 66.631s for 285ms&lt;br&gt;Sever Artery cast 58 of 87&lt;br&gt;Skill cast 192 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 66.916s for 362ms&lt;br&gt;Gash cast 54 of 79&lt;br&gt;Skill cast 193 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 67.278s for 316ms&lt;br&gt;Hamstring cast 53 of 77&lt;br&gt;Skill cast 194 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 67.594s for 79ms&lt;br&gt;Sever Artery cast 59 of 87&lt;br&gt;Skill cast 195 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Flurry at 67.673s for 1323ms&lt;br&gt;Flurry cast 9 of 12&lt;br&gt;Skill cast 196 of 288"
                                        src="https://render.guildwars2.com/file/4CEC34046638217807126F9BB1CADACB63E834D0/103014.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon rot-instant"
                                        data-original-title="Signet of Might at 68.836s&lt;br&gt;Signet of Might cast 2 of 3&lt;br&gt;Skill cast 197 of 288"
                                        src="https://render.guildwars2.com/file/450973A6DE4D0BEE580256F5759F632B7EBC7ADD/103798.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon rot-animfull"
                                        data-original-title="Chant of Action at 68.996s for 237ms&lt;br&gt;Chant of Action cast 2 of 2&lt;br&gt;Skill cast 198 of 288"
                                        src="https://render.guildwars2.com/file/A4D0D740CF360E0840EF76282843109C759C63A8/3680225.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon rot-instant"
                                        data-original-title="Signet of Stamina at 69.074s&lt;br&gt;Signet of Stamina cast 4 of 5&lt;br&gt;Skill cast 199 of 288"
                                        src="https://render.guildwars2.com/file/3763DF075356FE2A22A56915EB0B982B32F3FBA3/104128.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 69.233s for 282ms&lt;br&gt;Sever Artery cast 60 of 87&lt;br&gt;Skill cast 200 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 69.515s for 361ms&lt;br&gt;Gash cast 55 of 79&lt;br&gt;Skill cast 201 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 69.876s for 321ms&lt;br&gt;Hamstring cast 54 of 77&lt;br&gt;Skill cast 202 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon rot-animfull"
                                        data-original-title="Final Thrust at 70.239s for 357ms&lt;br&gt;Final Thrust cast 9 of 12&lt;br&gt;Skill cast 203 of 288"
                                        src="https://render.guildwars2.com/file/71EB0DF5243A382A100E5ACB0870994D59BC47B7/103005.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 70.596s for 280ms&lt;br&gt;Sever Artery cast 61 of 87&lt;br&gt;Skill cast 204 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 70.876s for 359ms&lt;br&gt;Gash cast 56 of 79&lt;br&gt;Skill cast 205 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 71.235s for 319ms&lt;br&gt;Hamstring cast 55 of 77&lt;br&gt;Skill cast 206 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 71.554s for 279ms&lt;br&gt;Sever Artery cast 62 of 87&lt;br&gt;Skill cast 207 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 71.833s for 360ms&lt;br&gt;Gash cast 57 of 79&lt;br&gt;Skill cast 208 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 72.193s for 319ms&lt;br&gt;Hamstring cast 56 of 77&lt;br&gt;Skill cast 209 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 72.512s for 284ms&lt;br&gt;Sever Artery cast 63 of 87&lt;br&gt;Skill cast 210 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 72.796s for 360ms&lt;br&gt;Gash cast 58 of 79&lt;br&gt;Skill cast 211 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 73.156s for 322ms&lt;br&gt;Hamstring cast 57 of 77&lt;br&gt;Skill cast 212 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 73.478s for 274ms&lt;br&gt;Sever Artery cast 64 of 87&lt;br&gt;Skill cast 213 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 73.752s for 359ms&lt;br&gt;Gash cast 59 of 79&lt;br&gt;Skill cast 214 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 74.111s for 322ms&lt;br&gt;Hamstring cast 58 of 77&lt;br&gt;Skill cast 215 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 74.433s for 283ms&lt;br&gt;Sever Artery cast 65 of 87&lt;br&gt;Skill cast 216 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 74.716s for 355ms&lt;br&gt;Gash cast 60 of 79&lt;br&gt;Skill cast 217 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 75.071s for 322ms&lt;br&gt;Hamstring cast 59 of 77&lt;br&gt;Skill cast 218 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 75.393s for 280ms&lt;br&gt;Sever Artery cast 66 of 87&lt;br&gt;Skill cast 219 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 75.673s for 361ms&lt;br&gt;Gash cast 61 of 79&lt;br&gt;Skill cast 220 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 76.034s for 319ms&lt;br&gt;Hamstring cast 60 of 77&lt;br&gt;Skill cast 221 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon rot-cancelled"
                                        data-original-title="Sever Artery at 76.353s for 44ms&lt;br&gt;Sever Artery cast 67 of 87&lt;br&gt;Skill cast 222 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Flurry at 76.397s for 1317ms&lt;br&gt;Flurry cast 10 of 12&lt;br&gt;Skill cast 223 of 288"
                                        src="https://render.guildwars2.com/file/4CEC34046638217807126F9BB1CADACB63E834D0/103014.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Impale at 77.714s for 364ms&lt;br&gt;Impale cast 8 of 10&lt;br&gt;Skill cast 224 of 288"
                                        src="https://render.guildwars2.com/file/4876CF1E0673120898A5EEFE9D2409741E182EAE/103060.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 78.078s for 276ms&lt;br&gt;Sever Artery cast 68 of 87&lt;br&gt;Skill cast 225 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 78.354s for 158ms&lt;br&gt;Gash cast 62 of 79&lt;br&gt;Skill cast 226 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon rot-animfull"
                                        data-original-title="Final Thrust at 78.512s for 360ms&lt;br&gt;Final Thrust cast 10 of 12&lt;br&gt;Skill cast 227 of 288"
                                        src="https://render.guildwars2.com/file/71EB0DF5243A382A100E5ACB0870994D59BC47B7/103005.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 78.872s for 283ms&lt;br&gt;Sever Artery cast 69 of 87&lt;br&gt;Skill cast 228 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 79.155s for 361ms&lt;br&gt;Gash cast 63 of 79&lt;br&gt;Skill cast 229 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 79.516s for 318ms&lt;br&gt;Hamstring cast 61 of 77&lt;br&gt;Skill cast 230 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 79.834s for 282ms&lt;br&gt;Sever Artery cast 70 of 87&lt;br&gt;Skill cast 231 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 80.116s for 356ms&lt;br&gt;Gash cast 64 of 79&lt;br&gt;Skill cast 232 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 80.472s for 323ms&lt;br&gt;Hamstring cast 62 of 77&lt;br&gt;Skill cast 233 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 80.795s for 278ms&lt;br&gt;Sever Artery cast 71 of 87&lt;br&gt;Skill cast 234 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 81.073s for 362ms&lt;br&gt;Gash cast 65 of 79&lt;br&gt;Skill cast 235 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 81.435s for 317ms&lt;br&gt;Hamstring cast 63 of 77&lt;br&gt;Skill cast 236 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 81.752s for 285ms&lt;br&gt;Sever Artery cast 72 of 87&lt;br&gt;Skill cast 237 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 82.037s for 357ms&lt;br&gt;Gash cast 66 of 79&lt;br&gt;Skill cast 238 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 82.394s for 321ms&lt;br&gt;Hamstring cast 64 of 77&lt;br&gt;Skill cast 239 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 82.716s for 277ms&lt;br&gt;Sever Artery cast 73 of 87&lt;br&gt;Skill cast 240 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 82.993s for 362ms&lt;br&gt;Gash cast 67 of 79&lt;br&gt;Skill cast 241 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 83.355s for 316ms&lt;br&gt;Hamstring cast 65 of 77&lt;br&gt;Skill cast 242 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 83.671s for 285ms&lt;br&gt;Sever Artery cast 74 of 87&lt;br&gt;Skill cast 243 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 83.956s for 361ms&lt;br&gt;Gash cast 68 of 79&lt;br&gt;Skill cast 244 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 84.317s for 320ms&lt;br&gt;Hamstring cast 66 of 77&lt;br&gt;Skill cast 245 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Flurry at 84.673s for 1323ms&lt;br&gt;Flurry cast 11 of 12&lt;br&gt;Skill cast 246 of 288"
                                        src="https://render.guildwars2.com/file/4CEC34046638217807126F9BB1CADACB63E834D0/103014.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon rot-instant"
                                        data-original-title="Signet of Might at 84.914s&lt;br&gt;Signet of Might cast 3 of 3&lt;br&gt;Skill cast 247 of 288"
                                        src="https://render.guildwars2.com/file/450973A6DE4D0BEE580256F5759F632B7EBC7ADD/103798.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon rot-instant"
                                        data-original-title="Signet of Stamina at 85.195s&lt;br&gt;Signet of Stamina cast 5 of 5&lt;br&gt;Skill cast 248 of 288"
                                        src="https://render.guildwars2.com/file/3763DF075356FE2A22A56915EB0B982B32F3FBA3/104128.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 85.996s for 280ms&lt;br&gt;Sever Artery cast 75 of 87&lt;br&gt;Skill cast 249 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 86.276s for 357ms&lt;br&gt;Gash cast 69 of 79&lt;br&gt;Skill cast 250 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 86.633s for 319ms&lt;br&gt;Hamstring cast 67 of 77&lt;br&gt;Skill cast 251 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 86.952s for 83ms&lt;br&gt;Sever Artery cast 76 of 87&lt;br&gt;Skill cast 252 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon rot-animfull"
                                        data-original-title="Final Thrust at 87.035s for 362ms&lt;br&gt;Final Thrust cast 11 of 12&lt;br&gt;Skill cast 253 of 288"
                                        src="https://render.guildwars2.com/file/71EB0DF5243A382A100E5ACB0870994D59BC47B7/103005.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 87.397s for 278ms&lt;br&gt;Sever Artery cast 77 of 87&lt;br&gt;Skill cast 254 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 87.675s for 358ms&lt;br&gt;Gash cast 70 of 79&lt;br&gt;Skill cast 255 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 88.033s for 283ms&lt;br&gt;Hamstring cast 68 of 77&lt;br&gt;Skill cast 256 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Impale at 88.354s for 362ms&lt;br&gt;Impale cast 9 of 10&lt;br&gt;Skill cast 257 of 288"
                                        src="https://render.guildwars2.com/file/4876CF1E0673120898A5EEFE9D2409741E182EAE/103060.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 88.716s for 277ms&lt;br&gt;Sever Artery cast 78 of 87&lt;br&gt;Skill cast 258 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 88.993s for 363ms&lt;br&gt;Gash cast 71 of 79&lt;br&gt;Skill cast 259 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 89.356s for 315ms&lt;br&gt;Hamstring cast 69 of 77&lt;br&gt;Skill cast 260 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 89.671s for 285ms&lt;br&gt;Sever Artery cast 79 of 87&lt;br&gt;Skill cast 261 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 89.956s for 360ms&lt;br&gt;Gash cast 72 of 79&lt;br&gt;Skill cast 262 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 90.316s for 318ms&lt;br&gt;Hamstring cast 70 of 77&lt;br&gt;Skill cast 263 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 90.634s for 284ms&lt;br&gt;Sever Artery cast 80 of 87&lt;br&gt;Skill cast 264 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 90.918s for 354ms&lt;br&gt;Gash cast 73 of 79&lt;br&gt;Skill cast 265 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 91.272s for 323ms&lt;br&gt;Hamstring cast 71 of 77&lt;br&gt;Skill cast 266 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 91.595s for 278ms&lt;br&gt;Sever Artery cast 81 of 87&lt;br&gt;Skill cast 267 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 91.873s for 360ms&lt;br&gt;Gash cast 74 of 79&lt;br&gt;Skill cast 268 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 92.233s for 319ms&lt;br&gt;Hamstring cast 72 of 77&lt;br&gt;Skill cast 269 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Flurry at 92.594s for 1320ms&lt;br&gt;Flurry cast 12 of 12&lt;br&gt;Skill cast 270 of 288"
                                        src="https://render.guildwars2.com/file/4CEC34046638217807126F9BB1CADACB63E834D0/103014.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 93.914s for 279ms&lt;br&gt;Sever Artery cast 82 of 87&lt;br&gt;Skill cast 271 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 94.193s for 360ms&lt;br&gt;Gash cast 75 of 79&lt;br&gt;Skill cast 272 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 94.553s for 321ms&lt;br&gt;Hamstring cast 73 of 77&lt;br&gt;Skill cast 273 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 94.874s for 278ms&lt;br&gt;Sever Artery cast 83 of 87&lt;br&gt;Skill cast 274 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 95.152s for 359ms&lt;br&gt;Gash cast 76 of 79&lt;br&gt;Skill cast 275 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 95.511s for 240ms&lt;br&gt;Hamstring cast 74 of 77&lt;br&gt;Skill cast 276 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon rot-animfull"
                                        data-original-title="Final Thrust at 95.751s for 362ms&lt;br&gt;Final Thrust cast 12 of 12&lt;br&gt;Skill cast 277 of 288"
                                        src="https://render.guildwars2.com/file/71EB0DF5243A382A100E5ACB0870994D59BC47B7/103005.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 96.113s for 280ms&lt;br&gt;Sever Artery cast 84 of 87&lt;br&gt;Skill cast 278 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 96.393s for 360ms&lt;br&gt;Gash cast 77 of 79&lt;br&gt;Skill cast 279 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 96.753s for 321ms&lt;br&gt;Hamstring cast 75 of 77&lt;br&gt;Skill cast 280 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 97.074s for 280ms&lt;br&gt;Sever Artery cast 85 of 87&lt;br&gt;Skill cast 281 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 97.354s for 361ms&lt;br&gt;Gash cast 78 of 79&lt;br&gt;Skill cast 282 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 97.715s for 316ms&lt;br&gt;Hamstring cast 76 of 77&lt;br&gt;Skill cast 283 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 98.031s for 281ms&lt;br&gt;Sever Artery cast 86 of 87&lt;br&gt;Skill cast 284 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Gash at 98.312s for 363ms&lt;br&gt;Gash cast 79 of 79&lt;br&gt;Skill cast 285 of 288"
                                        src="https://render.guildwars2.com/file/44563D2C3BDCEB1524D2DB0F23713347CDE93D32/103004.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Hamstring at 98.675s for 198ms&lt;br&gt;Hamstring cast 77 of 77&lt;br&gt;Skill cast 286 of 288"
                                        src="https://render.guildwars2.com/file/E2DF06E072A837280306F7A7DA2FEA399ABAAEC7/104137.png"
                                    />
                                </span>
                                <span class="rot-skill">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Impale at 98.954s for 361ms&lt;br&gt;Impale cast 10 of 10&lt;br&gt;Skill cast 287 of 288"
                                        src="https://render.guildwars2.com/file/4876CF1E0673120898A5EEFE9D2409741E182EAE/103060.png"
                                    />
                                </span>
                                <span class="rot-skill rot-small">
                                    <img
                                        class="rot-icon"
                                        data-original-title="Sever Artery at 99.315s for 278ms&lt;br&gt;Sever Artery cast 87 of 87&lt;br&gt;Skill cast 288 of 288"
                                        src="https://render.guildwars2.com/file/3040B9E8344BF32EA5ADB3FB632C4F01BFD0927D/103003.png"
                                    />
                                </span>
                            </div>
                        </div>
                        <!-- -->
                    </div>
                </div>
                <div class="mt-3 mb-3" style="display: none">
                    <h2 class="text-center">
                        The
                        <a
                            href="https://github.com/Krappa322/arcdps_healing_stats/releases"
                        >
                            healing stats addon
                        </a>
                        is now officially supported by Elite Insights. Make sure
                        to download and enable its logging features.
                    </h2>
                </div>
            </div>
            <div class="footer">
                <div>
                    Time Start: 2025-12-10 18:59:33 +02:00 | Time End:
                    2025-12-10 19:01:15 +02:00 | EVTC Duration: 01m 41s 570ms
                </div>
                <div>
                    Instance Start: 2025-12-10 18:32:43 +02:00 | Instance IP:
                    69.9.156.18
                </div>
                <div>
                    ARC: EVTC20251123.125813 | GW2 Build: 192224 | Trigger ID:
                    16199 | Log ID: 524550 | Map ID: 1154 | Elite Insights
                    3.16.0.0
                </div>
                <!-- -->
                <!-- -->
                <div class="mb-2">
                    File recorded by: Sota Jarmo - Arzon.5629
                </div>
            </div>
        </div>
    </body>
</html>
